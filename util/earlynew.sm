class term(my_sym, parent, nson)
begin fetch scanner, rmove, predictor, completer;

      proc scanner(start_set, cur_set, deriv, sym)
        if my_sym = sym then
	   return(parent.rmove(nson, start_set, cur_set, deriv, sym))
	else
	   freturn
	fi;

      proc rmove(ns, start_set, cur_set, deriv, deriv_incr)
	freturn;

      proc predictor(start_set, cur_set, rule_name)
	freturn;

      proc completer()
        freturn;

end term;

class nonterm(my_name, parent, nson)
begin fetch scanner, rmove, predictor, completer;

      proc scanner(start_set, cur_set, deriv, sym)
	freturn;

      proc rmove(ns, start_set, cur_set, deriv, deriv_incr)
	freturn;

      proc predictor(start_set, cur_set, rule_name)
	if rule_name = my_name then
	   return(RULES[my_name].predictor(start_set, cur_set, rule_name))
	else
	   freturn
	fi;

      proc completer(start_set, cur_set, deriv, deriv_incr)
	return(parent.rmove(nson, start_set, cur_set, deriv, deriv_incr));
end nonterm;

class body(sons, parent, nson)
begin fetch scanner, rmove, predictor, completer;

      proc scanner(start_set, cur_set, deriv, sym)
	freturn;

      proc rmove(n, start_set, cur_set, deriv, deriv_incr)
        if n < sons.size then
	   I[cur_set].additem(sons[n+1], start_set, deriv, deriv_incr)
	else
	   parent.rmove(nson, start_set, cur_set, deriv, deriv_incr)
	fi;

      proc predictor(start_set, cur_set, rule_name)
	freturn;
end body;
