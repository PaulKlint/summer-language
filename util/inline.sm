#********************************************************
*							*
* inline -- find inline executable sequences		*
*							*
* This program is a postprocessor for the assembly	*
* language output produced by the SUMMER compiler (sumc)*
* It is used to change some frequently occurring	*
* interpreted instructions into machine code sequences	*
* to speed up their execution.				*
*	loc, int, asloc, void, undef			*
* Each modified code sequence is preceeded by an	*
* instruction of the form:				*
*	ex x		 switch to direct mode		*
*	(inline instructions)				*
*	jmp	evloop	 switch back to interpretor	*
* X:	(interpreted instructions)			*
********************************************************#
const INT := 0, EX := 1, NINTEGERS := 100;
const TRUE := 1, FALSE := 0;
var mode := INT, xn := 0, firstint := TRUE;
var iccnt := 0, excnt := 0;
var fin, fout;

proc intsep()
  if firstint = TRUE then
     fout.put('.byte ');
     firstint := FALSE;
  else
     fout.put(',')
  fi;
proc ic1(x)
(var c;
    lit(x) & lit(',') &
    (c := break(',') & move(1) | c := rtab(0)) &
    iccnt := iccnt + 1 &
    return(c);
);
proc loc() return(ic1('loc'));

proc asloc() return(ic1('asloc'));

# load temprarily disabled #
proc load() return(ic1('XXload'));

proc int()
( var i;
  try i := ic1('int') & integer(i) < NINTEGERS & return(i) yrt | freturn;
);

proc void(first)
( if first = TRUE then mode = EX else TRUE fi &
  lit('void') & (lit(',') | '') & iccnt := iccnt + 1 );

proc undef()
( lit('undef') & (lit(',') | '') & iccnt := iccnt + 1 );

proc gen(s, n, m)
( var c, x;
  if mode = INT
  then intsep;
       fout.put('ex\n.long X', xn, '\nmovl _argbase,r9\n');
       mode := EX;
       excnt := excnt + 1;
  fi;
  scan s
  for if x := find('%') fails then fout.put(s)
      else fout.put(x, n);
	   move(2);
	   if x := find('%') fails then fout.put(rtab(0))
	   else move(2);
		fout.put(x, m, rtab(0))
	   fi
      fi
  rof;
  fout.put('\n')
);


proc exp_inline()
( var n, m, c;

  mode := INT;
  firstint := TRUE;
  while ~rpos(0)
  do
  if n := loc then
     if m := asloc
     then if void(FALSE) then gen('movl %n*4(r9),%m*4(r9)', n, m)
          else gen('movl %n*4(r9),(r10)+;movl -4(r10),%m*4(r9)', n, m)
          fi
     else gen('movl %n*4(r9),(r10)+', n, '')
     fi
  elif n := int then
     if m := asloc
     then if void(FALSE) then gen('addl3 $%n*8,_intbase,%m*4(r9)', n, m)
          else gen('addl3 $%n*8,_intbase,(r10)+;movl -4(r10),%m*4(r9)', n, m)
	  fi
     else gen('addl3 $%n*8,_intbase,(r10)+', n, '')
     fi
  elif undef then
     if m := asloc
     then if void(FALSE) then gen('movl _undefin,%m*4(r9)', m, '')
          else gen('movl _undefin,(r10)+; movl _undefin,%m*4(r9)', m, '')
	  fi
     else gen('movl _undefin,(r10)+', '', '')
     fi
  elif n := load then
     if m := asloc then
        if void(FALSE) then gen('movl $%n,%m*4(r9)', n, m)
        else gen('movl $%n,(r10)+;movl -4(r10),%m*4(r9)', n, m)
	fi
     else gen('movl $%n,(r10)+', n, '')
     fi
  elif n := asloc then
     if void(FALSE) then gen('movl -(r10),%n*4(r9)', n, '')
     else gen('movl -4(r10),%n*4(r9)', n, '')
     fi
  elif void(TRUE) then
     gen('tstl -(r10)', '', '')
  else
     c := break(',') & lit(',') | c := rtab(0);
     if mode = INT then
	intsep;
        fout.put(c)
     else
        fout.put('jmp evloop\n');
	fout.put('X', xn, ':\n');
	xn := xn + 1;
	firstint := TRUE;
	intsep;
	fout.put(c);
	mode := INT;
     fi;
  fi;
  od;
  if mode = INT then fout.put('\n')
  else
     fout.put('jmp evloop\n');
     fout.put('X', xn, ':\n');
     xn := xn + 1;
     mode := INT;
     firstint := TRUE;
  fi;
);
proc error(s)
( stand_er.put('ERROR: ', s, '\n'); stop(1) );
program inline(args)
( var line;

  case args.size of
  0:	fin := stand_in; fout := stand_out,
  1:	if fin := file(args[0], 'r') fails
	then error('Can''t open ' || args[0])
	fi;
	fout := stand_out,
  2:	if fin := file(args[0], 'r') fails
	then error('Can''t open ' || args[0]) fi;
	if fout := file(args[1], 'w') fails
	then error('Can''t create ' || args[1]) fi
  esac;

  fout.put('.set\tex,63\n');
  while line := fin.get
  do scan line
     for if ~lit('.byte ') | lit('''')
	 then fout.put(line, '\n')
	 else
	      exp_inline
	 fi
     rof
  od;
  stand_er.put(excnt, ' seqs of ', iccnt/excnt, ' instructions\n');
)
