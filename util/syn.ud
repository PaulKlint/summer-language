# flex -- flexible arrays #

class flex ()
begin fetch update, retrieve, append, delete, size, next, 
            index, top;
      store size : change_size;

      var mem, size;

      proc extend()
      ( var i, m1 := array(mem.size + 10, undefined);
        for i in mem.index do m1[i] := mem[i] od;
        mem := m1
      );

      proc retrieve(i)
      if 0 <= i < size then return(mem[i]) else stop(-1) fi;

      proc update(i, v)
      if 0 <= i < size then return(mem[i] := v) else stop(-1) fi;

      proc append(v)
      ( if size >= mem.size then extend fi;
        mem[size] := v;
        size := size + 1;
        return(v)
      );

      proc delete(n)
      ( if size - n <= 0 then freturn else size := size - n fi );

      proc change_size(n)
      if n < 0 then freturn
      else
         if n >= mem.size then extend fi;
         return(size := n)
      fi;

      proc next(state)
      ( if state = undefined then state := 0 fi;
        if state < size then
           return([mem[state], state + 1])
        else
           freturn
        fi
      );

      proc index() return(interval(0, size - 1, 1));

      proc top()
      if size = 0 then freturn else return(mem[size-1]) fi;

init: mem := array(10, undefined);
      size := 0;
end flex;

class body(sons)
begin fetch sons, print;
      store rep;
      var rep;

      proc print()
      ( var s, pre := '', pos := '', sep := '';
	if sons.size >1 then pre := '('; pos := ')' fi;
	if rep ~= undefined then
	   pos := pos || if rep = 0 then '*' else '+' fi
        fi;
	put(pre);
	for s in sons do put(sep); sep := ' '; s.print od;
	put(pos);
      );
end body;

class alt(sons)
begin fetch sons, print;
      store rep;
      var rep;

      proc print()
      ( var s, pre := '', pos := '', sep := '';
        if sons.size > 1 then pre := '('; pos := ')' fi;
	if rep ~= undefined then
	   pos := pos || if rep = 0 then '*' else '+' fi
        fi;
	put(pre);
	for s in sons do put(sep); sep := '|'; s.print od;
	put(pos);
      );
end alt;

class list(prim, term, rep)
begin fetch print;
      proc print()
      ( put('{'); prim.print; put(' ', term);
        if rep = 0 then put('}*') else put('}+') fi
      );
end list;

class term(sym)
begin fetch sym, print;
      store rep;
      var rep;
      proc print()
      ( put('''', sym, '''');
        if rep ~= undefined then put(if rep = 0 then '*' else '+' fi) fi
      );
end term;

class nonterm(sym)
begin fetch sym, print;
      store rep;
      var rep;

      proc print()
      ( put('<', sym, '>');
	if rep ~= undefined then put(if rep = 0 then '*' else '+' fi) fi
      );
end nonterm;

var rules := table(100, undefined);
