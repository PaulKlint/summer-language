	#  LEXICAL PROCEDURES			#

var	kars := kartab.index,		# array with symbols from PKF #
	karsize := kartab.size,		# number of symbols #
	in_code_spec := FALSE;		# flag to force reading of summer_text #
					# in a <code-spec> #

proc ermsg(mess, ln)
(
        put(string(ln).right(5,' '),': ',mess,'\n');
        errcnt := errcnt + 1;
);

# get_string reads a character-constant from the input.	#
# The quote character can be denoted by doubling it.	#
# Note that escape sequences are not converted . This	#
# means that things like '\' are not detected.		#

proc get_string ()
(
	const quote := '''';
	var symbol := '';

	scan line
	for	var s := cursor;
		while break(quote) & lit(quote||quote)
		do	od;

		if ~lit(quote)
		then	ermsg('Newline not allowed in string.\n',lnr)
		else	move(-1);
		fi;

		s := cursor - s;
		symbol := move(-s);
		move(s);

		if lit(quote)
		then	if symbol = ''
			then	ermsg('Character constant missing.\n',lnr)
			fi
		fi
	rof;
	return(symbol);
);

# comment() skips comment in the metalanguage.			#
# An error message is printed when the comment isn't terminated.#

proc comment()
(
	while line.break('#') fails do
		if line := scan_string(fsyn.get()) fails
		then ermsg('Comment not terminated.',lnr);
		     line := scan_string(' ');
		     return
		else lnr:=lnr+1;
		fi;
	od;

	if line.move(1) fails
	then if line:= scan_string(fsyn.get())
	     then lnr:=lnr+1;
	     fi;
	fi;
);

# nextsym() is the scanner for the parsergenerator. It reads	#
#  the next symbol from the input , puts it in the variable sy	#
#  and puts the type in t_sy.					#
#  The procedure tries to recognise the symbols in the		#
#  following order :						#
#	1.	identifiers (lower-case letters + hyphens)	#
#	2.	keywords (upper-case letters)			#
#       3.	a string constant in the grammar (a quote)	#
#       4.      a character constant ( e.g. ::= )		#
#  When neither of these possibilities succeeds, comment is	#
#  checked or an error message is printed. Of course, a new	#
#  line is read, when necessary.				#

proc nextsym()
(
	if in_code_spec = TRUE
	then
	   get_summer_text();
	   return;
	fi;
	while TRUE do
		line.span(' \t')|OKE;
		if sy := line.any(lower) succeeds
                then    sy := sy ||
			  line.span(lower||digit||'-'||'_').replace('-','_') |
			  OKE;
			t_sy := predef['ident'];
			return;
		elif sy := line.any(upper) succeeds
		then	sy := sy || line.span(upper) | OKE;
			if kartab[sy] ~= undefined
			then	t_sy := kartab[sy]
			else	t_sy := predef['keyword'];
			fi;
			return
		elif line.lit('''')
		then	t_sy := predef['string'];
			sy := get_string;
			return;
		elif line.rpos(0) succeeds
                then    (line := scan_string(fsyn.get()) & lnr:=lnr+1) |
			(t_sy:=predef['EOF'] & sy := 'EOF' & return);
		else	var i;
			for i in interval(karsize-1,0,-1)
			do	sy := kars[i];
				if line.lit(sy) succeeds
				then	t_sy := kartab[sy];
					return;
				fi;
			od;
			sy := line.move(1);
			if sy = '#'
			then	comment();
			else	ermsg('Character "' || sy ||
					'" not in legal context.',lnr);
			fi;
		fi;
	od;
);

# get_summer_text reads a set of SUMMER statements from the input.	#
# This procedure is called when labels are specified by		#
# actions. Note that in this situation layout is important.	#
# The keyword EXIT or a new label or the beginning of a		#
# new rule must be denoted at the beginng of a line. Other-	#
# wise they are assumed to belong to the collection of 		#
# statements. They may be preceded by spaces and tabs.		#

proc get_summer_text()
(
	assert in_code_spec = TRUE;
	in_code_spec := FALSE;
	sy := '# line: ' || string(lnr) || '#\n' ;

	while TRUE 
	do	line.span(' \t')|OKE;

		if ( (line.lit('/')&line.move(-1))        # new label ? #
		   | (line.lit('EXIT')&line.move(-4))     # EXIT-clause ? #
		   | (line.lit('<')&line.move(-1)) )      # new rule ? #

		then	return
		else
			if line.rpos(0) fails
			then
				sy := sy || line.rtab(0) || '\n' ;
			fi;

			t_sy := predef['summer_text'];
			if line := scan_string(fsyn.get())
			then	lnr := lnr + 1
			else	line := scan_string(' ');
				return
			fi
		fi
	od
);
