# used files:
-r-xr-xr-x  1 paulk      133120 Oct  9 23:43 /userfs/summer/paulk/sys/pgen/pg
-rw-r--r--  1 paulk        1641 Jan  7  1982 /userfs/summer/paulk/sys/pgen/pglib
-rw-r--r--  1 paulk        7992 Jan  7  1982 pg.syn
-rw-r--r--  1 paulk        4105 Jan  7  1982 pg.ns
#
const
	lower := 'abcdefghijklmnopqrstuvwxyz',
	upper := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
	digit := '0123456789',
	ASCII := ' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';

var
	lnr := 0, sy, t_sy, line := scan_string(' '), errcnt := 0;

proc SET(syms)
(	var i, b := bits(SETSIZE,0);

	for i in syms
	do
		b[i] := 1;
	od;
	return(b);
);


proc UN2(s1,s2)
(	
	return(s1.disj(s2))
);


proc UN3(s1,s2,s3)
(
	return((s1.disj(s2)).disj(s3))
);


proc error(mess,ln)
(
	ermsg(mess || ' expected', ln);
);


proc testsymee(exp1, exp2, dont_skip, message)
(	testsym(UN2(exp1, exp2), dont_skip, message);
);

proc testsymeee(exp1, exp2, exp3, dont_skip, message)
(	testsym(UN3(exp1, exp2, exp3), dont_skip, message);
);
proc testsymdd(exp, dont_skip1, dont_skip2, message)
(	testsym(exp, UN2(dont_skip1, dont_skip2), message);
);

proc testsym(exp,dont_skip,message)
(	if exp[t_sy] = 0
	then	var mess := '  ',
		    nskipped := 0,
		    erlnr := lnr,
		    both := UN2( exp,dont_skip);


		 	while both[t_sy] = 0
			do	if nskipped < 6
				then	if nskipped < 5
					then mess := mess || sy || ' '
					else mess := mess || sy || ' ...';
					fi;
					nskipped := nskipped + 1;
				fi;
				nextsym;
			od;
                        if mess ~= '  ' 
                        then    mess := ' "'|| mess || '"' || ' skipped.';
				if lnr - erlnr > 2 then
					mess := mess ||
						'\n       scan resumed at "' ||
						sy || '", in line '||string(lnr)
				fi
			fi;
                        if  message ~= ''
			then error(message,erlnr);
			fi;
			if mess ~= '  '
			then ermsg(mess,erlnr);
			fi;
	fi;
);
# user defined:
-rw-r--r--  1 paulk       42730 Jan  7  1982 pg.ud
#
#****************************************************************
*								*
*	pg - parser generator with error recovery.		*
*								*
*			by					*
*								*
*		Gert Florijn & Geert Rolf,			*
*								*
*		  Mathematisch Centrum				*
*		  January 15, 1981				*
*								*
* Revision history:						*
* aug 81 (paulk)						*
*	- Parsing routines rewriten to use pgen itself for	*
*	  the construction of a pgen input parser.		*
*	- Some optimizations made in code generation.		*
*	  (testsym_code)					*
*								*
****************************************************************#	  

const	EMPTY_STATE	:= 0,	#	state constants		#
	UNDECIDED_STATE	:= 1,
	NONEMPTY_STATE	:= 2,
	TRUE		:= 1,	#	boolean constants	#
	FALSE 		:= 0,
	OKE		:= 1;	#	prevention for unwished failure	#

var
	cout,				# file for generated code	  #
	tout,				# file for generated tables	  #
	sout,				# file for generated sets	  #
	fout,				# file for generated firstsets    #
	fsyn,			        # input file with grammar	  #
	startsym,		        # start symbol of the grammar	  #
        rule_cnt,			# number of nont.'s in the grammar#
	parent_node,			# communicates parent info between #
					# parsing procedures #
	rule_name,			# communicates current rule name #
					# between parsing procedures #
	rule;				# similar as above #

# flex is used to obtain an automatic expanding array with
* limited possibilities. Only update, retrieve
* and size can be used. When the update index exceeds
* the current range, the values are copied to a	larger array
#

class flex(n,df)
begin	fetch	update,retrieve,size;
	var	size,step,far;

	proc retrieve (i)
	(	if 0 <= i < size
		then return(far[i])
		else freturn
		fi;
	);

	proc update (i,val)
	(	if i >= far.size
		then	var j, help := array(i+step,df);

			for j in interval(0,size - 1,1)
			do	help[j] := far[j]	od;
			far := help;
		fi;
		size := i + 1;
		far[i] := val;
	);

init :	far := array(n,df);
	step := 5;
	size := 0;
end flex;

# CLASS GENERAL NODE
*
* Is used as general node structure. It's a superclass
* of various other type of nodes. The meaning of the 
* fields :
*	children :	flexible array with children-nodes.
*			The link is made by the children, via
*			a call of make-link.
*	child_count :   number of children nodes.
*	state :		indicates whether the node can produce 
*			the empty sentence or not. Can have 
*			three values: EMPTY_STATE, NONEMPTY_STATE and 
*			UNDECIDED_STATE.
*	firstsyms :	table that contains the first-symbols
*			of this node.
*	first_UND :	Used during information retrieval
*			process. Equals the number of children
*			that influence this node's firstsymbols, but
*			whose own first-symbols are not determined
*			yet.
*	make_link :	makes a link between the current node and
*			one of it's children-nodes.
#

class general_node()
begin
	fetch	children,child_count,state,firstsyms,first_UND,make_link;
	store	child_count,state,first_UND,firstsyms;
	var	children,child_count,state,first_UND,firstsyms;

	proc make_link(child)
	(
		children[child_count] := child;
		if type( child ) ~= 'alt'
		then 	children[ child_count].seqnr := child_count;
		fi;
		child_count:=child_count+1;
	);
init :
	child_count := 0;
	children := flex(5,undefined);
	first_UND := 0;
	firstsyms := table(10,0);
end general_node;

# RULE ROOT
* root of the tree, which reflects a production rule
* (see general_node also)
*
*	name		:	name of the production rule.
*	follow		:	table, which holds the follow symbols,
*				when necessary.
*	initcode	:	code that must be printed at the head
*				of the procedure that will handle this
*				rule. Can also contain declarations of
*				variables made by PGEN.
*	exitcode	:	code that must be performed at the end
*				of the procedure.
#

class rule_root(naam)
begin
	subclass of general_node;
	fetch name,follow,initcode,exitcode;
	store follow,initcode,exitcode;
	var   name,follow,initcode,exitcode;
init :
	state := UNDECIDED_STATE;
	name  := naam;
	initcode := '';
end rule_root;

# BODY OR ALT NODE
* structure for body nodes as well as alt nodes.
* ( see also general node )
*
*	parent		:	link to the parent node.
*	action		:	contains action related to this node.
#

class body_or_alt_node(par,toestand)
begin
	subclass of general_node;

	fetch	parent, action ;
	store   action ;
	var	parent, action ;
init :
	parent := par;
	state := toestand;
	parent.make_link(self);
end body_or_alt_node;

# BODY
* node which contains the body structure
* (see also body_or_alt node)
*
*	seqnr		:	sequence number of this node in the
*				children array of its parent.
*				Therefore, parent.children[seqnr] = self.
*	subtype		:	contains the subtype of the enclosing
*				structure, e.g. compound, option, etc.
#

class body(par,toestand)
begin
	subclass of body_or_alt_node;

	fetch 	seqnr,subtype, rep;
	store	seqnr,subtype : setsubtype, rep : setrep;
	var	seqnr,subtype, rep ;

	proc setsubtype(s)
	(	case s of
		'option':
		'list':
		'compound':
			return(subtype := s)
		esac
	);

	proc setrep(r)
	(	case r of
		'+':
		'*':
		'norep':
			return(rep := r)
		esac
	);
init:
	rep := 'norep';


end body;

# ALT
* represents an alternative.
* (see also body_or_alt node)
*
*	point		:	sequence number of the last child,
*				which determines the first of this node.
#

class alt(par,toestand)
begin
        subclass of body_or_alt_node;

	fetch	point;
	store	point;
	var	point;

end alt;

# TERM
* reflects a terminal symbol
* (see also the classdeclarations above)
*
*	symbol		:	the terminal symbol.
#

class term(par, sym)
begin
	fetch parent, state, subtype, rep, symbol,seqnr,ass_var,first_UND, action ;
        store state, subtype : setsubtype, rep : setrep, symbol,seqnr, ass_var, action ;
        var   parent, state, subtype, rep, symbol,seqnr,ass_var, first_UND, action ;

	proc setsubtype(s)
	(	case s of
		'keyword':
		'string':
		'lex-id':
			return(subtype := s)
		esac
	);


	proc setrep(r)
	(	case r of
		'+':
		'*':
		'norep':
			return(rep := r)
		esac
	);

init:	symbol := sym;
	rep    := 'norep';
	parent := par;
	parent.make_link(self);
	state  := NONEMPTY_STATE;
	first_UND := 0;

end term;

# NONT
* node, which reflects a call of another production rule.
* (see also the comments above)
*
*	name		:	name of the called production rule.
#

class nont(par,nam)
begin
	fetch parent, state, subtype, rep, name,first_UND, seqnr,ass_var, action ;
	store state,subtype,rep : setrep, first_UND, seqnr,ass_var, action ;
	var   parent, state, subtype, rep, name,first_UND, seqnr,ass_var, action ;

	proc setrep(r)
	(	case r of
		'+':
		'*':
		'norep':
			return(rep := r)
		esac
	);


init:	parent := par;
	name := nam;
	subtype := 'nonterm';
	rep  := 'norep';
	state := UNDECIDED_STATE;
	first_UND := 1;
	parent.make_link(self);

end nont;

# TT ENTRY
* entry for a production rule in the treetable.
*
*	root		:	root node of the production rule.
*	reftab		:	table, which contains the calling
*				nodes in other production rules.
*	filled_in	:	flag, used when determining the
*				first symbols of all nodes. True
*				when the first of the production rule is
*				carried over to its callers.
#

class tt_entry()
begin
	fetch root, reftab,filled_in;
	store root, reftab,filled_in;
	var   root, reftab := table(5, undefined),filled_in:=FALSE;

end tt_entry;

var	symtab := table(20,undefined),

	# symtab is used to store the keywords found in the grammar.
	  The keywords are mapped to lower-case letters before being
	  entered.
	#

	chartab := table(20,undefined),

	# chartab contains the character constants found in the grammar.
	  The constants are stored in their initial form, so no trans-
	  formations are performed.
	#

	remsets := table(20,undefined),

	# remsets is used for the declaration of the so-called remainder
	  sets. When a remainder-set is declared, i.e. when the declaration
	  is written on the file sout, the name of the set is entered
	  in this table. This allows the code generator to check whether
	  a set is declared or not. How and when a set is declared can be
	  found in the procedure rdecl.
	#

	var_decl := table(5,undefined),

	# var_decl contains the names of the tags which were used
	  in a production-rule. The tags are used to pick up return
	  values of other procedures. All tags within one production
	  are declared at the start of the production. This declaration
	  code is stored in the initcode-field of the root of the tree.
	#

        treetab := table(150,undefined), 

	# treetab contains the roots of all the trees for rules in
	  the grammar. 
	#

	upredef := table(4,undefined),

	 # upredef contains the name of the user-defined lexical
	  symbols. These names are specified in the grammar 
	  using the:
		LEXICAL  ....
	  clause. The hyphens are immediately substituted by 
	  underlines.
	#

	labeltab,

	# labeltab is used to store the labelnames with
	  the nodes to which the label was associated. The table
	  is initialized before a new production is dealt with.
	#

	path := table(5,undefined);

	# path is used when a follow set is determined. All the
	  nodes that are involved in the current search for fol-
	  low-symbols, are entered in this table. Whenever we
	  reach a node that is already present in path, the search
	  does not continue at that point. 
	  This table is needed to prevent endless search for fol-
	  low-symbols.
	#

#******************************************************#
#                                                      #
#						       #
#	    SUPPORTING ROUTINES			       #
#  	    (called from pg.syn)		       #
#						       #
#******************************************************#

# place_label stores the node for which a label has
* been read in the table 'labeltab'. The nodes in
* labeltab are visited when the label is read
* together with some Summer statements at the end
* of a production rule.
#

proc place_label(node,label)
(
	if label ~= undefined
	then	if labeltab[label] = undefined
		then	labeltab[label] := flex(3,undefined)
		fi;
		labeltab[label][labeltab[label].size] := node
	fi
);

# get_first assembles the firstset for a node. Note
* the different algorithm for an alt node. get_first
* is only called with node being an alt, a body or a rule_root.
#

proc get_first( node )
( 	var i, j;

 	if node.firstsyms.size > 0
  	then return;
  	fi;

  	if type(node) = 'alt'
  	then  scan node
	      for   if point = undefined
		    then point:= child_count-1;
		    fi;

		    for i in interval(0,point,1)
		    do
			if type(children[i]) = 'term'
			then	firstsyms[children[i].symbol] := 
				      	firstsyms[children[i].symbol] + 1;
			else    var childnode :=
					if type(children[i]) = 'nont'
					then 	treetab[children[i].name].root;
                                        else    children[i];
					fi;

				for j in childnode.firstsyms.index
                                do      firstsyms[j] := firstsyms[j] + 1;
				od;
			fi;
		    od;
	      rof;
	else	scan node
		for
                	for i in interval(0,child_count-1,1)
			do
				for j in children[i].firstsyms.index
				do	firstsyms[j] := firstsyms[j] + 1
				od;
			od;
		rof;
  	fi;
);

# backpatch patches the information of curnode one level upwards.
* The algorithm is a clear and straightforward implementation
* of the relations that were specified in the implementation
* description. Together with some actions within the parsing
* routines, this procedure forms the first-phase of the 
* information-retrieval process
#

proc backpatch( curnode )
(
  	scan curnode
	for	if type(curnode) = 'alt'
		then
			if first_UND > 0
			then	parent.first_UND := parent.first_UND + 1;
			fi;

			if state = EMPTY_STATE
			then	parent.state := EMPTY_STATE
			fi;
		else
			if state = NONEMPTY_STATE
			then
				parent.state := NONEMPTY_STATE;
				if parent.point = undefined
				then 	parent.point := seqnr;
				fi;
			fi;

			if first_UND > 0 & parent.point = undefined
			then
				parent.first_UND := parent.first_UND + 1;
			fi;

		fi;
  	rof;
);

# fill-in is used in the second phase of the information
* retrieval process. The information of the parameter node
* is passed on to the parent-level. This parent node
* now decides which actions it must do. When the parent
* node is determined, this procedure is called recursively.
* The first time, fill-in is called with a nonterminal. This
* call is performed by roll-up(), which passes on the information
* of a determined production to the reference points.
#

proc fill_in(node)
( 
	var i;
	if type(node.parent) = 'alt'
	then
		scan node
		for
			if state = EMPTY_STATE
			then	if parent.point = undefined |
					seqnr < parent.point
				then	parent.first_UND := parent.first_UND-1;
				fi;
			elif parent.point = undefined | seqnr < parent.point
			then
				parent.state := NONEMPTY_STATE;
				parent.point := seqnr;
				parent.first_UND := 0;

				# Reset the information in the parent node
				  concerning point and first_UND
				#

				for i in interval(0,parent.point,1)
				do
					if parent.children[i].first_UND > 0
					then parent.first_UND :=
						parent.first_UND +1;
					fi;
				od;
			fi;

			if parent.first_UND = 0
                        then    get_first(parent);
				if parent.state = UNDECIDED_STATE
				then parent.state := EMPTY_STATE;
				fi;

				if parent.point = undefined |
					seqnr <= parent.point
				then	fill_in(parent);
				fi;
			fi;
		rof;
	else	
		# Parent node is a body node, therefore this node
		  is an alternative.
		#

		scan node 
		for	parent.first_UND := parent.first_UND-1;
			if state = EMPTY_STATE
			then parent.state := EMPTY_STATE;
			fi;

			if parent.first_UND = 0
                        then    get_first(parent);
				if parent.state = UNDECIDED_STATE
				then parent.state := NONEMPTY_STATE;
				fi;

				if type(parent) ~= 'rule_root'
				then	fill_in(parent);
				fi;
			fi;
		rof;
	fi;
);

# roll-up is a part of the second phase of the retrieval process.
* It keeps on filling-in references of productions that are
* determined, until there are no productions left, or some can not
* be determined. The latter case implies a left recursive set of rules
* The meaning of the variables is :
*
*	rule_cnt :	The number of productions in the grammar.
*	dec_cnt  :	The number of productions whose information
*			is determined.
*	l_dec_cnt:	The number of rules that were determined and not
*			yet filled-in, during the last pass over all productions.
*			When l_dec_cnt equals zero and not all rules
*			are determined yet, we have found a left recursion.
#

proc roll_up()
( 	var dec_cnt, l_dec_cnt, callset,pr;

  	rule_cnt := treetab.size;
  	dec_cnt := 0;

  	while dec_cnt < rule_cnt
  	do
		l_dec_cnt := 0;
		for pr in treetab.index
		do
	  		if treetab[pr].filled_in = FALSE
		        	& treetab[pr].root.first_UND = 0
	          	then  	treetab[pr].filled_in := TRUE;
				l_dec_cnt := l_dec_cnt + 1;

				for callset in treetab[pr].reftab.index
				do
					if callset.state = UNDECIDED_STATE
					then
						callset.state := treetab[pr].root.state ;
					fi;

					callset.first_UND := 0;
					fill_in(callset);
				od;
	  		fi;
		od;

		if l_dec_cnt = 0
		then
			freturn;
		else
			dec_cnt := dec_cnt + l_dec_cnt ;
		fi;
  	od;
);

#*******************************************************#
#							#
#							#
#		LL(1) CHECK				#
#							#
#*******************************************************#

# get_follow collects a set of followsymbols for a node.
* The right-neighbor of the node is examined; it's firstsymbols
* are added to the wanted followset. If this node is EMPTY_STATE,
* the process continues to do the same for the next node.
* If the end of a production rule is reached in this way,
* the firstsets of all calling nodes are added to the wanted
* followset.
*
* tmpfol contains the followset within the current production.
#

proc get_follow( node )
( 	var tmpfol := table(10,undefined);

	while type(node)~='rule_root' & node.seqnr=node.parent.child_count-1
	do	node:=node.parent.parent;
		if type(node) ~= 'rule_root' & node.rep ~= 'norep' & 
				node.subtype ~= 'list'
		then tmpfol := untab(tmpfol,node.firstsyms);
		     if path[node] ~= undefined
		     then	return( tmpfol )
		     fi;
		fi;
	od;

	if type(node) = 'rule_root'
	then
		if path[node] = undefined
		then
			if node.follow = undefined
			then	#  Determine the follow set of the production
				   Get the follow symbols of all the references
				   in other productions
			        #

				var foll := table(5,undefined), callnode;

				path[node] := 1;
				for callnode in treetab[node.name].reftab.index
				do
					foll := untab(foll,get_follow(callnode));
				od;
				path[node] := undefined;
				node.follow := foll;
			fi;
			return(untab(tmpfol,node.follow));
		else	return(tmpfol);
		fi;

	else	# Go to the right-neighbor-node.
		  Add the firstsymbols to the followset.
		  If this node can produce the empty sentence
		  get_follow is called recursively.
		#

		node := node.parent.children[node.seqnr + 1];

		case type(node) of

		'term' :	tmpfol[node.symbol] := 1,
		'nont' :	tmpfol := untab(tmpfol,
					treetab[node.name].root.firstsyms),
		'body' :	tmpfol := untab(tmpfol,node.firstsyms);
		esac;

		if node.state = NONEMPTY_STATE | path[node] ~= undefined
		then	return(tmpfol);
		else	path[node] := 1;
			tmpfol := untab(tmpfol,get_follow(node));
			path[node] := undefined;
			return(tmpfol);
		fi;
	fi;
);

# untab - returns the union of two tables #

proc untab(tab1,tab2)
( 	var i, h := table(5,undefined);
	for i in tab1.index
	do
		h[i] := tab1[i];
	od;
	for i in tab2.index
	do
		h[i] := tab2[i];
	od;
	return(h);
);

# LL1_check - checks the grammar for LL(1) violations #

proc LL1_check()
( 	var pr;

	for pr in treetab.index
	do
		restr1(treetab[pr].root,pr);
	od;
);

# pkf_code returns a string with the meta notation of the
* construction of the node. It's used to expose the error
* messages.
#

proc pkf_code(node)
( 	var str1;

	case type(node) of
        'term' : str1 := '''' || node.symbol || '''',
	'nont' : str1 := '<'||node.name||'>',
	'body' : var i,str2;
		 case node.subtype of
		 'compound' :	str1 := '(';str2 := ')',
		 'option' :	str1 := '[';str2 := ']',
		 'list' :	str1 := '{';str2 := '}';
		 esac;

		 str1 := str1 || ' .. ';
		 for i in interval(1,node.child_count-1,1)
		 do str1 := str1 || '| .. ';
		 od;
		 str1 := str1 || str2;
	esac;

	case node.rep of
	'norep' : return(str1),
	'+' : return(str1 || '+'),
	'*' : return(str1 || '*');
	esac;
);

# put_err_syms - prints the symbols involved in an error #

proc put_err_syms(node,syms)
(
	var i, sep := '';

	put(' Symbols : ');
	for i in syms
	do	put(sep, i);
		sep := ' , ';
	od;
	put('\n');
);

# restr1 - checks for restriction 1 errors: the firstsets of
* two or more possibilities in the grammar must be disjunct.
#

proc restr1(node,name)
( 	var i,errsyms := table(5,undefined),emptycount := 0;

	for i in node.firstsyms.index
	do
		if node.firstsyms[i] > 1
		then errsyms[i] := 1;
		fi;
	od;

	if errsyms.size > 0
	then restr1_err(node,name,errsyms.index);
	fi;

	for i in interval(0,node.child_count-1,1)
	do
		restr2(node.children[i],name);

		if node.children[i].state = EMPTY_STATE
		then	emptycount := emptycount + 1
		fi

	od;

	if emptycount >= 2
	then	restr1_err(node,name,[]);
		put(' ',emptycount,' alternatives can be empty.\n');
		put(' The alternatives involved are : ');
		for i in interval(0,node.child_count-1,1)
		do	if node.children[i].state = EMPTY_STATE
			then	put(i+1,'  ');
			fi;
		od;
		put('\n\n');
	fi;
);

# restr1_err - error message handler for LL(1) restriction 1 errors #

proc restr1_err(node,name,syms)
(
	var i, j, error;
	put('\n Restriction 1, rule : ',name,'\n');
	if type(node) ~= 'rule_root'
	then put(' In : ',pkf_code(node),'\n');
	fi;
	
	if syms.size > 0
	then
		put_err_syms(node,syms);

		put(' the symbols occur in:\n');
		for i in interval(0,node.child_count - 1 ,1)
		do
			error := 0;
			for j in syms
			do
				if node.children[i].firstsyms[j] ~= 0
				then
					error := 1;
				fi;
			od;
			if error = 1
			then
				put('\talternative ',i + 1,'\n');
			fi;
		od;
	fi;
	errcnt := errcnt + 1;
);

# restr2 - checks for restriction 2 errors: the firstset and the
* set of symbols, that can succeed an optional construction
* must be disjunct. Note that a sequence partially behaves like an option.
#

proc restr2(node, name)
( 	var i, follow,errsyms:= table(5,undefined);

	for i in node.firstsyms.index
	do
                if node.firstsyms[i] > 1
		then	errsyms[i] := 1;
		fi;
	od;

	if errsyms.size > 0
	then	restr2_err(node,name,errsyms.index);
		errsyms:=table(5,undefined);
	fi;

	for i in interval(0, node.point - 1, 1)
	do
		if type(node.children[i]) = 'body'
		then
			restr1(node.children[i],name);
		fi;
	od;

	for i in interval(node.point, node.child_count - 1, 1)
	do
		if type(node.children[i]) = 'body'
		then
			restr1(node.children[i], name)
		fi;

		if node.children[i].state = EMPTY_STATE |
			node.children[i].rep = '+'
		then
			path[node.children[i]] := 1;
			follow := get_follow(node.children[i]);
			path[node.children[i]] := undefined;

			if type(node.children[i]) = 'term'
			then
				if follow[node.children[i].symbol] ~= undefined
				then
				   restr2_err(node.children[i],name,
					[node.children[i].symbol]);
				fi
			else
				var x,
				chno := if type(node.children[i]) = 'body'
					then node.children[i]
					else
					   treetab[node.children[i].name].root;
				        fi;

				for x in chno.firstsyms.index
                                do
                                        if follow[x] ~= undefined
					then errsyms[x] := 1;
                                        fi;
                                od;

				if errsyms.size > 0
				then
				   restr2_err(node.children[i],
					name,errsyms.index);
				     errsyms:=table(5,undefined);
				fi;
			fi;
		fi;
	od;
);

# restr2_err - error message handler for LL(1) restriction 2 errors #

proc restr2_err(node,name,syms)
(
	put(' Restriction 2, rule : ',name,'\n');
	put(' In : ');
	if type(node) = 'alt'
	then	var i;
		for i in interval(0,node.point,1)
		do put(pkf_code(node.children[i]),' ');
		od;
		put('\n');
	else	put(pkf_code(node),'\n');
	fi;

	put_err_syms(node,syms);
        errcnt := errcnt + 1;
);

#*******************************************************#
#							#
#		CODE GENERATION				#
#							#
#*******************************************************#

# gencode - generates in a recursive way, code for the whole grammar and
* calls fdecl and rdecl to declare first- and remainder-sets
* The meaning of the parameters :
*
*	curnode : the node for which code must be generated.
*	level   : string containing spaces; used to format the
*		  generated programs. Every recursion level implies
*		  further indenting.
*	curname : string that is used to get unique names for remainder-
*		  sets and first-sets. Every new recursion level adds
*		  a number to curname. The number added is the sequence-
*		  number of the current node in the children-array of it's
*		  parent_node.
*
* Note that firstsets are only declared when it's needed. This
* means that firstsets which consist of one symbol are globally
* represented by the set for that symbol. The name of a firstset
* is determined by the procedure get_first_name.
*
* The remaindersets are only mentioned, when they are declared.
* This can be checked by referring the table remsets. The remain-
* dersets are declared in the procedure rdecl.
*
* Body-nodes for constructions followed by a '+' can cause diffi-
* culties. When one of the alternatives of that body has state 
* EMPTY_STATE, the code must be visited when the empty sentence occurs.
* For these nodes, a repeat-until construction is simulated, by
* generating the following code :
*
*	(  var i_ ... := 0;  ( ... is the current name (curname))
*
*	   while ...[t_sy] = 1 | i_... = 0
*	   do
*		code for the body node
*		i_... := 1;
*	   od;
*	);
*
* This scheme ensures that the code for the body, and the associated
* actions are executed at least once, even when the empty sentence
* occurs. 
* Note that the state of the body-node must be EMPTY_STATE, and that the
* the corresponding construction must have been followed by a '+'.
* If this isn't true, then the normal code for such cases is generated.
#

proc gencode (curnode, level, curname)
( 	var i;

  case type(curnode) of
  'alt':
	rdecl(curnode,curname);
	put_action(curnode.action, level);

	for i in interval(0,curnode.child_count - 1, 1)
	do
	     gencode(curnode.children[i],level,curname || '_' || string(i));
	od;
	if get_first_name(curnode,curname) = 'f_'||curname
	then 	fdecl(curnode,curname);
	fi,

  'body':
        var ind := curnode.rep;

	if curnode.state = NONEMPTY_STATE & curnode.seqnr > 0
	then
                cout.put(level,testsym_code(curnode,curname,err_msg(curnode)));
	fi;
	case curnode.subtype of
	'compound':
		if ind ~= 'norep'
		then
			if ind = '+' & curnode.state = EMPTY_STATE
			then	cout.put(level,'( var i_',curname,' := 0;\n');
				level := level || '  ';
				cout.put(level,'while ', 
                                 get_first_name(curnode,curname),'[t_sy] = 1 | i_'
					,curname,' = 0\n');
			else	cout.put(level,'while ',
				get_first_name(curnode,curname),'[t_sy] = 1\n');
			fi;
			cout.put(level,'do\n');
			body_code(curnode,level || '  ',curname);
			if ind = '+' & curnode.state = EMPTY_STATE
			then	cout.put(level,'i_',curname,' := 1;\n');
			fi;
			cout.put(level,'od;\n');
			if ind = '+' & curnode.state = EMPTY_STATE
			then	level := level.substr(0,level.size-2);
				cout.put(level,');\n');
			fi;
		else
			body_code(curnode,level,curname);
		fi,
	'option':
		body_code(curnode,level,curname),
	'list':
		var tsco,defco;
                if ind = '+' & curnode.state = EMPTY_STATE
                then    cout.put(level,'( var i_',curname,' := 0;\n');
                        level := level || '  ';
                        cout.put(level,'while ',
                          get_first_name(curnode,curname),'[t_sy] = 1 | i_'
                                    ,curname,' = 0\n');
                else    cout.put(level,'while ',
                          get_first_name(curnode,curname),'[t_sy] = 1\n');
                fi;
		cout.put(level,'do\n');
		put_action(curnode.children[0].action, level || '  ');
		rdecl(curnode.children[0],curname || '_0');
		gencode(curnode.children[0].children[0],level || '  ',
			curname || '_0_0');

                cout.put(level,'  if t_sy = ',
                        symtab[curnode.children[0].children[1].symbol],'\n');
                cout.put(level,'  then\n');
		put_action(curnode.children[0].children[1].action,
			level || '    ');
		cout.put(level,'    nextsym;\n');

		tsco := testsym_code(curnode.children[0].children[0],curname ||
					'_0_0',
				err_msg(curnode.children[0].children[0]));

		if scan tsco for
			defco := find('r_'||curname||'_0_0')
			& lit('r_'||curname||'_0_0')
			& (defco := defco || 'r_'||curname||'_0_1')
			& (defco := defco || rtab(0))
		   rof
		then tsco := defco;
		fi;

		# This is indeed a very cryptic construction. Nevertheless
		* It is needed to generate good code for the list 
		* construction. The troubles are caused by the call of
		* the procedure testsym_code. The construction that is
		* expected, is the first grand-son of the current node.
		* The remainderset that we need is however the remainderset
		* of the second grand-son (the separating terminal-symbol).
		* This expression changes the name of the remainderset used
		* in the code generated by testsym_code, into the correct
		* name. This means substituting the last '_0_0' of the re-
		* mainder-name into '_0_1'.
		#

		cout.put(level,'    ',tsco);
		cout.put(level,'  elif ',get_first_name(curnode
		   .children[0].children[0],curname||'_0_0'),'[t_sy] = 1\n');
		cout.put(level,'  then error(''Separating "',curnode
		   .children[0].children[1].symbol,'"'',lnr);\n');
                cout.put(level,'  fi;\n');
                if ind = '+' & curnode.state = EMPTY_STATE
                then    cout.put(level,'i_',curname,' := 1;\n');
                fi;
                cout.put(level,'od;\n');
                if ind = '+' & curnode.state = EMPTY_STATE
                then    level := level.substr(0,level.size-2);
                        cout.put(level,');\n');
                fi;
	esac;

	put_action(curnode.action,level);
	if get_first_name(curnode,curname) = 'f_'||curname
	then	fdecl(curnode,curname);
	fi,

  'term':
        var ind := curnode.rep;

	if ind ~= '*' & curnode.seqnr > 0
	then	cout.put(level,'if t_sy = ',symtab[curnode.symbol],'\n');
		cout.put(level,'then\n');
		level := level || '  ';
	fi;

	if ind ~= 'norep'
	then	cout.put(level,'while t_sy = ',symtab[curnode.symbol],'\n');
		cout.put(level,'do\n');
		level := level || '  ';
	fi;

	if curnode.ass_var ~= undefined
	then	cout.put(level, curnode.ass_var, ':= sy;\n')
	fi;

	put_action(curnode.action,level);
        cout.put(level,'nextsym;\n');
# -- old code :
	cout.put(level,'testsym(');

	if remsets['r_'||curname] ~= undefined
	then cout.put('UN2(dont_skip,r_',curname,'),EMPTY,'''');\n');
	else cout.put('dont_skip,EMPTY,'''');\n');
	fi;
 -- replaced by: #
	cout.put(level,'if ');
	if remsets['r_'||curname] ~= undefined
	then cout.put('dont_skip[t_sy]=0 & ',
		      'r_', curname, '[t_sy]=0 then ',
		      'testsymee(dont_skip,', 'r_', curname,
		      ',EMPTY,'''') fi;\n');
	else cout.put('dont_skip[t_sy]=0 then ',
		      'testsym(dont_skip,EMPTY,'''') fi;\n');
	fi;

	if ind ~= 'norep'
	then
		level := level.substr(0,level.size-2);
		cout.put(level,'od;\n');
	fi;

	if curnode.seqnr > 0 & ind ~= '*'
	then
		level := level.substr(0,level.size-2);
		cout.put(level,'else error(''"',curnode.symbol,'"'',lnr);\n');
		cout.put(level,'fi;\n');
	fi,

  'nont':
        var ind := curnode.rep,
	    ds := 	if remsets[ 'r_'||curname ] ~= undefined
			then	gen_UN2('dont_skip', 'r_' || curname)
			else	'dont_skip'
			fi;


	if ind ~= '*'
	then	if curnode.ass_var ~= undefined
		then cout.put(level,curnode.ass_var,
			' := p_',curnode.name,'(',ds,');\n')
		else cout.put(level,'p_',curnode.name,'(',ds,');\n')
		fi;
		put_action(curnode.action,level);
	fi;

	if ind ~= 'norep'
	then	cout.put(level,'while ',
				get_first_name(curnode,curname),'[t_sy] = 1\n');
		cout.put(level,'do ');
		if curnode.ass_var ~= undefined
		then	cout.put(curnode.ass_var,' := p_',
				curnode.name,'(',ds,');\n');
		else	cout.put('p_',curnode.name,'(',ds,');\n');
		fi;
		put_action(curnode.action,level || '  ');
		cout.put(level,'od;\n');
	fi,

  'rule_root':

	if curnode.name = startsym
	then
		# generate program declaration  #

		cout.put('program  p_',curname,'(args)\n');
		cout.put('(\n  var dont_skip := s_',symtab['EOF'],';\n');

	else	cout.put('\n\nproc  ','p_',curname,'(dont_skip)\n');
		cout.put('(\n');
	fi;

	level := '  ';
	put_action(curnode.initcode,level);

	if curnode.name = startsym
	then	cout.put(level,'nextsym;\n');
	fi;

	if curnode.firstsyms.size > 0 | curnode.name = startsym
        then    cout.put(level,
			testsym_code(curnode,curname,'<' ||curnode.name|| '>'));
	fi;

	body_code(curnode,level,curname);

	put_action(curnode.exitcode,level);
	if curnode.name = startsym
	then	cout.put(level,'if errcnt > 0\n',level,'then stop(1)\n',
			 level,'fi;\n');
	fi;
        cout.put(');\n');
	fdecl( curnode, curname );
  esac;
);

# pt_action - prints the action on the .co file #

proc put_action(action,level)
(	var line := '';

	if action ~= undefined
	then	scan action
		for	while  line := level || break('\n')
			do	cout.put(line,'\n');
				move(1)
			od
		rof
	fi;
);

# testsym_code - Generates text for a call of the procedure testsym. The 
* construction that is expected is represented by node. 
* Note the difference between nodes whose state is EMPTY_STATE, and
* nodes whose state is NONEMPTY_STATE.
#

proc testsym_code(node,path,mess)
(	var remainder_name,main_part,first_name,tst;

	first_name := get_first_name(node,path);
	remainder_name := if remsets['r_'||path] ~= undefined
	      		  then	'r_'||path;
	      		  else	undefined;
	      		  fi;

# -- old code :
	if node.state = EMPTY_STATE
	then	main_part := '(' || first_name || ',dont_skip';
		if remainder_name ~= undefined
		then main_part := 'UN3' || main_part || ',' || remainder_name;
		else main_part := 'UN2' || main_part;
		fi;
		main_part := main_part || '),EMPTY,'''');';
	else
		main_part := first_name || ',';

		if remainder_name ~= undefined
		then	main_part := main_part || 'UN2(dont_skip,' ||
				remainder_name || '),';
		else	main_part := main_part || 'dont_skip,';
		fi;

		main_part := main_part || '''' || mess || ''');';
	fi;
	return('testsym(' || main_part || '\n');
  -- replaced by: #
	scan first_name
        for	if lit('s_')
		then
			tst := 't_sy ~= ' || span('0123456789')
		else
			tst := first_name || '[t_sy]=0'
		fi
	rof;
	
	if node.state = EMPTY_STATE
	then
		tst := 'if ' || tst || ' & dont_skip[t_sy]=0';
		main_part :=	'(' ||
				first_name || ',' ||
				'dont_skip,' ||
				if remainder_name ~= undefined
				then
				   remainder_name  || ','
				else
				   ''
				fi ||
				'EMPTY, '''') fi;\n' ;
		if remainder_name ~= undefined
		then	tst := tst || ' & ' || remainder_name || '[t_sy] = 0';
			return(tst || ' then testsymeee' || main_part)
		else	return(tst || ' then testsymee' || main_part)
		fi;
	else
		tst := 'if ' || tst;

		main_part :=	'(' ||
				first_name || ',' ||
				'dont_skip,' ||
				if remainder_name ~= undefined
				then
				   remainder_name  || ','
				else
				   ''
				fi ||
				'''' || mess || ''') fi;\n' ;
		if remainder_name ~= undefined
		then	return(tst || ' then testsymdd' || main_part);
		else	return(tst || ' then testsym' || main_part);
		fi;
	fi;
);

# gen_UN2 -- generate code equivalent to UN2(a,b) #

proc gen_UN2(a, b)
(	return(a || '.disj(' || b || ')' )
);


# fdecl - declare a first_set in the .fs file
* This procedure is only called, when the firstset cannot be
* represented by the name of another set.
#

proc fdecl( node, pathname )
(
	var syms := node.firstsyms.index;

	if syms.size ~= 1
	then	var i, sep := '', str := '\tf_'||pathname||' := SET([';
		for i in syms
		do	str := str || sep ||  string(symtab[i]) ;
			sep := ',';
		od;
		fout.put(str||']),\n');
	fi;
);

# body_code - creates the surrounding code for a body-node.
* If an alternative can produce the empty sentence, then the
* code for this alternative is put in an else-branch if the
* number of alternatives is larger than one. When there is
* only one alternative, and when this alternative has state EMPTY_STATE,
* the code for that specific alternative is not surrounded by an if-statement.
#

proc body_code(node,level,name)
(
	  var i,j,emptycall;
	  cout.put(level);

	  for i in interval(0,node.child_count-1,1)
	  do
		j := node.children[i].firstsyms.index;

		if node.children[i].state=EMPTY_STATE& (type(node) = 'rule_root'|
						node.subtype ~= 'option')
		then	emptycall := [ node.children[i],i]
		else
			if j.size = 1
	                then    cout.put('if t_sy = ',symtab[j[0]],'\n');
			else	cout.put('if ',
				  get_first_name( node.children[i]
					,name||'_'||string(i)),'[t_sy] = 1\n');
			fi;

			cout.put(level,'then\n');
		        gencode(node.children[i],level ||
				'  ',name||'_'||string(i));

			if i = node.child_count-1 & emptycall = undefined
			then cout.put(level,'fi;\n');
			else cout.put(level,'el');
			fi;
		fi;
	  od;
	  if emptycall ~= undefined
	  then	if node.child_count > 1
		then	cout.put('se\n');
		fi;
		gencode(emptycall[0],level ||
				'  ',name||'_'||string(emptycall[1]));
		if node.child_count > 1
		then	cout.put(level,'fi;\n');
		fi;
	  fi;
);

# get_parent - returns the name of the parent #

proc get_parent(pathname)
(	var rb;
	scan pathname.reverse for
		break('_');
		move(1);
		rb := rtab(0);
	rof;
	return(rb.reverse);
);

# rdecl - declares the so called remainderset for all nodes of an 
* alternative. The remainderset is defined recursively. Whenever
* a set is declared,i.e. written on the file sout, the name is
* entered in the table remsets. The procedure gencode can use
* this information. 
* The number of remsets can be decreased, by not declaring remsets
* that consist of one symbol. The string that defines the remainder-
* set is than the value of the entry of the remaindername in remsets.
* The application of this method implies modifications, where ever
* the remaindersets, or their names are used.
#

proc rdecl(node,pathname)
(
  var i,str1,str2,ndcl;

  for i in interval(node.child_count-1,0,-1)
  do
        str1 := 'r_'||pathname||'_'||string(i);
	ndcl := 0;

	if i = node.child_count-1
	then
		str2 := 'r_' || get_parent(pathname);

		if remsets[str2] ~= undefined
		then ndcl := 1;
		else str2 := '';
		fi;
	else	str2 := get_first_name(node.children[i+1],pathname ||
				'_'||string(i+1));
		ndcl:=1;
		if remsets['r_'||pathname|| '_' ||string(i+1)] ~= undefined
		then	ndcl := 2;
			str2 := str2 || ',r_' ||pathname|| '_' ||string(i+1);
		fi;
	fi;

	if node.children[i].rep ~= 'norep'
	then
		if str2 ~= ''
		then str2 := str2||',';
		fi;
		ndcl := ndcl + 1;
		str2 := str2 || get_first_name(node.children[i],pathname ||
				'_'||string(i));
	fi;

	if ndcl > 0
	then	remsets[str1] := 1;
		if ndcl = 1
	        then    str1 := str1 || ' := ' || str2;
		elif ndcl = 2
	        then    str1 := str1 || ' := ' || 'UN2(' || str2 || ')';
                else    str1 := str1 || ' := ' || 'UN3(' || str2 || ')';
		fi;
		sout.put(',\n\t',str1);
	fi;

  od;
);

# get_first_name - returns the name for the firstset of node 'node' #

proc get_first_name(node,pathname)
(
  if type(node) ~= 'rule_root' & node.parent.child_count = 1
  then	return( get_first_name(node.parent,get_parent(pathname)));
  fi;

  case type(node) of

  'term' :
	  return('s_'||string(symtab[node.symbol])),

  'nont' :
	  var ss := treetab[node.name].root.firstsyms.index;

	  if ss.size ~= 1 
	  then	return('f_'||node.name);
          else  return('s_'||string(symtab[ss[0]]));
	  fi,

  'rule_root':
  'body' :
  'alt'  :
	  var ss := node.firstsyms.index;

	  if ss.size ~= 1
	  then return('f_'||pathname);
	  else return('s_'||string(symtab[ss[0]]));
	  fi;
  esac;
);

# err_msg - return an error message for a node. 
* If the node is not a nonterminal, the message is created, using
* the first-symbols of the node. Max. 5 symbols are given in such
* a message.
#

proc err_msg(node)
(
	if type(node) = 'nont'
        then    return('<' || node.name || '>')
	elif type(node) = 'term'
        then    return('"' || node.symbol || '"');
	else
		var i, j, mesg;

		j := node.firstsyms.index;
		i := 0;

		while i < 5 & i < j.size
		do
			if i = 0
			then
				mesg := '"' ;
			else
				if i = j.size - 1 | i = 4
				then
					mesg := mesg || '" or "';
				else
					mesg := mesg || '","';
				fi;

			fi;
	
			mesg := mesg || j[i];
			i := i +1;
		od;

		if j.size > 5
		then
			mesg := mesg || '" etc.';
		else
			mesg := mesg || '"';
		fi;

		return(mesg);
	fi;
);

# pgen1 and pgen2 are the main driver routines for pgen; they are both
* called from "pgentext", the start symbol for the grammar for pgen
* input.
#

proc pgen1( BASE )
(
	# open the input and output files #

	if (fsyn := file(BASE[0],'r')) fails
	then	put('PGEN: cannot open syntax-file\n');
		stop(1)
	fi;


	if (tout := file(BASE[0]||'.tb','w') &
	    sout := file(BASE[0]||'.rs','w') &
	    cout := file(BASE[0]||'.co','w') &
	    fout := file(BASE[0]||'.fs','w') ) fails
	then
		put('PGEN: cannot open intermediate files\n');
		stop(1);
	fi;
);

proc pgen2( BASE )
(	var w, i;

	# Look for undefined nonterminals		#

	for w in treetab.index 
	do	if treetab[w].root = undefined & w ~= '???'
		then	put(' Nonterminal ',w,' not declared.\n');
			errcnt:=errcnt + 1;
		fi;
	od;



	if errcnt = 0
	then
		# Find the start symbol of the grammar  #


		var startsymbols := table(5,undefined);

		for w in treetab.index 
	        do      if treetab[w].reftab.size = 0
			then
				startsym := w;
				startsymbols[w] := 1;
	                fi;
		od;

		if startsymbols.size = 0
		then  put(' No correct startsymbol found.\n');
		      errcnt := errcnt + 1;
		elif  startsymbols.size > 1
		then
		      var i;
		      put(' More than one startsymbol found.\n');
		      put(' Startsymbols: ');
		      for i in startsymbols.index
		      do
			put(' <',i,'>');
		      od;
		      put('\n');
		      errcnt := errcnt + 1;
		else
		      # The followset of the start symbol consists of
			the end-of-file symbol
		      #

		      treetab[startsym].root.follow :=
						    table(1,undefined);
		      treetab[startsym].root.follow['EOF'] := 1;
		fi;

	fi;

	if errcnt = 0
	then	if roll_up fails
		then
		     put(' First_sets of the following rules ',
				'cannot be determined\n');

		     for w in treetab.index 
		     do if treetab[w].filled_in = FALSE
                        then put(' ** ',w,' **\n');
			fi;
		     od;
		     errcnt := errcnt + 1;
		fi;
	fi;

	if errcnt = 0
	then LL1_check();
	fi;


	if errcnt = 0
	then
		# Generate table declarations	
		  Note that after this declaration, symtab contains
		  all the symbols of the grammar, with their type
		  values for the generated parser. This information
		  is used by the code-generator.
		#


		var count:=0,syms:=symtab.index;

		tout.put('\tvar\n\t \tkeytab := table(20,undefined) init [\n');
		if syms.size > 0
		then	for i in interval(1,syms.size-1,1)
			do	tout.put('\t\t''',syms[i],''' : ',count,',\n');
				symtab[syms[i]] := count;
				count:=count+1;
			od;
                	tout.put('\t\t''',syms[0],''' : ',count,'\n');
			symtab[syms[0]] := count;
			count := count + 1;
		fi;

		tout.put('\t],\n\n\n');
		syms := chartab.index;

		if syms.size > 0
		then	tout.put('\tkartab := table(20,undefined) init [\n');
			for i in interval(1,syms.size-1,1)
			do	tout.put('\t\t''',syms[i],''' : ',count,',\n');
				symtab[syms[i]] := count;
				count := count+1;
			od;
                	tout.put('\t\t''',syms[0],'''  : ',count,'\n\t],\n\n\n');
			symtab[syms[0]] := count;
			count := count + 1;
		fi;

		syms := upredef.index;
	
		tout.put('\tpredef := table(10,undefined) init [\n');

		if syms.size > 0
		then	for i in syms.index
			do	tout.put('\t\t''',syms[i],''' : ',count,',\n');
				symtab[syms[i]] := count;
				count := count + 1;
			od;
		fi;
		tout.put('\t\t''EOF'' : ',count,'\n\t],\n\n\n\n');
		symtab['EOF'] := count;
		count := count + 1;

		tout.put('\tSETSIZE := ',count,',\n');

		for i in interval(0,symtab.size-1,1)
		do	sout.put('\ts_',i,' := SET([',i,']),\n');
		od;
	fi;


	if errcnt = 0
	then 
		sout.put('\tEMPTY := SET([])');
		for w in treetab.index
		do
			gencode(treetab[w].root,'',treetab[w].root.name);
		od;

		sout.put(';\n\n');
	fi;

	if errcnt > 0
	then	stop(1);
	fi;

);

	
# end of pg.ud #
	var
	 	keytab := table(20,undefined) init [
	],


	kartab := table(20,undefined) init [
		')' : 0,
		'*' : 1,
		'+' : 2,
		',' : 3,
		'.' : 4,
		'/' : 5,
		':' : 6,
		'::=' : 7,
		'<' : 8,
		'>' : 9,
		'EXIT' : 10,
		'INIT' : 11,
		'LEXICAL' : 12,
		'[' : 13,
		']' : 14,
		'{' : 15,
		'|' : 16,
		'}' : 17,
		'('  : 18
	],


	predef := table(10,undefined) init [
		'ident' : 19,
		'keyword' : 20,
		'string' : 21,
		'summer_text' : 22,
		'EOF' : 23
	],



	SETSIZE := 24,
	f_alternative := SET([18,5,8,13,19,20,21,15]),
	f_code_spec := SET([5,10,11]),
	f_list_0_3_0 := SET([20,21]),
	f_list_0_3 := SET([8,20,21]),
	f_list_0_6 := SET([1,2]),
	f_nothing := SET([]),
	f_pgentext := SET([8,12]),
	f_primary_0_0_0_0_0 := SET([20,21]),
	f_primary_0_0_0_0_1 := SET([8,19]),
	f_primary_0_0_0_0 := SET([18,8,19,20,21]),
	f_primary_0_0_0_1_2 := SET([]),
	f_primary_0_0_0_1 := SET([1,2]),
	f_primary_0_0_0 := SET([18,8,19,20,21]),
	f_primary_0_0 := SET([18,8,13,19,20,21,15]),
	f_primary := SET([18,8,13,19,20,21,15]),
	f_rule_0_1 := SET([5,10,11]),
	f_rule_body := SET([18,5,8,13,19,20,21,15]),
	f_rule_call := SET([8,19]),
	f_terminal_symbol := SET([20,21]),
	s_0 := SET([0]),
	s_1 := SET([1]),
	s_2 := SET([2]),
	s_3 := SET([3]),
	s_4 := SET([4]),
	s_5 := SET([5]),
	s_6 := SET([6]),
	s_7 := SET([7]),
	s_8 := SET([8]),
	s_9 := SET([9]),
	s_10 := SET([10]),
	s_11 := SET([11]),
	s_12 := SET([12]),
	s_13 := SET([13]),
	s_14 := SET([14]),
	s_15 := SET([15]),
	s_16 := SET([16]),
	s_17 := SET([17]),
	s_18 := SET([18]),
	s_19 := SET([19]),
	s_20 := SET([20]),
	s_21 := SET([21]),
	s_22 := SET([22]),
	s_23 := SET([23]),
	EMPTY := SET([]),
	r_alternative_0_1 := f_primary,
	r_alternative_0_0 := UN2(f_primary,r_alternative_0_1),
	r_alternative_0_0_0_0 := r_alternative_0_0,
	r_code_spec_0_1 := UN2(s_10,s_5),
	r_code_spec_0_0 := UN2(s_5,r_code_spec_0_1),
	r_code_spec_0_0_0_2 := r_code_spec_0_0,
	r_code_spec_0_0_0_1 := UN2(s_22,r_code_spec_0_0_0_2),
	r_code_spec_0_0_0_0 := UN2(s_6,r_code_spec_0_0_0_1),
	r_code_spec_0_1_0_2 := r_code_spec_0_1,
	r_code_spec_0_1_0_1 := UN2(s_22,r_code_spec_0_1_0_2),
	r_code_spec_0_1_0_0 := UN2(s_6,r_code_spec_0_1_0_1),
	r_code_spec_0_2_0_1 := s_22,
	r_code_spec_0_2_0_0 := UN2(s_6,r_code_spec_0_2_0_1),
	r_compound_0_1 := s_0,
	r_compound_0_0 := UN2(f_rule_body,r_compound_0_1),
	r_label_0_1 := s_5,
	r_label_0_0 := UN2(s_19,r_label_0_1),
	r_lexicals_0_1 := UN2(s_4,s_19),
	r_lexicals_0_0 := UN2(s_19,r_lexicals_0_1),
	r_lexicals_0_1_0_1 := r_lexicals_0_1,
	r_lexicals_0_1_0_0 := UN2(s_3,r_lexicals_0_1_0_1),
	r_list_0_5 := f_list_0_6,
	r_list_0_4 := UN2(s_17,r_list_0_5),
	r_list_0_3 := UN2(s_5,r_list_0_4),
	r_list_0_2 := UN2(f_list_0_3,r_list_0_3),
	r_list_0_1 := UN2(f_primary,r_list_0_2),
	r_list_0_0 := UN2(s_5,r_list_0_1),
	r_list_0_1_0_0 := r_list_0_1,
	r_list_0_3_0_0 := r_list_0_3,
	r_list_0_3_1_0 := r_list_0_3,
	r_list_0_4_0_0 := r_list_0_4,
	r_name_0_1 := s_9,
	r_name_0_0 := UN2(s_19,r_name_0_1),
	r_option_0_1 := s_14,
	r_option_0_0 := UN2(f_rule_body,r_option_0_1),
	r_pgentext_0_1 := s_8,
	r_pgentext_0_0 := UN2(s_8,r_pgentext_0_1),
	r_pgentext_0_0_0_0 := r_pgentext_0_0,
	r_primary_0_0 := s_5,
	r_primary_0_0_0_1 := r_primary_0_0,
	r_primary_0_0_0_0 := UN2(f_primary_0_0_0_1,r_primary_0_0_0_1),
	r_primary_0_0_0_0_0_0 := r_primary_0_0_0_0,
	r_primary_0_0_0_0_1_0 := r_primary_0_0_0_0,
	r_primary_0_0_0_0_2_0 := r_primary_0_0_0_0,
	r_primary_0_0_0_1_0_0 := r_primary_0_0_0_1,
	r_primary_0_0_0_1_1_0 := r_primary_0_0_0_1,
	r_primary_0_0_0_1_2_0 := r_primary_0_0_0_1,
	r_primary_0_0_1_0 := r_primary_0_0,
	r_primary_0_0_2_0 := r_primary_0_0,
	r_rule_0_0 := f_rule_0_1,
	r_rule_body_0_0 := f_rule_body,
	r_rule_body_0_0_0_1 := r_rule_body_0_0,
	r_rule_body_0_0_0_0 := UN2(s_16,r_rule_body_0_0_0_1),
	r_rule_call_0_0 := s_8,
	r_rule_call_0_0_0_1 := r_rule_call_0_0,
	r_rule_call_0_0_0_0 := UN2(s_6,r_rule_call_0_0_0_1),
	r_rule_def_0_2 := s_4,
	r_rule_def_0_1 := UN2(f_rule_body,r_rule_def_0_2),
	r_rule_def_0_0 := UN2(s_7,r_rule_def_0_1);

	#  LEXICAL PROCEDURES			#

var	kars := kartab.index,		# array with symbols from PKF #
	karsize := kartab.size,		# number of symbols #
	in_code_spec := FALSE;		# flag to force reading of summer_text #
					# in a <code-spec> #

proc ermsg(mess, ln)
(
        put(string(ln).right(5,' '),': ',mess,'\n');
        errcnt := errcnt + 1;
);

# get_string reads a character-constant from the input.	#
# The quote character can be denoted by doubling it.	#
# Note that escape sequences are not converted . This	#
# means that things like '\' are not detected.		#

proc get_string ()
(
	const quote := '''';
	var symbol := '';

	scan line
	for	var s := cursor;
		while break(quote) & lit(quote||quote)
		do	od;

		if ~lit(quote)
		then	ermsg('Newline not allowed in string.\n',lnr)
		else	move(-1);
		fi;

		s := cursor - s;
		symbol := move(-s);
		move(s);

		if lit(quote)
		then	if symbol = ''
			then	ermsg('Character constant missing.\n',lnr)
			fi
		fi
	rof;
	return(symbol);
);

# comment() skips comment in the metalanguage.			#
# An error message is printed when the comment isn't terminated.#

proc comment()
(
	while line.break('#') fails do
		if line := scan_string(fsyn.get()) fails
		then ermsg('Comment not terminated.',lnr);
		     line := scan_string(' ');
		     return
		else lnr:=lnr+1;
		fi;
	od;

	if line.move(1) fails
	then if line:= scan_string(fsyn.get())
	     then lnr:=lnr+1;
	     fi;
	fi;
);

# nextsym() is the scanner for the parsergenerator. It reads	#
#  the next symbol from the input , puts it in the variable sy	#
#  and puts the type in t_sy.					#
#  The procedure tries to recognise the symbols in the		#
#  following order :						#
#	1.	identifiers (lower-case letters + hyphens)	#
#	2.	keywords (upper-case letters)			#
#       3.	a string constant in the grammar (a quote)	#
#       4.      a character constant ( e.g. ::= )		#
#  When neither of these possibilities succeeds, comment is	#
#  checked or an error message is printed. Of course, a new	#
#  line is read, when necessary.				#

proc nextsym()
(
	if in_code_spec = TRUE
	then
	   get_summer_text();
	   return;
	fi;
	while TRUE do
		line.span(' \t')|OKE;
		if sy := line.any(lower) succeeds
                then    sy := sy ||
			  line.span(lower||digit||'-'||'_').replace('-','_') |
			  OKE;
			t_sy := predef['ident'];
			return;
		elif sy := line.any(upper) succeeds
		then	sy := sy || line.span(upper) | OKE;
			if kartab[sy] ~= undefined
			then	t_sy := kartab[sy]
			else	t_sy := predef['keyword'];
			fi;
			return
		elif line.lit('''')
		then	t_sy := predef['string'];
			sy := get_string;
			return;
		elif line.rpos(0) succeeds
                then    (line := scan_string(fsyn.get()) & lnr:=lnr+1) |
			(t_sy:=predef['EOF'] & sy := 'EOF' & return);
		else	var i;
			for i in interval(karsize-1,0,-1)
			do	sy := kars[i];
				if line.lit(sy) succeeds
				then	t_sy := kartab[sy];
					return;
				fi;
			od;
			sy := line.move(1);
			if sy = '#'
			then	comment();
			else	ermsg('Character "' || sy ||
					'" not in legal context.',lnr);
			fi;
		fi;
	od;
);

# get_summer_text reads a set of SUMMER statements from the input.	#
# This procedure is called when labels are specified by		#
# actions. Note that in this situation layout is important.	#
# The keyword EXIT or a new label or the beginning of a		#
# new rule must be denoted at the beginng of a line. Other-	#
# wise they are assumed to belong to the collection of 		#
# statements. They may be preceded by spaces and tabs.		#

proc get_summer_text()
(
	assert in_code_spec = TRUE;
	in_code_spec := FALSE;
	sy := '# line: ' || string(lnr) || '#\n' ;

	while TRUE 
	do	line.span(' \t')|OKE;

		if ( (line.lit('/')&line.move(-1))        # new label ? #
		   | (line.lit('EXIT')&line.move(-4))     # EXIT-clause ? #
		   | (line.lit('<')&line.move(-1)) )      # new rule ? #

		then	return
		else
			if line.rpos(0) fails
			then
				sy := sy || line.rtab(0) || '\n' ;
			fi;

			t_sy := predef['summer_text'];
			if line := scan_string(fsyn.get())
			then	lnr := lnr + 1
			else	line := scan_string(' ');
				return
			fi
		fi
	od
);


proc  p_alternative(dont_skip)
(
  var l ;
  # line: 131#
  var curnode := alt(parent_node, UNDECIDED_STATE),
  my_parent := parent_node;
  parent_node := curnode;
  if f_alternative[t_sy]=0 then testsym(f_alternative,dont_skip,'<alternative>') fi;
  if f_alternative[t_sy] = 1
  then
    if t_sy = 5
    then
      l := p_label(dont_skip.disj(r_alternative_0_0_0_0));
      # line: 135#
      place_label(curnode, l);
    fi;
    p_primary(dont_skip.disj(r_alternative_0_1));
    while f_primary[t_sy] = 1
    do p_primary(dont_skip.disj(r_alternative_0_1));
    od;
  fi;
  # line: 137#
  # Check whether the information for this alternative
  can be assembled. #
  scan curnode
  for	if first_UND = 0
  then	get_first(subject);
  if state = UNDECIDED_STATE
  then	state := EMPTY_STATE
  fi
  fi
  rof;
  backpatch(curnode);
  parent_node := my_parent;
);


proc  p_code_spec(dont_skip)
(
  var label ;
  # line: 23#
  var deflabels := table(10, undefined);
  if f_code_spec[t_sy]=0 & dont_skip[t_sy]=0 then testsymee(f_code_spec,dont_skip,EMPTY, '') fi;
      if t_sy = 11
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_code_spec_0_0_0_0[t_sy]=0 then testsymee(dont_skip,r_code_spec_0_0_0_0,EMPTY,'') fi;
      if t_sy = 6
      then
        # line: 25#
        in_code_spec := TRUE;
        nextsym;
        if dont_skip[t_sy]=0 & r_code_spec_0_0_0_1[t_sy]=0 then testsymee(dont_skip,r_code_spec_0_0_0_1,EMPTY,'') fi;
      else error('":"',lnr);
      fi;
      if t_sy = 22
      then
        # line: 28#
        # Add the statements to the initcode field of	#
        # the rootnode of the current production.	#
        treetab[rule_name].root.initcode :=
        treetab[rule_name].root.initcode || sy;
        nextsym;
        if dont_skip[t_sy]=0 & r_code_spec_0_0_0_2[t_sy]=0 then testsymee(dont_skip,r_code_spec_0_0_0_2,EMPTY,'') fi;
      else error('"summer_text"',lnr);
      fi;
    fi;
    while s_5[t_sy] = 1
    do
      if t_sy = 5
      then
        label := p_label(dont_skip.disj(r_code_spec_0_1_0_0));
        if t_sy = 6
        then
          # line: 25#
          in_code_spec := TRUE;
          nextsym;
          if dont_skip[t_sy]=0 & r_code_spec_0_1_0_1[t_sy]=0 then testsymee(dont_skip,r_code_spec_0_1_0_1,EMPTY,'') fi;
        else error('":"',lnr);
        fi;
        if t_sy = 22
        then
          # line: 34#
          deflabels[label] := 1;
          # Store the collection of statements in the	#
          # 'action'-field of every node to which		#
          # the label was related. If a label is specified#
          # twice, then the last specification is saved.	#
          if labeltab[label] ~= undefined
          then var i;
          for i in interval(0,labeltab[label].size -1,1)
          do
          if labeltab[label][i] ~= undefined
          then
          labeltab[label][i].action := sy;
          fi
          od;
          else
          ermsg('Label /' || label ||
          '/ does not occur in <rule-def>.\n', lnr)
          fi;
          nextsym;
          if dont_skip[t_sy]=0 & r_code_spec_0_1_0_2[t_sy]=0 then testsymee(dont_skip,r_code_spec_0_1_0_2,EMPTY,'') fi;
        else error('"summer_text"',lnr);
        fi;
      fi;
    od;
    if t_sy = 10
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_code_spec_0_2_0_0[t_sy]=0 then testsymee(dont_skip,r_code_spec_0_2_0_0,EMPTY,'') fi;
      if t_sy = 6
      then
        # line: 25#
        in_code_spec := TRUE;
        nextsym;
        if dont_skip[t_sy]=0 & r_code_spec_0_2_0_1[t_sy]=0 then testsymee(dont_skip,r_code_spec_0_2_0_1,EMPTY,'') fi;
      else error('":"',lnr);
      fi;
      if t_sy = 22
      then
        # line: 55#
        # store the statements in the exitcode field	#
        # of the root node.				#
        treetab[rule_name].root.exitcode := sy;
        nextsym;
        if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
      else error('"summer_text"',lnr);
      fi;
    fi;
  # line: 60#
  for label in labeltab.index
  do if deflabels[label] = undefined
  then
  ermsg('No statements for label /' || label || '/.\n', lnr)
  fi
  od;
);


proc  p_compound(dont_skip)
(
  # line: 261#
  var curnode := body(parent_node, UNDECIDED_STATE),
  my_parent := parent_node;
  parent_node := curnode;
  if t_sy ~= 18 then testsym(s_18,dont_skip,'<compound>') fi;
  if t_sy = 18
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_compound_0_0[t_sy]=0 then testsymee(dont_skip,r_compound_0_0,EMPTY,'') fi;
    p_rule_body(dont_skip.disj(r_compound_0_1));
    if t_sy = 0
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('")"',lnr);
    fi;
  fi;
  # line: 265#
  curnode.subtype := 'compound';
  parent_node := my_parent;
  return(curnode);
);


proc  p_label(dont_skip)
(
  # line: 333#
  var l;
  if t_sy ~= 5 then testsym(s_5,dont_skip,'<label>') fi;
  if t_sy = 5
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_label_0_0[t_sy]=0 then testsymee(dont_skip,r_label_0_0,EMPTY,'') fi;
    if t_sy = 19
    then
      # line: 335#
      l := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_label_0_1[t_sy]=0 then testsymee(dont_skip,r_label_0_1,EMPTY,'') fi;
    else error('"ident"',lnr);
    fi;
    if t_sy = 5
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"/"',lnr);
    fi;
  fi;
  # line: 337#
  return(l);
);


proc  p_lexicals(dont_skip)
(
  if t_sy ~= 12 then testsym(s_12,dont_skip,'<lexicals>') fi;
  if t_sy = 12
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_lexicals_0_0[t_sy]=0 then testsymee(dont_skip,r_lexicals_0_0,EMPTY,'') fi;
    if t_sy ~= 19 then testsymdd(s_19,dont_skip,r_lexicals_0_1,'"ident"') fi;
    while s_19[t_sy] = 1
    do
      # line: 10#
      upredef[sy] := 1;
      nextsym;
      if dont_skip[t_sy]=0 & r_lexicals_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_lexicals_0_1_0_0,EMPTY,'') fi;
      if t_sy = 3
      then
        nextsym;
        if t_sy ~= 19 then testsymdd(s_19,dont_skip,r_lexicals_0_1_0_1,'"ident"') fi;
      elif s_19[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 4
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"."',lnr);
    fi;
  fi;
);


proc  p_list(dont_skip)
(
  var lab,name,tsnode ;
  # line: 207#
  var curnode, altnode, my_parent;
  curnode := body(parent_node, UNDECIDED_STATE);
  altnode := alt(curnode, UNDECIDED_STATE);
  my_parent := parent_node;
  parent_node := altnode;
  if t_sy ~= 15 then testsym(s_15,dont_skip,'<list>') fi;
  if t_sy = 15
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_list_0_0[t_sy]=0 then testsymee(dont_skip,r_list_0_0,EMPTY,'') fi;
    if t_sy = 5
    then
      lab := p_label(dont_skip.disj(r_list_0_1_0_0));
      # line: 212#
      place_label(altnode, lab);
    fi;
    p_primary(dont_skip.disj(r_list_0_2));
    if f_list_0_3[t_sy]=0 then testsymdd(f_list_0_3,dont_skip,r_list_0_3,'"<","keyword" or "string"') fi;
    if f_list_0_3_0[t_sy] = 1
    then
      tsnode := p_terminal_symbol(dont_skip.disj(r_list_0_3_0_0));
    elif t_sy = 8
    then
      name := p_name(dont_skip.disj(r_list_0_3_1_0));
      # line: 214#
      # Check that "name" is a lexical-id #
      if upredef[name] = undefined
      then ermsg('No rule name allowed as separator.', lnr)
      else tsnode := term(altnode, name);
      tsnode.subtype := 'lex-id';
      fi;
    fi;
    # line: 221#
    if tsnode ~= undefined
    then tsnode.state := EMPTY_STATE;
    tsnode.rep := 'norep';
    fi;
    if t_sy = 5
    then
      lab := p_label(dont_skip.disj(r_list_0_4_0_0));
      # line: 226#
      place_label(tsnode, lab);
    fi;
    if t_sy = 17
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_list_0_5[t_sy]=0 then testsymee(dont_skip,r_list_0_5,EMPTY,'') fi;
    else error('"}"',lnr);
    fi;
    if f_list_0_6[t_sy]=0 then testsym(f_list_0_6,dont_skip,'"*" or "+"') fi;
    if t_sy = 2
    then
      # line: 228#
      curnode.subtype := 'list';
      curnode.rep := '+';
      if altnode.children[0] ~= undefined
      then	altnode.state := altnode.children[0].state;
      fi;
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    elif t_sy = 1
    then
      # line: 234#
      curnode.state := EMPTY_STATE;
      curnode.subtype := 'list';
      curnode.rep := '*';
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    fi;
    # line: 238#
    # check whether the info of the alternative can be assembled. #
    if altnode.first_UND = 0
    then	get_first(altnode);
    fi;
    backpatch(altnode);
    # Check whether the info of the body-node can be assembled. #
    if curnode.first_UND = 0
    then	get_first(curnode);
    if curnode.state = UNDECIDED_STATE
    then	curnode.state := NONEMPTY_STATE;
    fi;
    fi;
  fi;
  # line: 256#
  parent_node := my_parent;
  return(curnode);
);


proc  p_name(dont_skip)
(
  # line: 293#
  var nm := '???';
  if t_sy ~= 8 then testsym(s_8,dont_skip,'<name>') fi;
  if t_sy = 8
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_name_0_0[t_sy]=0 then testsymee(dont_skip,r_name_0_0,EMPTY,'') fi;
    if t_sy = 19
    then
      # line: 295#
      nm := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_name_0_1[t_sy]=0 then testsymee(dont_skip,r_name_0_1,EMPTY,'') fi;
    else error('"ident"',lnr);
    fi;
    if t_sy = 9
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('">"',lnr);
    fi;
  fi;
  # line: 297#
  return(nm);
);


proc  p_nothing(dont_skip)
(
  );


proc  p_option(dont_skip)
(
  # line: 192#
  var curnode := body(parent_node, EMPTY_STATE),
  my_parent := parent_node;
  parent_node := curnode;
  if t_sy ~= 13 then testsym(s_13,dont_skip,'<option>') fi;
  if t_sy = 13
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_option_0_0[t_sy]=0 then testsymee(dont_skip,r_option_0_0,EMPTY,'') fi;
    p_rule_body(dont_skip.disj(r_option_0_1));
    if t_sy = 14
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"]"',lnr);
    fi;
  fi;
  # line: 196#
  curnode.subtype := 'option';
  curnode.rep := 'norep';
  parent_node := my_parent;
  return(curnode);
);
program  p_pgentext(args)
(
  var dont_skip := s_23;
  # line: 5#
  pgen1(args);
  nextsym;
  if f_pgentext[t_sy]=0 & dont_skip[t_sy]=0 then testsymee(f_pgentext,dont_skip,EMPTY, '') fi;
      if t_sy = 12
    then
      p_lexicals(dont_skip.disj(r_pgentext_0_0_0_0));
    fi;
    while s_8[t_sy] = 1
    do p_rule(dont_skip.disj(r_pgentext_0_1));
    od;
  # line: 6#
  pgen2(args);
  if errcnt > 0
  then stop(1)
  fi;
);


proc  p_primary(dont_skip)
(
  var curnode,lab ;
  # line: 168#
  var my_parent := parent_node;
  if f_primary[t_sy]=0 then testsym(f_primary,dont_skip,'<primary>') fi;
  if f_primary[t_sy] = 1
  then
    if f_primary_0_0_0[t_sy] = 1
    then
      if f_primary_0_0_0_0_0[t_sy] = 1
      then
        curnode := p_terminal_symbol(dont_skip.disj(r_primary_0_0_0_0_0_0));
      elif f_primary_0_0_0_0_1[t_sy] = 1
      then
        curnode := p_rule_call(dont_skip.disj(r_primary_0_0_0_0_1_0));
      elif t_sy = 18
      then
        curnode := p_compound(dont_skip.disj(r_primary_0_0_0_0_2_0));
      fi;
      if t_sy = 2
      then
        # line: 170#
        if curnode ~= undefined
        then	curnode.rep := '+';
        fi;
        nextsym;
        if dont_skip[t_sy]=0 & r_primary_0_0_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_primary_0_0_0_1_0_0,EMPTY,'') fi;
      elif t_sy = 1
      then
        # line: 174#
        if curnode ~= undefined
        then	curnode.rep := '*';
        curnode.state := EMPTY_STATE;
        fi;
        nextsym;
        if dont_skip[t_sy]=0 & r_primary_0_0_0_1_1_0[t_sy]=0 then testsymee(dont_skip,r_primary_0_0_0_1_1_0,EMPTY,'') fi;
      else
        p_nothing(dont_skip.disj(r_primary_0_0_0_1_2_0));
        # line: 179#
        if curnode ~= undefined
        then	curnode.rep := 'norep';
        fi;
      fi;
    elif t_sy = 15
    then
      curnode := p_list(dont_skip.disj(r_primary_0_0_1_0));
    elif t_sy = 13
    then
      curnode := p_option(dont_skip.disj(r_primary_0_0_2_0));
    fi;
    if t_sy = 5
    then
      lab := p_label(dont_skip);
      # line: 183#
      place_label(curnode, lab);
    fi;
  fi;
  # line: 185#
  if curnode ~= undefined
  then	backpatch(curnode);
  fi;
  parent_node := my_parent;
);


proc  p_rule(dont_skip)
(
  var rn ;
  # line: 14#
  labeltab := table(10, undefined);
  if t_sy ~= 8 then testsym(s_8,dont_skip,'<rule>') fi;
  if t_sy = 8
  then
    rn := p_rule_def(dont_skip.disj(r_rule_0_0));
    # line: 16#
    rule_name := rn;
    if f_rule_0_1[t_sy] = 1
    then
      p_code_spec(dont_skip);
    fi;
  fi;
);


proc  p_rule_body(dont_skip)
(
  # line: 111#
  var my_parent := parent_node;
  if f_rule_body[t_sy]=0 & dont_skip[t_sy]=0 then testsymee(f_rule_body,dont_skip,EMPTY, '') fi;
      while f_rule_body[t_sy] = 1
    do
      p_alternative(dont_skip.disj(r_rule_body_0_0_0_0));
      if t_sy = 16
      then
        nextsym;
        if f_alternative[t_sy]=0 then testsymdd(f_alternative,dont_skip,r_rule_body_0_0_0_1,'<alternative>') fi;
      elif f_alternative[t_sy] = 1
      then error('Separating "|"',lnr);
      fi;
    od;
  # line: 112#
  # Check whether the parent-node, which is a body-node
  or the root-node, can be determined.
  #
  scan my_parent
  for	if first_UND = 0
  then	if child_count > 0
  then	get_first(subject);
  if state = UNDECIDED_STATE
  then	state := NONEMPTY_STATE;
  fi;
  else	state := EMPTY_STATE;
  fi;
  fi;
  rof;
  parent_node := my_parent;
);


proc  p_rule_call(dont_skip)
(
  var name ;
  # line: 301#
  var varname, curnode;
  if f_rule_call[t_sy]=0 then testsym(f_rule_call,dont_skip,'<rule_call>') fi;
  if f_rule_call[t_sy] = 1
  then
    if t_sy = 19
    then
      # line: 303#
      varname := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_rule_call_0_0_0_0[t_sy]=0 then testsymee(dont_skip,r_rule_call_0_0_0_0,EMPTY,'') fi;
      if t_sy = 6
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_rule_call_0_0_0_1[t_sy]=0 then testsymee(dont_skip,r_rule_call_0_0_0_1,EMPTY,'') fi;
      else error('":"',lnr);
      fi;
    fi;
    name := p_name(dont_skip);
  fi;
  # line: 305#
  if name ~= undefined
  then	if upredef[name] ~= undefined
  then	curnode := term(parent_node,name);
  curnode.subtype := 'lex-id';
  if varname ~= undefined
  then	var_decl[varname] := 1;
  curnode.ass_var := varname;
  fi;
  else	curnode := nont(parent_node,name);
  if treetab[name] = undefined
  then	treetab[name] := tt_entry;
  fi;
  treetab[name].reftab[curnode] := 1;
  if varname ~= undefined
  then	var_decl[varname] := 1;
  curnode.ass_var := varname;
  fi;
  fi;
  else	curnode := nont(parent_node,'???');
  fi;
  return(curnode);
);


proc  p_rule_def(dont_skip)
(
  var name ;
  if t_sy ~= 8 then testsym(s_8,dont_skip,'<rule_def>') fi;
  if t_sy = 8
  then
    name := p_name(dont_skip.disj(r_rule_def_0_0));
    if t_sy = 7
    then
      # line: 69#
      if upredef[name] ~= undefined
      then ermsg('Lexical_id redefined : '||name||'.',lnr);
      fi;
      if treetab[name] = undefined
      then treetab[name] := tt_entry;
      fi;
      if treetab[name].root ~= undefined
      then ermsg('Nonterminal redefined : '||name||'.',lnr);
      else treetab[name].root := rule_root(name);
      fi;
      parent_node := treetab[name].root;
      nextsym;
      if dont_skip[t_sy]=0 & r_rule_def_0_1[t_sy]=0 then testsymee(dont_skip,r_rule_def_0_1,EMPTY,'') fi;
    else error('"::="',lnr);
    fi;
    p_rule_body(dont_skip.disj(r_rule_def_0_2));
    if t_sy = 4
    then
      # line: 85#
      # The tags that occurred within the rule
      are now converted to a declaration-string, which
      is stored in the init-code field of the root
      node.
      #
      if var_decl.size > 0
      then	var i,j := 0;
      scan treetab[name].root
      for	initcode := 'var ';
      for i in var_decl.index
      do	if j= 0
      then j:= 1;
      initcode := initcode || i;
      else initcode := initcode || ',' || i
      fi;
      od;
      initcode := initcode || ' ;\n';
      rof;
      var_decl := table(5,undefined);
      fi;
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"."',lnr);
    fi;
  fi;
  # line: 108#
  return(name);
);


proc  p_terminal_symbol(dont_skip)
(
  # line: 278#
  var symbol, curnode, tp;
  if f_terminal_symbol[t_sy]=0 then testsym(f_terminal_symbol,dont_skip,'<terminal_symbol>') fi;
  if t_sy = 20
  then
    # line: 280#
    symbol := sy.replace(upper,lower);
    symtab[symbol] := 1;
    tp := 'keyword';
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  elif t_sy = 21
  then
    # line: 283#
    symbol := sy;
    chartab[sy] := 1;
    tp := 'string';
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  fi;
  # line: 287#
  curnode := term(parent_node, symbol);
  curnode.subtype := tp;
  return(curnode);
);
