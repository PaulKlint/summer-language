LEXICAL keyword, string, ident, summer-text.

<pgentext> ::= [ <lexicals> ] <rule>* .

	INIT:	pgen1(args);
	EXIT:	pgen2(args);

<lexicals> ::= 'LEXICAL' { <ident> /ins/ ',' }+ '.' .

	/ins/:	upredef[sy] := 1;

<rule> ::= rn: <rule-def> /asg/ [ <code-spec> ] .

	INIT:	labeltab := table(10, undefined);

	/asg/:	rule_name := rn;

<code-spec> ::=
  	[ 'INIT' ':' /setflag/ <summer-text> /insinit/ ]
  	( label: <label> ':' /setflag/ <summer-text> /inseach/ )*
  	[ 'EXIT' ':' /setflag/ <summer-text> /insexit/ ] .

	INIT:	var deflabels := table(10, undefined);

	/setflag/:
		in_code_spec := TRUE;

	/insinit/:
		# Add the statements to the initcode field of	#
		# the rootnode of the current production.	#

		treetab[rule_name].root.initcode :=
			treetab[rule_name].root.initcode || sy;
	/inseach/:
		deflabels[label] := 1;

		# Store the collection of statements in the	#
		# 'action'-field of every node to which		#
		# the label was related. If a label is specified#
		# twice, then the last specification is saved.	#

		if labeltab[label] ~= undefined
		then var i;
			for i in interval(0,labeltab[label].size -1,1)
			do
			   if labeltab[label][i] ~= undefined
			   then
			      labeltab[label][i].action := sy;
			   fi
			od;
		else
			ermsg('Label /' || label ||
			      '/ does not occur in <rule-def>.\n', lnr)
		fi;
	/insexit/:
		# store the statements in the exitcode field	#
		# of the root node.				#
		treetab[rule_name].root.exitcode := sy;

	EXIT:	for label in labeltab.index
		do if deflabels[label] = undefined
		   then
		      ermsg('No statements for label /' || label || '/.\n', lnr)
		   fi
		od;

<rule-def> ::= name: <name> '::=' /check1/ <rule-body> '.' /cleanup/ .

	/check1/:
		if upredef[name] ~= undefined
		then ermsg('Lexical_id redefined : '||name||'.',lnr);
		fi;

		if treetab[name] = undefined
		then treetab[name] := tt_entry;
		fi;

		if treetab[name].root ~= undefined
		then ermsg('Nonterminal redefined : '||name||'.',lnr);
		else treetab[name].root := rule_root(name);
		fi;

		parent_node := treetab[name].root;

	/cleanup/:
	
		# The tags that occurred within the rule
		  are now converted to a declaration-string, which
		  is stored in the init-code field of the root
		  node.
		#

		if var_decl.size > 0
		then	var i,j := 0;
			scan treetab[name].root
			for	initcode := 'var ';
				for i in var_decl.index
				do	if j= 0
					then j:= 1;
					     initcode := initcode || i;
					else initcode := initcode || ',' || i
					fi;
				od;
				initcode := initcode || ' ;\n';
			rof;
			var_decl := table(5,undefined);
		fi;
	EXIT:	return(name);

<rule-body> ::= { <alternative> '|' }* .
	INIT:	var my_parent := parent_node;
	EXIT:
	# Check whether the parent-node, which is a body-node
	  or the root-node, can be determined.
	#
	scan my_parent
	for	if first_UND = 0
		then	if child_count > 0
			then	get_first(subject);
				if state = UNDECIDED_STATE
				then	state := NONEMPTY_STATE;
				fi;
			else	state := EMPTY_STATE;
			fi;
		fi;
	rof;
	parent_node := my_parent;

<alternative> ::= [ l: <label> /place/ ] <primary>+ .

	INIT:	var curnode := alt(parent_node, UNDECIDED_STATE),
		    my_parent := parent_node;
		parent_node := curnode;

	/place/:place_label(curnode, l);

	EXIT: # Check whether the information for this alternative
		can be assembled. #

		scan curnode
		for	if first_UND = 0
			then	get_first(subject);
				if state = UNDECIDED_STATE
				then	state := EMPTY_STATE
				fi
			fi
		rof;

		backpatch(curnode);
		parent_node := my_parent;

<primary> ::=
	( ( curnode : <terminal-symbol>
	  | curnode : <rule-call>
	  | curnode : <compound>
	  ) ( '+' /doplus/ | '*' /dostar/ | <nothing> /norep/ )
	| curnode : <list>
        | curnode : <option>
        ) [ lab : <label> /inslab/ ] .

	# The repetition indicators are represented in the "type" field	#
	# of the primaries. The third character of this field is used 	#
	# as follows:							#
	#	'1' - no repetition					#
	#	'2' - one or more repetitions (+)			#
	#	'3' - zero or more repetitions (*)			#

	INIT: var my_parent := parent_node;

	/doplus/:
		if curnode ~= undefined
		then	curnode.rep := '+';
		fi;
	/dostar/:
		if curnode ~= undefined
		then	curnode.rep := '*';
			curnode.state := EMPTY_STATE;
		fi;
	/norep/:
		if curnode ~= undefined
		then	curnode.rep := 'norep';
		fi;
	/inslab/:
		place_label(curnode, lab);
	EXIT:	if curnode ~= undefined
		then	backpatch(curnode);
		fi;
		parent_node := my_parent;

<option> ::= '[' <rule-body> ']' .

	INIT:	var curnode := body(parent_node, EMPTY_STATE),
		    my_parent := parent_node;
		parent_node := curnode;

	EXIT:	curnode.subtype := 'option';
		curnode.rep := 'norep';
		parent_node := my_parent;
		return(curnode);
<list> ::=
  	'{'  [ lab: <label> /place1/ ] <primary> 
       		( tsnode : <terminal-symbol>
                | name : <name> /checknm/
                )  /adjustts/ [ lab: <label> /place2/ ]
  	'}'  ( '+' /doplus/ | '*' /dostar/ )  /cleanup/ .

	INIT:	var curnode, altnode, my_parent;
		curnode := body(parent_node, UNDECIDED_STATE);
		altnode := alt(curnode, UNDECIDED_STATE);
		my_parent := parent_node;
		parent_node := altnode;
	/place1/:
		place_label(altnode, lab);
	/checknm/:
		# Check that "name" is a lexical-id #
		if upredef[name] = undefined
		then ermsg('No rule name allowed as separator.', lnr)
		else tsnode := term(altnode, name);
		     tsnode.subtype := 'lex-id';
		fi;
	/adjustts/:
		if tsnode ~= undefined
		then tsnode.state := EMPTY_STATE;
		     tsnode.rep := 'norep';
		fi;
	/place2/:
		place_label(tsnode, lab);
	/doplus/:
		curnode.subtype := 'list';
		curnode.rep := '+';
		if altnode.children[0] ~= undefined
		then	altnode.state := altnode.children[0].state;
		fi;
	/dostar/:
		curnode.state := EMPTY_STATE;
		curnode.subtype := 'list';
		curnode.rep := '*';
	/cleanup/:
		# check whether the info of the alternative can be assembled. #

		if altnode.first_UND = 0
		then	get_first(altnode);
		fi;

		backpatch(altnode);

		# Check whether the info of the body-node can be assembled. #

		if curnode.first_UND = 0
		then	get_first(curnode);
			if curnode.state = UNDECIDED_STATE
			then	curnode.state := NONEMPTY_STATE;
			fi;
		fi;

	EXIT:	parent_node := my_parent;
		return(curnode);

<compound> ::= '(' <rule-body> ')' .

	INIT:	var curnode := body(parent_node, UNDECIDED_STATE),
		    my_parent := parent_node;
		parent_node := curnode;

	EXIT:	curnode.subtype := 'compound';
		parent_node := my_parent;
		return(curnode);

<terminal-symbol> ::= <keyword> /iskw/ | <string> /isstr/ .

	# The three possible terminal symbols are keywords, strings and	#
	# lexical identifiers. (The latter are handled by <rule-call>)	#
	# They are distinguished by different type fields as follows:	#
	#	'keyword' - keyword					#
	#	'string'  - string					#
	#	'lex-id'  - lexical identifier				#

	INIT:	var symbol, curnode, tp;

	/iskw/:	symbol := sy.replace(upper,lower);
		symtab[symbol] := 1;
		tp := 'keyword';
	/isstr/:
		symbol := sy;
		chartab[sy] := 1;
		tp := 'string';
	EXIT:	curnode := term(parent_node, symbol);
		curnode.subtype := tp;
		return(curnode);

<name> ::= '<' <ident> /asg/ '>' .

	INIT:	var nm := '???';

	/asg/:	nm := sy;

	EXIT:	return(nm);

<rule-call> ::= [ <ident> /asg/ ':' ]  name:<name> .

	INIT:	var varname, curnode;

	/asg/:	varname := sy;

	EXIT:	if name ~= undefined
		then	if upredef[name] ~= undefined
			then	curnode := term(parent_node,name);
				curnode.subtype := 'lex-id';
				if varname ~= undefined
				then	var_decl[varname] := 1;
					curnode.ass_var := varname;
				fi;
	
			else	curnode := nont(parent_node,name);
	
				if treetab[name] = undefined
				then	treetab[name] := tt_entry;
				fi;
				treetab[name].reftab[curnode] := 1;
	
				if varname ~= undefined
				then	var_decl[varname] := 1;
					curnode.ass_var := varname;
				fi;
			fi;
		else	curnode := nont(parent_node,'???');
		fi;
	
		return(curnode);

<label> ::= '/' <ident> /asg/  '/' .

	INIT:	var l;

	/asg/:	l := sy;

	EXIT:	return(l);

<nothing> ::= .
