#********* Class declarations for parse tree nodes *********************#

class ASSIGN(left, right)
begin fetch left, right, code;
      proc code(lab, rval)
      ( right.code(empty, Value);
	if left.code(empty, Assign) ~= Assign then
	   ermsg('illegal left hand side of assignment', lnr)
	fi;
	return(Value);
      );
end ASSIGN;

class SUP_CALL(super, args)
begin fetch super, args, code;
      proc code(lab, rval)
      ( var a;
        assert super.kind = Class;
        assert args.size = super.nformals;
        for a in args do a.code(empty, Value) od;
        exp_op2('call', super.seq, args.size);
        voidcall(rval);
        return(abs(rval))
      );
end SUP_CALL;

class CALL(left, args)
begin fetch left, args, code;
      proc treat(args)
      ( var a;
	for a in args do a.code(empty, Value) od
      );
      proc code(lab, rval)
      ( var nactuals := args.size;
        case left.kind of
	GlobalProc:
	BuiltinProc:
	   treat(args);
	   # note: left.nformals < 0 => variable number of arguments #
	   if nactuals ~= left.nformals & left.nformals >= 0 then
	      ermsg(left.name || ' called with wrong number of arguments', lnr);
	      return(abs(rval))
	   fi;
	   exp_op2('call', left.seq, nactuals),
	Class:
	BuiltinClass:
	   exp_op0('undef');
	   treat(args);
	   if nactuals + 1 ~= left.nformals & left.nformals >= 0 then
	      ermsg(left.name || ' called with wrong number of arguments', lnr);
	      return(abs(rval))
	   fi;
	   exp_op2('call', left.seq, nactuals + 1),
	ClassProc:
	   exp_op0('self');
	   treat(args);
	   if fieldtab[left.name].is_unique_field &
	      fieldtab[left.name].last.classname = curclassname
	   then
	      exp_op2('call', left.seq, nactuals + 1)
	   else
	      exp_op2('ifld', fieldtab[left.name].seq, nactuals + 1)
	   fi,
	Field:
	Forward:
	   assert fieldtab[left.name] ~= undefined;
	   if fieldtab[left.name].locate_fld(curclassname) then
	      exp_op0('self');
	      treat(args);
	      exp_op2('ifld', fieldtab[left.name].seq, nactuals + 1)
	   elif symtab[left.name] ~= undefined then
		return(CALL(symtab[left.name][S_VALUE], args).code(lab, rval))
	   else
	      return(FIELDSEL(SUBJECT, left.name, args).code(lab, rval))
	   fi
	esac;
	voidcall(rval);
	return(abs(rval))
      );
end CALL;

class OPCALL(optab, args)
begin fetch optab, args, code;
      proc code(lab, rval)
      ( var nactuals := args.size, a, oper := optab[O_NAME];

	for a in args do a.code(empty, Value) od;
	if fieldtab[oper] = undefined then
	   exp_op2('call', symtab[oper][S_VALUE].seq, nactuals);
	else
	   exp_op2('fld', fieldtab[oper].seq, nactuals)
	fi;
	voidcall(rval);
	return(abs(rval));
      );
      
init: assert optab[O_ADIC] = args.size;
end OPCALL;

class SEMI(exprs)
begin fetch exprs, code;
      proc code(lab, rval)
      ( var i;
	newfl('nil');
	for i in interval(0, exprs.size-2, 1)
	do void(exprs[i].code(empty, Novalue)) od;
	oldfl();
	return(exprs[exprs.size-1].code(lab, rval))
     );
init:
     if exprs.size = 0 then
	return(UNDEFINED)
     elif exprs.size = 1 then
	return(exprs[0])
     fi;
end SEMI;

class IFTHEN(line, test, ethen)
begin fetch line, test, ethen, code;
      proc code(lab, rval)
      ( var f := flab.next;
	newfl(f);
	line.code(empty, Novalue);
	void(test.code(empty, Novalue));
	oldfl();
	void(ethen.code(empty, Novalue));
	label(f);
	inspect(rval, 'ifthen');
	return(Novalue);
      );
end IFTHEN;

class IFELSE(line, test, ethen, eelse)
begin fetch line, test, ethen, eelse, code;
      proc code(lab, rval)
      ( var f := flab.next, l, aval;
	line.code(empty, Novalue);
	newfl(f);
	void(test.code(empty, Novalue));
	oldfl();
	if lab = empty then l := llab.next else l := lab fi;
	aval := ethen.code(l, rval);
	if rval = Novalue then void(aval)
	elif rval = Assign then rval := aval
	fi;
	go(l);
	label(f);
	aval := eelse.code(l, rval);
	if rval = Novalue then void(aval) fi;
	if lab = empty then label(l) fi;
	return(rval);
      );
end IFELSE;

class WHILEDO(line, test, body)
begin fetch line, test, body, code;
      proc code(lab, rval)
      ( var f, l1, l2;
	line.code(empty, Novalue);
	label(l1 := llab.next);
	if type(test) ~= 'CONSTANT' then
		newfl(f := flab.next);
		void(test.code(empty, Novalue));
		oldfl();
		void(body.code(l1, Novalue));
		go(l1);
		label(f);
	else	# optimize "infinite" loops #
		void(body.code(l1, Novalue));
		go(l1)
	fi;
	inspect(rval, 'whiledo');
	return(Novalue);
      );
end WHILEDO;

class CASE(line, name, iexpr, deflab, defexpr, caselabs, caseexprs)
begin fetch line, name, iexpr, deflab, defexpr, caselabs, caseexprs, code;
      proc code(lab, rval)
      ( var nm, n, lout, aval, l, i;
	line.code(empty, Novalue);
	iexpr.code(empty, Value);
	exp_opw1('gocase', name.seq);
	lout := llab.next;
	for i in caselabs.index
	do label(caselabs[i]);
	   aval := caseexprs[i].code(empty, rval);
	   if rval = Novalue then void(aval)
	   elif rval = Assign then rval := aval
	   fi;
	   go(lout);
	od;
	label(deflab);
	if defexpr = undefined then
	   ercode('case');
	else
	   aval := defexpr.code(empty, rval);
	   if rval = Novalue then void(rval)
	   elif rval = Assign then rval := aval
	   fi;
	fi;
	label(lout);
	return(rval);
      );
end CASE;

#----------------------------try-expr----------------------------------
|	TRY e1, e2, ... UNTIL e0 YRT
| generates:
|	newrc
|	newfl	F1
|	(code for e1)
|	go	L
| F1:	resrc
|	newfl	F2
|	(code for e2)
|	go	L
| F2:	resrc
|	...
| Fn:	resrc
|	oldrc
|	gofl
| L:	(code for e0)
|	oldfl
|	oldrc
----------------------------------------------------------------------#

class TRY(line, exprs, uexpr)
begin fetch line, exprs, uexpr, code;
      proc code(lab, rval)
      ( var f, l, aval, e, rv;
	rv := if uexpr = undefined then rval else Novalue fi;
	line.code(empty, Novalue);
	newrc();
	nrc := nrc + 1;
	l := llab.next;
	for e in exprs
	do newfl(f := flab.next);
	   aval := e.code(empty, rv);
	   if rv = Novalue then void(aval)
	   elif rv = Assign then ermsg('illegal assignment to try', lnr)
	   fi;
	   go(l);
	   label(f);
	   resrc();
	od;
	oldrc();
	gofl();
	label(l);
	if uexpr ~= undefined then
	   aval := uexpr.code(empty, rval);
	   if rval = Novalue then void(aval)
	   elif rval = Assign then ermsg('illegal assignment to try', lnr)
	   fi
	fi;
	oldfl();
	oldrc();
	nrc := nrc - 1;
	return(rval)
      );
end TRY;

class ASSERT(expr)
begin fetch expr, code;
      proc code(lab, rval)
      ( var aval, l, f;
	newfl(f := flab.next);
	l := llab.next;
	aval := expr.code(empty, rval);
	oldfl();
	go(l);
	label(f); ercode('assert');
	label(l);
	return(aval)
      );
end ASSERT;

class RETURN(expr)
begin fetch expr, code;
      proc code(lab, rval)
      ( var f, t := type(expr);
         if t = 'CONSTANT' |
            t = 'VARIABLE' & (expr.kind = LocalVar | expr.kind = GlobalVar)
        then				# expr cannot fail #
	   expr.code(empty, Value);
	   retu(1)
        elif t = 'undefined' then	# no value return #
	   retu(0)
	else				# general case #
	   newfl(f := flab.next);
	   expr.code(empty, Value);
	   # oldfl() is not necessary, but flstack must be popped #
	   popfl();
	   retu(1);
	   label(f);
	   fretu();
	fi;
	inspect(rval, 'return');
	return(Novalue)
      );
end RETURN;

class FRETURN()
begin fetch code;
      proc code(lab, rval)
      ( fretu();
	inspect(rval, 'freturn');
	return(rval);
      );
end FRETURN;

class SELF()
begin fetch code;
      proc code(lab, rval)
      ( if rval = Value then
	   exp_op0('self');
	else
	   inspect(rval, 'self')
	fi;
	return(rval);
      );
end SELF;

class SUBJECT()
begin fetch code;
      proc code (lab, rval)
      ( if rval = Value then
	   exp_op0('subject')
	else
	   inspect(rval, 'self')
	fi;
	return(rval);
      );
end SUBJECT;

class LINE()
begin fetch delta, code;
      var delta := lnr - lastlnr;

      proc code(lab, rval)
      ( lnr := lnr + delta;
	exp_op1('line', delta);
	return(Novalue)
      );
init:
      lastlnr := lnr;
end LINE;

#----------------------------scan-expr---------------------------------
|	SCAN s FOR e ROF
| generates:
|	(code for s)
|	newsubj
|	newfl	F
|	(code for e)
|	oldfl
|	go	L
| F:	oldsubj
|	gofl
| L:	oldsubj
----------------------------------------------------------------------#

class SCAN(subj, expr)
begin fetch subj, expr, code;
      proc code(lab, rval)
      ( var f, l, aval;
	subj.code(empty, Value);
	newsubj();
	nsubj := nsubj + 1;
	newfl(f := flab.next);
	aval := expr.code(empty, rval);
	oldfl();
	go(l := llab.next);
	label(f);
		oldsubj();
		gofl();
	label(l);
		oldsubj();
	nsubj := nsubj - 1;
	return(aval);
      );
end SCAN;

class FIELDSEL(instance, name, args)
begin fetch instance, name, args, code;

      proc code(lab, rval)
      ( var a, seq;
	if fieldtab[name] = undefined then
	   ermsg('non existing field "' || name || '" selected', lnr);
	   seq := 0
	else
	   seq := fieldtab[name].seq
	fi;
	instance.code(empty, Value);
	for a in args do a.code(empty, Value) od;
	if rval = Assign then
	   exp_op2('asfld', seq, args.size + 1)
	else
	   exp_op2('fld', seq, args.size + 1);
	   voidcall(rval);
	fi;
	return(rval);
      );

end FIELDSEL;

class ARIND(arr, ind)
begin fetch arr, ind, code;
      proc code(lab, rval)
      ( arr.code(empty, Value);
	ind.code(empty, Value);
	if rval = Assign then
	   exp_op0('asind');
	else 
	   exp_op0('ind')
	fi;
	return(rval);
      );
end ARIND;
      
class ARINIT(size, def, exprs)
begin fetch size, def, exprs, code;
      proc code(lab, rval)
      ( var e, i;
	if rval = Value | rval = Novalue then
	   for e in exprs do e.code(empty, Value) od;
	   def.code(empty, Value);
	   size.code(empty, Value);
	   exp_opw1('arinit', exprs.size);
	else
	   exp_op1('xar', exprs.size);
	   for i in exprs.index
	   do var aval := exprs[i].code(empty, Assign);
	      if aval ~= Assign then
		 ermsg('illegal element in multiple assignment', lnr)
	      fi;
	      if i ~= exprs.size - 1 then void(aval) fi
	   od;
	   if (type(def) = 'CONSTANT' & def.val = undefined &
	      type(size) = 'CONSTANT' & size.val = exprs.size) fails
	   then
	      ermsg('illegal multiple assignment', lnr)
	   fi
	fi;
	return(rval);
      );
	      
end ARINIT;

class TABINIT(size, def, actsize, keys)
begin fetch size, def, actsize, keys, code;
      proc code(lab, rval)
      ( var k;
	if type(def) = 'string' then
	   exp_opw1('load', def);
	else
	   def.code(empty, Value);
	fi;
	size.code(empty, Value);
	exp_op0('tabinit');
	for k in keys do k.code(empty, Value) od;
	return(Value);
      );
end TABINIT;

class KEY(keys, expr)
begin fetch keys, expr, code;
      proc code(lab, rval)
      ( var k;
	if type(expr) = 'string' then
	   exp_opw1('load', expr)
	else
	   expr.code(empty, Value);
	fi;
	for k in keys do k.code(empty, Value) od;
	exp_opw1('tabelem', keys.size);
	return(Value)
      );
end KEY;

class VARINIT(line1, name, expr, line2)
begin fetch line1, name, expr, line2, code;
      proc code(lab, rval)
      ( #! generate line numbers in some cases #
	return(ASSIGN(name, expr).code(lab, rval))
      );
end VARINIT;

class DYOP(oper, left, right)
begin fetch oper, left, right, code;
      proc code(lab, rval)
      ( if oper = '&' then
	   void(left.code(empty, Novalue));
	   return(right.code(lab, rval))
	elif oper = '|' then
	   var f, l, aval;

	   newfl(f := flab.next);
	   if lab = empty then l := llab.next else l := lab fi;
	   aval := left.code(empty, rval);
	   if rval = Novalue then void(aval)
	   elif rval = Assign then rval := aval
	   fi;
	   oldfl(); go(l); label(f);
	   aval := right.code(l, rval);
	   if rval = Novalue then void(aval)
	   elif rval = Assign then rval := aval
	   fi;
	   if lab = empty then label(l) fi;
	   return(rval)
	else
	   left.code(empty, Value);
	   right.code(empty, Value);
	   exp_op0(dytab[oper][O_CODE]);
	   return(Value)
	fi;
      );
      proc ir_ir(a, b)
      (var ta := type(a), tb := type(b);
           if (ta = 'integer' | ta = 'real') & (tb = 'integer' | tb ='real')
	   then
	      return(True)
	   else
	      ermsg('dyadic operator requires integer or real arguments', lnr);
	      freturn
	   fi
      );
      proc i_i(a, b)
           if (type(a) = 'integer') & (type(b) = 'integer') then
              return(True)
           else
              ermsg('dyadic operator requires integer operands', lnr);
              freturn
	   fi;
      proc s_s(a, b)
           if (type(a) = 'string') & (type(b) = 'string') then
              return(True)
           else
              ermsg('dyadic operator requires string operands', lnr);
              freturn
	   fi;

init: if type(left) = 'CONSTANT' & type(right) = 'CONSTANT' then
         var vleft := left.val, vright:= right.val, res;

          case oper of
          '+':	if ir_ir(vleft, vright) then res := vleft + vright fi,
          '-':	if ir_ir(vleft, vright) then res := vleft - vright fi,
          '*':	if ir_ir(vleft, vright) then res := vleft * vright fi,
          '/':	if ir_ir(vleft, vright) then
		   if vright = 0 then
                      ermsg('division by 0', lnr)
                    else
                      res := vleft / vright
		    fi
                fi,
          '%':	if i_i(vleft, vright) then
		   if vright = 0 then
		      ermsg('division by 0', lnr)
		   else
		      res := vleft % vright
		   fi
		fi,
          '||':	if s_s(vleft, vright) then res := vleft || vright fi,
          default:
          esac;
          if res ~= undefined then return(CONSTANT(res)) fi
      fi;
      if oper = ':=' then
	 return(ASSIGN(left, right))
      fi;
end DYOP;

class MONOP(oper, and)
begin fetch oper, and, code;
      proc code(lab, rval)
      ( if oper = '~' then
	   var f, l;

	   if lab = empty then f := flab.next else f := lab fi;
	   newfl(f);
	   l := llab.next;
	   void(and.code(l, Novalue));
	   inspect(rval, 'not');
	   label(l);
	   oldfl();
	   gofl();
	   if lab = empty then label(f) fi;
	   return(Novalue);
	else
	   and.code(lab, Value);
	   exp_op0(montab[oper][O_CODE]);
	   return(Value);
	fi;
      );

init: if type(and) = 'CONSTANT' then
         var v := and.val, tv := type(v);
         if oper = '-' then
            if tv = 'integer' | tv = 'real' then
               return(CONSTANT(-v))
            else
               ermsg('monadic - has argument of illegal type', lnr)
            fi
         fi
      fi;
end MONOP;
