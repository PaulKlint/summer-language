#*************************************************************************#
#**									**#
#**			SUMMER COMPILER					**#
#**									**#
#** This is a compiler for the SUMMER programming language as described **#
#** in:									**#
#**	Klint, P., An overview of the SUMMER programming language,	**#
#**	Conference Record of the 7th Annual ACM Symposium on		**#
#**	Principles of Programming Languages, ACM, 1980, 47-55.		**#
#** or:									**#
#**	Klint, P., From SPRING to SUMMER: Design, definition and	**#
#**	implementation of programming languages for string manipulation **#
#**	and pattern matching, (dissertation), Amsterdam, 1982.		**#
#**									**#
#** The compiler uses the parsergenerator "pgen" as described in	**#
#**	Florijn, G. & Rolf, G.,						**#
#**	Pgen - a general purpose parser generator,			**#
#**	Mathematical Centre Report IW 157/81.				**#
#**									**#
#** The compiler consists of three parts:				**#
#**	1. (file: "parser.ns"): lexical scanner.			**#
#**	2. (file: "parser.syn"): grammar + actions.			**#
#**	3. (file: "parser.ud"): symboltable routines, codegeneration.	**#
#**									**#
#*************************************************************************#
#**                                                                  	**#
#** 	SUMMER COMPILER PART I:  lexical scanner			**#
#**                                                                  	**#
#** This file contains procedures which form a lexical scanner	     	**#
#** for SUMMER. The following variables/procedures/constants are	**#
#** (pre)defined by the	parser generator:				**#
#**									**#
#**		line:		current line,				**#
#**		lnr:		current line number,			**#
#**		ermsg:		produces error messages,		**#
#**		errcnt:		number of errors in source,		**#
#**		sy:		current symbol,				**#
#**		t_sy:		current symbol type,			**#
#**		predef:		types of predefined LEXICAL classes,	**#
#**		keytab:		types of keywords,			**#
#**		kartab:		types of "literals" (e.g. ':', ':='),	**#
#**		lower:		lower case letters,			**#
#**		upper:		upper case letters,			**#
#**		digit:		digits,					**#
#**		ASCII:		ordered string of ASCII characters,	**#
#**				the first one is the space.		**#
#**									**#
#** The following variables and constants are defined in parser.ud:	**#
#**		montab:		contains monadic operators,		**#
#**		dytab:		contains dyadic operators,		**#
#**									**#
#*************************************************************************#
#*************************************************************************#

var     ascii		:= '\000\001\002\003\004\005\006\007' ||
			   '\010\011\012\013\014\015\016\017' ||
			   '\020\021\022\023\024\025\026\027' ||
			   '\030\031\032\033\034\035\036\037' ||
			   ASCII || '\177';

var	NON_STANDARD_CHARS := ascii.substr(0,31) || '\\' || '"' || '\177';

var	ILLEGAL_CHARS	:= '\000\001\002\003\004\005\006\007' ||
	                               '\013\014'||'\016\017' ||
	    		   '\020\021\022\023\024\025\026\027' ||
	    		   '\030\031\032\033\034\035\036\037' ||
	    		   '\177',
	STOP_CHARS	:= '\\''' || ILLEGAL_CHARS;

var	f_src,
		# File containing the SUMMER source #
	char_to_int;
		# octal conversion table #

var	t_str, t_int, t_real, t_op, t_ident, t_dot, t_lp, t_rp, t_lbr,
	t_rbr, t_comma, t_semi, t_colon, t_EOF, t_EOF_INCLUDE;

proc init_scanner()
(	var i, c;

	t_str	:= predef['string_constant'];
	t_int	:= predef['integer_constant'];
	t_real	:= predef['real_constant'];
	t_op	:= predef['operator_symbol'];
	t_ident	:= predef['identifier'];
	t_dot	:= kartab['.'];
	t_lp	:= kartab['('];
	t_rp	:= kartab[')'];
	t_lbr	:= kartab['['];
	t_rbr	:= kartab[']'];
	t_comma	:= kartab[','];
	t_semi	:= kartab[';'];
	t_colon	:= kartab[':'];
	t_EOF	:= predef['EOF'];
	t_EOF_INCLUDE := kartab['eof_include'];

	keytab['init'] := kartab['init'];

	#*******************************************************#
	# 'init' is a keyword, but the syntax of parsgen	#
	# does not allow writing it as INIT. Nevertheless, it	#
	# should be in keytab, in order to retrieve its type	#
	# correctly.						#
	#*******************************************************#

	char_to_int := table(128, undefined);
	for i in interval(0, 32, 1) do char_to_int[ascii[i]] := i od;
	for c in ASCII do char_to_int[c] := '''' || c od;
	char_to_int['\\'] := 92;
	char_to_int['\177'] := 127;

);
	#***************************************************************#
	# This procedure initializes symbol types. It is called just	#
	# before the first call to nextsym; in that way it is certain	#
	# that predef and kartab are initialized at the moment these	#
	# types are initialized.					#
	#***************************************************************#

proc comment()
(	var cseen := True, readln := True;

        while True
        do      if cseen = False
		then	line.span(layout) | empty_string;
			if line.lit('#')
			then	cseen := True; readln := False;
			elif line.rpos(0)
			then	readln := True;
			else	return
			fi;
		fi;
		if cseen = True 
		then	if line.break('#') & line.move(1)
			then	cseen := False;
				readln :=
				if line.rpos(0) then True else False fi;
			else	readln := True
			fi
		fi;
		if readln=True & ~src.get
		then	if cseen = True
			then	ermsg('non closed comment', lnr) fi;
			return
		fi;
	od;
);

proc get_str()
(	var c;

	t_sy := t_str;
	sy := '';
	scan line for
	while sy := sy || break(STOP_CHARS)
	do	if lit('''') then
		   if lit('''') then sy := sy || ''''
		   else
		      return
		   fi
		elif lit('\\\\') then sy := sy || '\\'
		elif lit('\\t')  then sy := sy || '\t'
		elif lit('\\n')  then sy := sy || '\n'
		elif lit('\\b')  then sy := sy || '\b'
		elif lit('\\r')  then sy := sy || '\r'
		elif lit('\\') then
		   if c := integer((lit('0') | lit('1'))) * 64 +
			   integer(any('01234567')) * 8 +
			   integer(any('01234567'))
		   then sy := sy || ascii[c]
		   else
		        ermsg('illegal escape sequence in string', lnr);
		   fi
		else
		     ermsg('illegal character in string', lnr);
		     move(1);
		fi;
	od;
	rtab(0);
	ermsg('string not terminated', lnr);
	rof;
);

proc get_number()
assert  scan line
	for   var tail;
	      if tail := span(digit)
	      then sy := if sy = '0' then tail else sy || tail fi
	      fi &
	      t_sy := t_int &
	      if sy := sy || lit('.') || (span(digit) | '')
	      then t_sy := t_real
	      fi &
	      if sy := sy || lit('e') || (any('+-') | '') || span(digit)
	      then t_sy := t_real
	      fi
	rof;

	#***************************************************************#
	#    Get_number parses a number which start with a digit	#
	#    (and not with a dot). After parsing a sequence of digits,	#
	#    type t_int is assigned. If that sequence is followed by	#
	#    either a dot (possibly followed by another string of 	#
	#    digits), or e [+|-|nothing] followed by a string of digits,#
	#    or both, the type is t_real.				#
	#***************************************************************#

proc get_real_or_dot()
scan line
for   if sy := sy || span(digit) ||
	       ( lit('e') || (any('+-') | '') || span(digit)
		 | '')
      then t_sy := t_real
      else t_sy := t_dot
      fi
rof;
	#***************************************************************#
	# 3. To parse a single dot, or a real denotation which starts	#
	#    with a dot, and then must be followed by at least one	#
	#    digit. '.e3' is not a legal real denotation because of the	#
	#    difficulties it would cause 'nextsym' to distinguish	#
	#    between a field selection and a real.			#
	#***************************************************************#


proc get_opname()
scan line
for	sy := sy || span(alphanum) | 'OK';
	t_sy := t_op;
	if montab[sy] ~= undefined | dytab[sy] ~= undefined
	then return
	elif scan sy for lit('_') & any(alpha) & rtab(1) & lit('_') rof fails
	then	ermsg('illegal operator name "' || sy || '"', lnr)
	fi
rof;


proc nextsym()
while True
do line.span(layout) | empty_string;
   if sy := line.any(alpha) || (line.span(alphanum) | empty_string)
   then
	t_sy := (undefined ~= keytab[sy] | t_ident);
	return;
   elif sy := line.move(1)
   then 
	case sy
	of	'0':		# skip leading zeros #
				line.span('0') | empty_string;
				get_number();
				return,
		'1': '2': '3': '4': '5': '6': '7': '8': '9':
				get_number();
				return,
		'.':
				get_real_or_dot();
				return,
		'''':
				get_str();
				return,
		'_':		get_opname();
				return,
		'*': '+': '-': '/': ':': '<': '=': '>': '?':
		'|': '&': '~': '!': '$': '%': '\\': '@':
				sy := sy || line.span(ops) | 'OK';
				if sy = ':'
				then	t_sy := t_colon
				else	t_sy := t_op
				fi;
				return,
		'(':
				t_sy := t_lp;
				return,
		')':
				t_sy := t_rp;
				return,
		'[':
				t_sy := t_lbr;
				return,
		']':
				t_sy := t_rbr;
				return,
		',':
				t_sy := t_comma;
				return,
		';':
				t_sy := t_semi;
				return,
		'#':
				comment(),
		default:	ermsg('illegal character "' || sy || '"', lnr)
	esac
   elif src.get
   then # noop #
   elif src.previous ~= undefined
   then sy := 'EOF_INCLUDE';
	t_sy := t_EOF_INCLUDE;
	return
   else sy := 'EOF';
	t_sy := t_EOF;
	return
   fi
od;
	#***************************************************************#
	# comment must be updated					#
	# 'nextsym' determines the next lexical symbol (in 'sy') and	#
	# its type (in 't_sy'). First, tabs and spaces are skipped.	#
	# If then nothing is left on the current line, the proecdure	#
	# reads new lines until it finds one with a meaningful symbol.	#
	# There are altogether 15 possibilities:			#
	# 1. Identifiers and keywords, which get a separate treatment	#
	#    to speed up their recognition. Their type is either	#
	#    extracted from keytab, or t_int.				#
	# 2. Integers, and reals for so far they start with a digit.	#
	# 3. A single dot, which could also be the start of a real.	#
	# 4. A string.							#
	# 5. An operator name starting with an underline.		#
	# 6. An operator consisting of a sequence of operator symbols.	#
	#    An explicit test for a single colon is included here.	#
	# 7. A left parenthesis.					#
	# 8. A right parenthesis.					#
	# 9. A left bracket.						#
	#10. A right bracket.						#
	#11. A comma.							#
	#12. A semi_colon.						#
	#13. The start of a comment. After the comment has been parsed,	#
	#    a next pass through the loop is executed, to retrieve	#
	#    a meaningful symbol.					#
	#14. If the current line contains a non_layout character which	#
	#    is none of the above, it is illegal. An error message is	#
	#    issued an a new pass through the loop executed.		#
	#15. If the current line is empty and no new line can be read	#
	#    from the source file, we are at end-of-file.		#
	#***************************************************************#

