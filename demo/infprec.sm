#****************************************************************
*								*
* infprec -- infinite precision (integer) arithmetic		*
*								*
* The algorithms in this program are taken from Gimpels book	*
* "Algorithms in SNOBOL4".					*
*								*
****************************************************************#


var no_digits := 4;

proc empty () return(lit(''));

proc lpad(s, n)
  if s.size >= n then
     return(s)
  else
     return(s.right(n, '0') )
  fi;

proc min(a,b) return(if a < b then a else b fi);

proc sign_of(x)  scan x for lit('-') & return(rtab(0)) rof;

proc ldg_zeros() return(break('123456789') | rtab(1));

#************************************************************************
* small(x, y) -- are x and y small enough to use integer arithmetic ?	*
************************************************************************#

proc small(x, y) return(x.size <= no_digits & y.size <= no_digits);

#************************************************************************
* split(x, n) -- split x in two parts x1, x2 in such a way that		*
* x1.size = n.								*
* split returns (k, x1, x2) where k is the amount of the split measured	*
* from the right.							*
************************************************************************#

proc split(x, n)
( var top, bot;

  if n < 0 then n := x.size % 2 fi;
  scan x
  for
    top := (move(n) | empty()) & (span('0') | empty()) & bot := rtab(0)
  rof;
  if top = '' then top := '0' fi;
  if bot = '' then bot := '0' fi;
  return([x.size - top.size , top, bot])
);

#************************************************************************
* minus(x) -- unary minus						*
************************************************************************#

proc minus(x)
  return(
  if small(x, '') then string(-integer(x)) else
     if x := sign_of(x) then x else '-' || x fi
  fi);

#************************************************************************
* gt(x,y) -- the > opererator						*
* Most relational opererators are reduced to this case.			*
************************************************************************#
proc gt(x, y)
  if small(x, y) then return(integer(x) > integer(y))
  else
    if x := sign_of(x) then
       if ~(y := sign_of(y)) then freturn else [x, y] := [y, x] fi
    fi;
    if y := sign_of(y) then return('')
    else
       return(lpad(x, y.size ) > lpad(y, x.size ))
    fi
  fi;

proc eq(x, y) x = y;

proc ne(x, y) x ~= y;

proc lt(x, y) ~(gt(x, y) | eq(x, y));

proc le(x, y) ~gt(x, y);


#************************************************************************
* diff(x, y) -- (x - y)							*
************************************************************************#
proc diff(x, y) return(sum(x, minus(y)));

proc sum(x, y)
( var x1, x2, y1, y2, k, l, s;
  if small(x, y) then return(string(integer(x) + integer(y)))
  elif lt(x, '0') then return(minus(sum(minus(x), minus(y))))
  else
     if y := sign_of(y) then
	# case x > 0 & y < 0					#
	# Ensure x >= y and then add the 10's complement	#
	# of y.							#
        if gt(y, x) then return(minus(diff(y, x)))
        else
           y := lpad(y, x.size );
           s := sum(sum(x, '1'), y.replace('0123456789', '9876543210') );
	   scan s for break('1') & lit('1') & ldg_zeros() & return(rtab(0)) rof
	fi
     else
	# case x > 0 & y > 0 					#
        if lt(x, y) then [x, y] := [y, x] fi;
	[k, x1, x2] := split(x, -1);
	y := sum(y, x2);
	[l, y1, y2] := split(y, y.size - k);
	return(sum(y1, x1) || lpad(y2, k))
     fi
  fi
);

#************************************************************************
| mult(x, y) -- (x * y)							|
************************************************************************#
proc mult(x, y)
( var k, x1, x2, r;

  if x.size + y.size <= no_digits then
     return(string(integer(x) * integer(y)))
  else
     if lt(x, '0') then return(mult(minus(x), minus(y))) fi;
     if lt(y, '0') then return(minus(mult(x, minus(y)))) fi;
     if gt(y, x) then [x, y] := [y, x] fi;
     if eq(y, '0') then return('0') fi;
     [k, x1, x2] := split(x, -1);
     r := mult(y, x1) || '0'.repl(k) ;
     return(sum(r, mult(x2, y)))
  fi
);

#************************************************************************
| div(x, y) -- ( x / y)							|
************************************************************************#
proc div(x, y)
( var x1, x2, kx, y1, y2, ky, t, t1, t2, r;

  if small(x, y) then return(string(integer(x) % integer(y))) fi;
  if lt(x , '0') then return(minus(div(minus(x), y))) fi;
  if lt(y , '0') then return(minus(div(x, minus(y)))) fi;
  if gt(y, x) then return('0') fi;
  [ky, y1, y2] := split(y, min(no_digits%2, y.size ));
  [kx, x1, x2] := split(x, no_digits);
  t1 := div(x1, y1);
  t2 := '0'.repl(kx - ky) ;
  t  := diff(x, mult(t1, y) || t2);
  r  := t1 || t2;
  if lt(t, '0') then
     t := diff(sum(t, '1'), y)
  fi;
  return(sum(r, div(t, y)))
);


proc numb()
( (span('0') | empty) &
  return(span('0123456789') | '0')
);

proc ator() return(any('+-/*'));

program infprec (args)
( var x, y, oper, line, p, data;

  if args.size = 0
  then data := stand_in
  else
       data := file(args[0], 'r');
  fi;
  while line := data.get()
  do
     if scan line for x := numb() & oper := ator() & y := numb()  & rpos(0) rof then
	put(x, ' ', oper, ' ', y, ' = ');
	put(case oper of
		'+': sum(x, y),
		'-': diff(x, y),
		'*': mult(x, y),
		'/': div(x, y)
		esac, '\n');
     else
	put('type <integer><op><integer> with <op>= "+", "-", "*" or "/"\n');
     fi;
  od
)
