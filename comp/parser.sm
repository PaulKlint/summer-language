# used files:
-r-xr-xr-x  1 paulk    ai          94492 Jan  7  1982 /summer/paulk/sys/pgen/pg
-rw-r--r--  1 paulk    ai           1641 Jan  7  1982 /summer/paulk/sys/pgen/pglib
-rw-rw-r--  1 paulk    ai          28348 Jan  9 14:36 parser.syn
-rw-rw-r--  1 paulk    ai          10946 Jan  9 15:05 parser.ns
#
const
	lower := 'abcdefghijklmnopqrstuvwxyz',
	upper := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
	digit := '0123456789',
	ASCII := ' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';

var
	lnr := 0, sy, t_sy, line := scan_string(' '), errcnt := 0;

proc SET(syms)
(	var i, b := bits(SETSIZE,0);

	for i in syms
	do
		b[i] := 1;
	od;
	return(b);
);


proc UN2(s1,s2)
(	
	return(s1.disj(s2))
);


proc UN3(s1,s2,s3)
(
	return((s1.disj(s2)).disj(s3))
);


proc error(mess,ln)
(
	ermsg(mess || ' expected', ln);
);


proc testsymee(exp1, exp2, dont_skip, message)
(	testsym(UN2(exp1, exp2), dont_skip, message);
);

proc testsymeee(exp1, exp2, exp3, dont_skip, message)
(	testsym(UN3(exp1, exp2, exp3), dont_skip, message);
);
proc testsymdd(exp, dont_skip1, dont_skip2, message)
(	testsym(exp, UN2(dont_skip1, dont_skip2), message);
);

proc testsym(exp,dont_skip,message)
(	if exp[t_sy] = 0
	then	var mess := '  ',
		    nskipped := 0,
		    erlnr := lnr,
		    both := UN2( exp,dont_skip);


		 	while both[t_sy] = 0
			do	if nskipped < 6
				then	if nskipped < 5
					then mess := mess || sy || ' '
					else mess := mess || sy || ' ...';
					fi;
					nskipped := nskipped + 1;
				fi;
				nextsym;
			od;
                        if mess ~= '  ' 
                        then    mess := ' "'|| mess || '"' || ' skipped.';
				if lnr - erlnr > 2 then
					mess := mess ||
						'\n       scan resumed at "' ||
						sy || '", in line '||string(lnr)
				fi
			fi;
                        if  message ~= ''
			then error(message,erlnr);
			fi;
			if mess ~= '  '
			then ermsg(mess,erlnr);
			fi;
	fi;
);
# user defined:
-rw-r--r--  1 paulk    ai          62763 Mar 13 18:17 parser.ud
#
#*************************************************************************#
#*************************************************************************#
#**									**#
#**	SUMMER COMPILER PART III: parse tree -> code			**#
#**									**#
#** This file contains procedures for symtable management, building of  **#
#** parse trees and code generation.					**#
#**									**#
#** Variables/procedures used here which are (pre)defined by the	**#
#** parsergenerator:							**#
#** 	ermsg:		issues error messages,				**#
#**	errcnt:		number of errors in source,			**#
#**	lnr:		current source line number.			**#
#**									**#
#*************************************************************************#
#*************************************************************************#

const	lpar		:= '(',
	sc		:= ',',
	newl		:= '\n',
	NIL		:= '~nil',

	NOFETCH		:= '_fetcher',
	NOSTORE		:= '_storeer',
	SIMPLE		:= '0',
	PROC		:= '~proc',
	VAR		:= '~var',
	fetch_type	:= 'fetch',
	store_type	:= 'store',
	empty		:= '',

	o_lpar		:= '(',
	S_LEVEL		:= 0,
	S_NEXT		:= 1,
	S_VALUE		:= 2,

	O_NAME		:= 0,
	O_ADIC		:= 1,
	O_STATUS	:= 2,
	O_PRIOF		:= 3,
	O_PRIOG		:= 4,
	O_CODE		:= 5,

	False		:= 0,
	True		:= 1;

const	LocalVar	:= 0,
	GlobalVar	:= 1,
	ClassVar	:= 2,
	BuiltinProc	:= 3,
	GlobalProc	:= 4,
	ClassProc	:= 5,
	BuiltinClass	:= 6,
	Class		:= 7,
	Constant	:= 8,
	Forward		:= 9,
	Field		:= 10,
	Program		:= 11;
	
const	Assign		:= -1,
	Novalue		:= 0,
	Value		:= 1;

#*************************** GENERAL GLOBAL VARIABLES *********************#


var	f_er,
		# error message file					#
	src,	# a SOURCE object representing the current source file.	#
		# Handles the tree structure of nested include files.	#
	opstack := [],
		# The operator stack.					#
		# The stack is pushed by 'opush', popped by 'opush'	#
		# Elements on opstack are entries from montab and dytab.#

	ndstack := [],
		# The operand stack.					#
		# Pushed by 'ndpush', popped by 'ndpop'			#
		# Entries on the stack are operands.        		#
	glcnt := 0,
		# Determines the next global index			#
	symtab,
		# global symbol table (see init_tables)			#
	fieldtab,
		# global field table (see init_tables)			#

        # classtab (real declaration occurs in 'prefix', see below)	#
		# Class table. Keys are classnames, entries are arrays	#
		# of six elements defined as follows:			#
		# 0:	number of datafields declared in the class	#
		#	(= size of an class instance)			#
		# 1:	parameter fields				#
		# 2:	(remaining) var fields				#
		# 3:	procedure fields				#
		# 4:	operator fields					#
		# 5:	sequence number of this class.			#
		# These elements are used by 'do_subclass' when a new	#
		# subclass is declared.					#
	inhertab := table(10, undefined),
		# During the parse of a subclass, inhertab contains	#
		# entries for fields which are inherited from the super-#
		# class and may still be redefined.			#

        fetchtab := table(5, undefined),
	storetab := table(5, undefined),
		# Keys are fieldnames occurring in respectively the	#
		# 'fetch' and the 'store' declaration of the current	#
		# class. Values are the associations ('_s' for simple,	#
		# or a name).						#

	assoctab := table(5, undefined),
		# keys are procedure names declared as associations,	#
		# values are fetch_ or store_type. Used to check whether#
		# number of arguments and return values are correct.	#

	loclist := [],
		# Names of locals of the current procedure. Used to	#
		# produce string representing symbolic names (convlocs).#
		# Names of constants of the current block		#

	par_flds := [],
	data_flds := [],
	proc_flds := [],
	op_flds := [],
		# parameters, data fields and procedure and operator	#
		# fields of current class.				#
		# Names of fields of current class. Used by 'undefine'	#
		# to remove them from symtab on class exit.		#

	level := 0,
		# Current depth of name-nesting. Incremented on proce-	#
		# dure entry, on class entry and on block entry. Decre-	#
		# Used by 'symentry' to check for illegal redefinitions.#
	loccnt := 0,
		# Determines the offset of the next local variable to	#
		# be declared. For global procedures and operators, the	#
		# offset is initially 0; for classes and their associa-	#
		# ted procedures it is 1, as 0 is reserved for the class#
		# object passes as additional argument.			#
		# Because the tracer needs a unique mapping from local	#
		# numbers to associated names, the offset is not reset	#
		# on block exit. This does however cause an inefficient	#
		# use of space in the interpreter.			#

	# nclasses  (declared in "prefix"				#
		# To determine class sequence number. Incremented on 	#
		# entry of a new class.					#

	nfields := 0,
		# Determines field sequence number.			#
	curproc,
		# The PROC_DECL corresponding to the current procedure	#
	curclassname,
		# The name of the current class; used during code generation #
		# by PROC_DECL and CALL to treat FORWARD nodes.	#

	globinit := [],
		# array of VARINITs for global initializations		#
	caseinit := [],
		# array of VARINITs for case table initialazations	#
	classvarinit,
		# array of VARINITs for data field initializations in	#
		# class declarations.					#
	classprocs,
		# array of PROC_DECLs for field and operator procs	#
		# used by PROC_DECL.complete				#
	offset,
		# The current class offset. Set to 0 on class entry,	#
		# incremented for each new data field.			#
	clname,
		# The name of the current class. Used to make field-	#
		# entries ('procedure', 'vars', 'operator', 'params')	#
		# and to check whether a field is not redefined within	#
		# the same class ('fieldentry').			#
	inproc := 0,
		# Flag which signals whether the current program point	#
		# lies within a procedure, an operator, a class init	#
		# statement or the main program. Used by 'locvars' to	#
		# detect illegal local declarations (allowed only when	#
		# inproc = 1), and by 'forloop' to recognize whether it	#
		# must invent global or local variables.		#
	inloop := 0,
		# Indicator for nesting level inside while, for or try	#
		# expressions; used to determine whether explicit	#
		# variable initialization should be generated for	#
		# declaration without initializing expression.		#
		# See <local_initialization>.				#

	lastlnr := 1,
		# The source line number on which the most recent line	#
		# increment was generated. (Such an instruction enables	#
		# the interpreter and the tracer to compute source line	#
		# numbers from the ic-code). 'lastlnr' is set to lnr by #
		# 'LINE' and each time an absolute linenumber is	#
		# generated in the code.				#

	may_sel := False,
	may_sub := False,
		# Indicate whether the last <unit> may be selected or	#
		# subscribed. See parser.syn				#

	montab := table (20, undefined) init
		[	'-' :		['-', 1,0,13,14,'neg'],
			'~' :		['~',  1,0,13,14,'*error*']
                ],


        dytab := table(20, undefined) init
                [       ':=':           [':=', 2, 0,  7, 8,'*error*'],
                        '+' :           [ '+', 2, 0, 11,11,'add'],
                        '-' :           ['-', 2, 0, 11,11,'sub'],
                        '*' :           [ '*', 2, 0, 12,12,'mul'],
                        '/' :           [ '/', 2, 0, 12,12,'div'],
                        '%' :           [ '%', 2, 0, 12,12,'idiv'],
                        '||':           ['||', 2, 0, 13,13,'conc'],
                        '&' :           [ '&', 2, 0,  6, 6,'*error*'],
                        '|' :           [ '|', 2, 0,  4, 5,'*error*'],
                        '<' :           [ '<', 2, 0, 10,10,'lt'],
                        '<=':           ['<=', 2, 0, 10,10,'le'],
                        '>' :           [ '>', 2, 0, 10,10,'gt'],
                        '>=':           ['>=', 2, 0, 10,10,'ge'],
                        '=' :           [ '=', 2, 0, 10,10,'eq'],
                        '~=':           ['~=', 2, 0, 10,10,'ne'],
                        '(' :           [ '(', 2, 0,  1, 2,'*error*']
		],
		# 'montab' and 'dytab' map operator names to a 5-tuple,	#
		# consisting of the following items:			#
		# - An internal name (without class suffix). For user	#
		#   defined operators, this is their external name	#
		#   followed by a dot followed by 1 or 2 according to	#
		#   their adicity.					#
		# - A 1 for monadic and a 2 for dyadic operators.	#
		#   Entries from montab and dytab are stacked on the	#
		#   operator stack, and unstacked (by 'treatop' and	#
		#   'emptystack') without knowing from which table they #
		#   originally came. Hence the necessity to include the #
		#   adicity.						#
		# - A declaration status indicator:			#
		#   - 0 for build in, global operators.			#
		#   - 1 for user defined, global operators as yet 	#
		#     without a namesake within a class.		#
		#   - 2 for user defined, global operators with a name-	#
		#     sake within a class. User defined operators which #
		#     occur both globally and within a class, get an    #
                #     additional entry in 'fieldtab'. The 1 and 2 serve #
		#     to see whether this entry has been made already.	#
		#     (see also 'operator' and 'addglobf').		#
		#   - 3 for operators defined as yet only within a class#
		#     Built-in class operators don't occur as yet, but  #
		#     should get the same treatment as user defined	#
		#     ones, i.e. when a global namesake is defined, an  #
		#     additional entry must be amde in the fieldtable.  #
		#   - -lnr for operator names occurring in 'monadic' and#
		#     'dyadic' declarations, but not yet defined. lnr	#
		#     is the source line number on which the declaration#
		#     occurred, rememberd here in order to be able to	#
		#     issue an error message at the correct line when	#
		#     the operator remains undefined.			#
		#   - The f-priority.					#
		#   - The g-priority.					#
		#   All user defined operators get the same priority.   #

	stringtab := table(500, undefined),
		# table of string constants #

	slab      := labelgenerator('S'),

	UNDEFINED := CONSTANT(undefined),

	typetag	:= table(10, '') init [
		'integer':	'I',
		'real':		'R',
		'string':	'S',
		'array':	'A',
		'table':	'T',
		'file':		'F',
		'bits':		'B',
		'scan_string':	'SC',
		'interval':	'IV'
		];

	# table with standard type tags for builtin class procedures	#
	# Example: the procedure "update" for tables is "T_update"	#
	# This convention has to be respected in the interpreter	#

include 'prefix';

	# prefix has the following duties:				#
	# - declare proc "prefix" (prints assembler prefix)		#
	# - declare and initialize "classtab"				#
	# - declare constant "long"					#
	# - declare and initialize var "nclasses"			#


proc decl_built_in_proc(name, kind, nformals)
	symentry(name, 0, BUILT_IN_PROC_DECL(name, kind, nformals));

proc built_in_fieldentry(fieldname, classname, ftype, intern, ffetch, fstore)
( var f := fieldtab[fieldname];
  if f = undefined then
     f := FIELD_DECL(fieldname, fieldname);
     fieldtab[fieldname] := f;
  fi;
  f.add(FIELD(fieldname, classname, ftype, intern, ffetch, fstore));
);

proc init_tables()
(
	symtab := table (100, undefined);
	decl_built_in_proc('string',BuiltinClass,2);
	decl_built_in_proc('real',BuiltinClass,2);
	decl_built_in_proc('integer',BuiltinClass,2);
	decl_built_in_proc('scan_string',BuiltinClass,2);
	decl_built_in_proc('file',BuiltinClass,3);
	decl_built_in_proc('bits',BuiltinClass,3);
	decl_built_in_proc('interval',BuiltinClass,4);
	decl_built_in_proc('copy',BuiltinProc, 1);
	decl_built_in_proc('stop',BuiltinProc, 1);
	decl_built_in_proc('system',BuiltinProc, 1);
	decl_built_in_proc('type',BuiltinProc, 1);
	decl_built_in_proc('put',BuiltinProc, -1);
	decl_built_in_proc('get',BuiltinProc, -1);
	symentry('stand_in',  0, VARIABLE('stand_in',GlobalVar));
	symentry('stand_out', 0, VARIABLE('stand_in',GlobalVar));
 	symentry('stand_er',  0, VARIABLE('stand_in',GlobalVar));

	fieldtab := table(50, undefined);
	built_in_fieldentry('any','scan_string',PROC,'any','any',NOSTORE);
	built_in_fieldentry('append','array',PROC,'append','append',NOSTORE);
	built_in_fieldentry('break','scan_string',PROC,'break','break',NOSTORE);
	built_in_fieldentry('center','string',PROC,'center','center',NOSTORE);
	built_in_fieldentry('close','file',PROC,'close','close',NOSTORE);
	built_in_fieldentry('compl','bits',PROC,'compl','compl',NOSTORE);
	built_in_fieldentry('conj','bits',PROC,'conj','conj',NOSTORE);
	built_in_fieldentry('delete','array',PROC,'delete','delete',NOSTORE);
	built_in_fieldentry('disj','bits',PROC,'disj','disj',NOSTORE);
	built_in_fieldentry('find','scan_string',PROC,'find','find',NOSTORE);
	built_in_fieldentry('get','file',PROC,'get','get',NOSTORE);
	built_in_fieldentry('index','array',PROC,'index','index',NOSTORE);
		built_in_fieldentry('index','table',PROC,'index','index',NOSTORE);
		built_in_fieldentry('index','string',PROC,'index','index',NOSTORE);
		built_in_fieldentry('index','bits',PROC,'index','index',NOSTORE);
	built_in_fieldentry('last','array',PROC,'last','last',NOSTORE);
	built_in_fieldentry('left','string',PROC,'left','left',NOSTORE);
	built_in_fieldentry('lit','scan_string',PROC,'lit','lit',NOSTORE);
	built_in_fieldentry('move','scan_string',PROC,'move','move',NOSTORE);
	built_in_fieldentry('next','string',PROC,'next','next',NOSTORE);
		built_in_fieldentry('next','array',PROC,'next','next',NOSTORE);
		built_in_fieldentry('next','table',PROC,'next','next',NOSTORE);
		built_in_fieldentry('next','interval',PROC,'next','next',NOSTORE);
		built_in_fieldentry('next','bits',PROC,'next','next',NOSTORE);
	built_in_fieldentry('pos','scan_string',PROC,'pos','pos',NOSTORE);
	built_in_fieldentry('put','file',PROC,'put','put',NOSTORE);
	built_in_fieldentry('repl','string',PROC,'repl','repl',NOSTORE);
	built_in_fieldentry('replace','string',PROC,'replace','replace',NOSTORE);
	built_in_fieldentry('retrieve','array',PROC,'retrieve','retrieve',NOSTORE);
		built_in_fieldentry('retrieve','table',PROC,'retrieve','retrieve',NOSTORE);
		built_in_fieldentry('retrieve','string',PROC,'retrieve','retrieve',NOSTORE);
		built_in_fieldentry('retrieve','bits',PROC,'retrieve','retrieve',NOSTORE);
	built_in_fieldentry('reverse','string',PROC,'reverse','reverse',NOSTORE);
	built_in_fieldentry('right','string',PROC,'right','right',NOSTORE);
	built_in_fieldentry('rpos','scan_string',PROC,'rpos','rpos',NOSTORE);
	built_in_fieldentry('rtab','scan_string',PROC,'rtab','rtab',NOSTORE);
	built_in_fieldentry('size','array',PROC,'size','size',NOSTORE);
		built_in_fieldentry('size','bits',PROC,'size','size',NOSTORE);
		built_in_fieldentry('size','string',PROC,'size','size',NOSTORE);
		built_in_fieldentry('size','table',PROC,'size','size',NOSTORE);
	built_in_fieldentry('sort','array',PROC,'sort','sort',NOSTORE);
	built_in_fieldentry('span','scan_string',PROC,'span','span',NOSTORE);
	built_in_fieldentry('substr','string',PROC,'substr','substr',NOSTORE);
	built_in_fieldentry('tab','scan_string',PROC,'tab','tab',NOSTORE);
	built_in_fieldentry('update','array',PROC,'update','update',NOSTORE);
		built_in_fieldentry('update','table',PROC,'update','update',NOSTORE);
		built_in_fieldentry('update','bits',PROC,'update','update',NOSTORE);
	built_in_fieldentry('bal','scan_string',PROC,'bal','bal',NOSTORE);
	built_in_fieldentry('text','scan_string',VAR,0,SIMPLE,NOSTORE);
	built_in_fieldentry('cursor','scan_string',VAR,1,SIMPLE,NOSTORE);


	fieldtab['+.2']  := FIELD_DECL('+.2', 'add');
	fieldtab['-.2']  := FIELD_DECL('-.2', 'sub');
	fieldtab['-.1']  := FIELD_DECL('-.1', 'neg');
	fieldtab['*.2']  := FIELD_DECL('*.2', 'mul');
	fieldtab['/.2']  := FIELD_DECL('/.2', 'div');
	fieldtab['%.2']  := FIELD_DECL('%.2', 'idiv');
	fieldtab['||.2'] := FIELD_DECL('||.2', 'conc');
	fieldtab['=.2']  := FIELD_DECL('=.2', 'eq');
	fieldtab['~=.2'] := FIELD_DECL('~=.2', 'ne');
	fieldtab['>.2']  := FIELD_DECL('>.2', 'gt');
	fieldtab['>=.2'] := FIELD_DECL('>=.2', 'ge');
	fieldtab['<.2']  := FIELD_DECL('<.2', 'lt');
	fieldtab['<=.2'] := FIELD_DECL('<=.2', 'le');
	   	# Fieldtable. Keys are all field names defined up to the#
		# current program point. Entries consist of classname,	#
		# PROC or VAR, the internal name (for procedures) or the#
		# offset (for data-fields), the fetch association, the  #
                # store association, and a successor.			#
		# For operator fields, the key is the internal operator	#
		# name (without class suffix): for a monadic (dyadic)	#
		# operator @, '@.1' ('@.2').				#
);

class labelgenerator(lab)
begin fetch next;
      var current := -1;
      proc next() return(lab || string(current := current + 1));

end labelgenerator;

#********* Class declarations for parse tree nodes *********************#

class ASSIGN(left, right)
begin fetch left, right, code;
      proc code(lab, rval)
      ( right.code(empty, Value);
	if left.code(empty, Assign) ~= Assign then
	   ermsg('illegal left hand side of assignment', lnr)
	fi;
	return(Value);
      );
end ASSIGN;

class SUP_CALL(super, args)
begin fetch super, args, code;
      proc code(lab, rval)
      ( var a;
        assert super.kind = Class;
        assert args.size = super.nformals;
        for a in args do a.code(empty, Value) od;
        exp_op2('call', super.seq, args.size);
        voidcall(rval);
        return(abs(rval))
      );
end SUP_CALL;

class CALL(left, args)
begin fetch left, args, code;
      proc treat(args)
      ( var a;
	for a in args do a.code(empty, Value) od
      );
      proc code(lab, rval)
      ( var nactuals := args.size;
        case left.kind of
	GlobalProc:
	BuiltinProc:
	   treat(args);
	   # note: left.nformals < 0 => variable number of arguments #
	   if nactuals ~= left.nformals & left.nformals >= 0 then
	      ermsg(left.name || ' called with wrong number of arguments', lnr);
	      return(abs(rval))
	   fi;
	   exp_op2('call', left.seq, nactuals),
	Class:
	BuiltinClass:
	   exp_op0('undef');
	   treat(args);
	   if nactuals + 1 ~= left.nformals & left.nformals >= 0 then
	      ermsg(left.name || ' called with wrong number of arguments', lnr);
	      return(abs(rval))
	   fi;
	   exp_op2('call', left.seq, nactuals + 1),
	ClassProc:
	   exp_op0('self');
	   treat(args);
	   if fieldtab[left.name].is_unique_field &
	      fieldtab[left.name].last.classname = curclassname
	   then
	      exp_op2('call', left.seq, nactuals + 1)
	   else
	      exp_op2('ifld', fieldtab[left.name].seq, nactuals + 1)
	   fi,
	Field:
	Forward:
	   assert fieldtab[left.name] ~= undefined;
	   if fieldtab[left.name].locate_fld(curclassname) then
	      exp_op0('self');
	      treat(args);
	      exp_op2('ifld', fieldtab[left.name].seq, nactuals + 1)
	   elif symtab[left.name] ~= undefined then
		return(CALL(symtab[left.name][S_VALUE], args).code(lab, rval))
	   else
	      return(FIELDSEL(SUBJECT, left.name, args).code(lab, rval))
	   fi
	esac;
	voidcall(rval);
	return(abs(rval))
      );
end CALL;

class OPCALL(optab, args)
begin fetch optab, args, code;
      proc code(lab, rval)
      ( var nactuals := args.size, a, oper := optab[O_NAME];

	for a in args do a.code(empty, Value) od;
	if fieldtab[oper] = undefined then
	   exp_op2('call', symtab[oper][S_VALUE].seq, nactuals);
	else
	   exp_op2('fld', fieldtab[oper].seq, nactuals)
	fi;
	voidcall(rval);
	return(abs(rval));
      );
      
init: assert optab[O_ADIC] = args.size;
end OPCALL;

class SEMI(exprs)
begin fetch exprs, code;
      proc code(lab, rval)
      ( var i;
	newfl('nil');
	for i in interval(0, exprs.size-2, 1)
	do void(exprs[i].code(empty, Novalue)) od;
	oldfl();
	return(exprs[exprs.size-1].code(lab, rval))
     );
init:
     if exprs.size = 0 then
	return(UNDEFINED)
     elif exprs.size = 1 then
	return(exprs[0])
     fi;
end SEMI;

class IFTHEN(line, test, ethen)
begin fetch line, test, ethen, code;
      proc code(lab, rval)
      ( var f := flab.next;
	newfl(f);
	line.code(empty, Novalue);
	void(test.code(empty, Novalue));
	oldfl();
	void(ethen.code(empty, Novalue));
	label(f);
	inspect(rval, 'ifthen');
	return(Novalue);
      );
end IFTHEN;

class IFELSE(line, test, ethen, eelse)
begin fetch line, test, ethen, eelse, code;
      proc code(lab, rval)
      ( var f := flab.next, l, aval;
	line.code(empty, Novalue);
	newfl(f);
	void(test.code(empty, Novalue));
	oldfl();
	if lab = empty then l := llab.next else l := lab fi;
	aval := ethen.code(l, rval);
	if rval = Novalue then void(aval)
	elif rval = Assign then rval := aval
	fi;
	go(l);
	label(f);
	aval := eelse.code(l, rval);
	if rval = Novalue then void(aval) fi;
	if lab = empty then label(l) fi;
	return(rval);
      );
end IFELSE;

class WHILEDO(line, test, body)
begin fetch line, test, body, code;
      proc code(lab, rval)
      ( var f, l1, l2;
	line.code(empty, Novalue);
	label(l1 := llab.next);
	if type(test) ~= 'CONSTANT' then
		newfl(f := flab.next);
		void(test.code(empty, Novalue));
		oldfl();
		void(body.code(l1, Novalue));
		go(l1);
		label(f);
	else	# optimize "infinite" loops #
		void(body.code(l1, Novalue));
		go(l1)
	fi;
	inspect(rval, 'whiledo');
	return(Novalue);
      );
end WHILEDO;

class CASE(line, name, iexpr, deflab, defexpr, caselabs, caseexprs)
begin fetch line, name, iexpr, deflab, defexpr, caselabs, caseexprs, code;
      proc code(lab, rval)
      ( var nm, n, lout, aval, l, i;
	line.code(empty, Novalue);
	iexpr.code(empty, Value);
	exp_opw1('gocase', name.seq);
	lout := llab.next;
	for i in caselabs.index
	do label(caselabs[i]);
	   aval := caseexprs[i].code(empty, rval);
	   if rval = Novalue then void(aval)
	   elif rval = Assign then rval := aval
	   fi;
	   go(lout);
	od;
	label(deflab);
	if defexpr = undefined then
	   ercode('case');
	else
	   aval := defexpr.code(empty, rval);
	   if rval = Novalue then void(rval)
	   elif rval = Assign then rval := aval
	   fi;
	fi;
	label(lout);
	return(rval);
      );
end CASE;

#----------------------------try-expr----------------------------------
|	TRY e1, e2, ... UNTIL e0 YRT
| generates:
|	newrc
|	newfl	F1
|	(code for e1)
|	go	L
| F1:	resrc
|	newfl	F2
|	(code for e2)
|	go	L
| F2:	resrc
|	...
| Fn:	resrc
|	oldrc
|	gofl
| L:	(code for e0)
|	oldfl
|	oldrc
----------------------------------------------------------------------#

class TRY(line, exprs, uexpr)
begin fetch line, exprs, uexpr, code;
      proc code(lab, rval)
      ( var f, l, aval, e, rv;
	rv := if uexpr = undefined then rval else Novalue fi;
	line.code(empty, Novalue);
	newrc();
	nrc := nrc + 1;
	l := llab.next;
	for e in exprs
	do newfl(f := flab.next);
	   aval := e.code(empty, rv);
	   if rv = Novalue then void(aval)
	   elif rv = Assign then ermsg('illegal assignment to try', lnr)
	   fi;
	   go(l);
	   label(f);
	   resrc();
	od;
	oldrc();
	gofl();
	label(l);
	if uexpr ~= undefined then
	   aval := uexpr.code(empty, rval);
	   if rval = Novalue then void(aval)
	   elif rval = Assign then ermsg('illegal assignment to try', lnr)
	   fi
	fi;
	oldfl();
	oldrc();
	nrc := nrc - 1;
	return(rval)
      );
end TRY;

class ASSERT(expr)
begin fetch expr, code;
      proc code(lab, rval)
      ( var aval, l, f;
	newfl(f := flab.next);
	l := llab.next;
	aval := expr.code(empty, rval);
	oldfl();
	go(l);
	label(f); ercode('assert');
	label(l);
	return(aval)
      );
end ASSERT;

class RETURN(expr)
begin fetch expr, code;
      proc code(lab, rval)
      ( var f, t := type(expr);
         if t = 'CONSTANT' |
            t = 'VARIABLE' & (expr.kind = LocalVar | expr.kind = GlobalVar)
        then				# expr cannot fail #
	   expr.code(empty, Value);
	   retu(1)
        elif t = 'undefined' then	# no value return #
	   retu(0)
	else				# general case #
	   newfl(f := flab.next);
	   expr.code(empty, Value);
	   # oldfl() is not necessary, but flstack must be popped #
	   popfl();
	   retu(1);
	   label(f);
	   fretu();
	fi;
	inspect(rval, 'return');
	return(Novalue)
      );
end RETURN;

class FRETURN()
begin fetch code;
      proc code(lab, rval)
      ( fretu();
	inspect(rval, 'freturn');
	return(rval);
      );
end FRETURN;

class SELF()
begin fetch code;
      proc code(lab, rval)
      ( if rval = Value then
	   exp_op0('self');
	else
	   inspect(rval, 'self')
	fi;
	return(rval);
      );
end SELF;

class SUBJECT()
begin fetch code;
      proc code (lab, rval)
      ( if rval = Value then
	   exp_op0('subject')
	else
	   inspect(rval, 'self')
	fi;
	return(rval);
      );
end SUBJECT;

class LINE()
begin fetch delta, code;
      var delta := lnr - lastlnr;

      proc code(lab, rval)
      ( lnr := lnr + delta;
	exp_op1('line', delta);
	return(Novalue)
      );
init:
      lastlnr := lnr;
end LINE;

#----------------------------scan-expr---------------------------------
|	SCAN s FOR e ROF
| generates:
|	(code for s)
|	newsubj
|	newfl	F
|	(code for e)
|	oldfl
|	go	L
| F:	oldsubj
|	gofl
| L:	oldsubj
----------------------------------------------------------------------#

class SCAN(subj, expr)
begin fetch subj, expr, code;
      proc code(lab, rval)
      ( var f, l, aval;
	subj.code(empty, Value);
	newsubj();
	nsubj := nsubj + 1;
	newfl(f := flab.next);
	aval := expr.code(empty, rval);
	oldfl();
	go(l := llab.next);
	label(f);
		oldsubj();
		gofl();
	label(l);
		oldsubj();
	nsubj := nsubj - 1;
	return(aval);
      );
end SCAN;

class FIELDSEL(instance, name, args)
begin fetch instance, name, args, code;

      proc code(lab, rval)
      ( var a, seq;
	if fieldtab[name] = undefined then
	   ermsg('non existing field "' || name || '" selected', lnr);
	   seq := 0
	else
	   seq := fieldtab[name].seq
	fi;
	instance.code(empty, Value);
	for a in args do a.code(empty, Value) od;
	if rval = Assign then
	   exp_op2('asfld', seq, args.size + 1)
	else
	   exp_op2('fld', seq, args.size + 1);
	   voidcall(rval);
	fi;
	return(rval);
      );

end FIELDSEL;

class ARIND(arr, ind)
begin fetch arr, ind, code;
      proc code(lab, rval)
      ( arr.code(empty, Value);
	ind.code(empty, Value);
	if rval = Assign then
	   exp_op0('asind');
	else 
	   exp_op0('ind')
	fi;
	return(rval);
      );
end ARIND;
      
class ARINIT(size, def, exprs)
begin fetch size, def, exprs, code;
      proc code(lab, rval)
      ( var e, i;
	if rval = Value | rval = Novalue then
	   for e in exprs do e.code(empty, Value) od;
	   def.code(empty, Value);
	   size.code(empty, Value);
	   exp_opw1('arinit', exprs.size);
	else
	   exp_op1('xar', exprs.size);
	   for i in exprs.index
	   do var aval := exprs[i].code(empty, Assign);
	      if aval ~= Assign then
		 ermsg('illegal element in multiple assignment', lnr)
	      fi;
	      if i ~= exprs.size - 1 then void(aval) fi
	   od;
	   if (type(def) = 'CONSTANT' & def.val = undefined &
	      type(size) = 'CONSTANT' & size.val = exprs.size) fails
	   then
	      ermsg('illegal multiple assignment', lnr)
	   fi
	fi;
	return(rval);
      );
	      
end ARINIT;

class TABINIT(size, def, actsize, keys)
begin fetch size, def, actsize, keys, code;
      proc code(lab, rval)
      ( var k;
	if type(def) = 'string' then
	   exp_opw1('load', def);
	else
	   def.code(empty, Value);
	fi;
	size.code(empty, Value);
	exp_op0('tabinit');
	for k in keys do k.code(empty, Value) od;
	return(Value);
      );
end TABINIT;

class KEY(keys, expr)
begin fetch keys, expr, code;
      proc code(lab, rval)
      ( var k;
	if type(expr) = 'string' then
	   exp_opw1('load', expr)
	else
	   expr.code(empty, Value);
	fi;
	for k in keys do k.code(empty, Value) od;
	exp_opw1('tabelem', keys.size);
	return(Value)
      );
end KEY;

class VARINIT(line1, name, expr, line2)
begin fetch line1, name, expr, line2, code;
      proc code(lab, rval)
      ( #! generate line numbers in some cases #
	return(ASSIGN(name, expr).code(lab, rval))
      );
end VARINIT;

class DYOP(oper, left, right)
begin fetch oper, left, right, code;
      proc code(lab, rval)
      ( if oper = '&' then
	   void(left.code(empty, Novalue));
	   return(right.code(lab, rval))
	elif oper = '|' then
	   var f, l, aval;

	   newfl(f := flab.next);
	   if lab = empty then l := llab.next else l := lab fi;
	   aval := left.code(empty, rval);
	   if rval = Novalue then void(aval)
	   elif rval = Assign then rval := aval
	   fi;
	   oldfl(); go(l); label(f);
	   aval := right.code(l, rval);
	   if rval = Novalue then void(aval)
	   elif rval = Assign then rval := aval
	   fi;
	   if lab = empty then label(l) fi;
	   return(rval)
	else
	   left.code(empty, Value);
	   right.code(empty, Value);
	   exp_op0(dytab[oper][O_CODE]);
	   return(Value)
	fi;
      );
      proc ir_ir(a, b)
      (var ta := type(a), tb := type(b);
           if (ta = 'integer' | ta = 'real') & (tb = 'integer' | tb ='real')
	   then
	      return(True)
	   else
	      ermsg('dyadic operator requires integer or real arguments', lnr);
	      freturn
	   fi
      );
      proc i_i(a, b)
           if (type(a) = 'integer') & (type(b) = 'integer') then
              return(True)
           else
              ermsg('dyadic operator requires integer operands', lnr);
              freturn
	   fi;
      proc s_s(a, b)
           if (type(a) = 'string') & (type(b) = 'string') then
              return(True)
           else
              ermsg('dyadic operator requires string operands', lnr);
              freturn
	   fi;

init: if type(left) = 'CONSTANT' & type(right) = 'CONSTANT' then
         var vleft := left.val, vright:= right.val, res;

          case oper of
          '+':	if ir_ir(vleft, vright) then res := vleft + vright fi,
          '-':	if ir_ir(vleft, vright) then res := vleft - vright fi,
          '*':	if ir_ir(vleft, vright) then res := vleft * vright fi,
          '/':	if ir_ir(vleft, vright) then
		   if vright = 0 then
                      ermsg('division by 0', lnr)
                    else
                      res := vleft / vright
		    fi
                fi,
          '%':	if i_i(vleft, vright) then
		   if vright = 0 then
		      ermsg('division by 0', lnr)
		   else
		      res := vleft % vright
		   fi
		fi,
          '||':	if s_s(vleft, vright) then res := vleft || vright fi,
          default:
          esac;
          if res ~= undefined then return(CONSTANT(res)) fi
      fi;
      if oper = ':=' then
	 return(ASSIGN(left, right))
      fi;
end DYOP;

class MONOP(oper, and)
begin fetch oper, and, code;
      proc code(lab, rval)
      ( if oper = '~' then
	   var f, l;

	   if lab = empty then f := flab.next else f := lab fi;
	   newfl(f);
	   l := llab.next;
	   void(and.code(l, Novalue));
	   inspect(rval, 'not');
	   label(l);
	   oldfl();
	   gofl();
	   if lab = empty then label(f) fi;
	   return(Novalue);
	else
	   and.code(lab, Value);
	   exp_op0(montab[oper][O_CODE]);
	   return(Value);
	fi;
      );

init: if type(and) = 'CONSTANT' then
         var v := and.val, tv := type(v);
         if oper = '-' then
            if tv = 'integer' | tv = 'real' then
               return(CONSTANT(-v))
            else
               ermsg('monadic - has argument of illegal type', lnr)
            fi
         fi
      fi;
end MONOP;

#************ Procedures for the treatment of operators ****************#

proc check_monop(symbol)
if montab[symbol] = undefined
then	if dytab[symbol] = undefined
	then	ermsg('"' || symbol || '" undefined', lnr)
	else	ermsg('dyadic operator "' || symbol
		      || '" used in monadic position', lnr)
	fi
fi;


proc check_dyop(symbol)
if dytab[symbol] = undefined
then	if montab[symbol] = undefined
	then	ermsg('"' || symbol || '" undefined', lnr)
	else	ermsg('monadic operator "' || symbol
		      || '" used in dyadic position', lnr)
	fi
fi;



proc opush(opr)
if errcnt = 0 then opstack.append(opr); fi;

proc opop()
if errcnt = 0 then return(opstack.delete) fi;
	# Pushing and popping the operator stack.			#

proc ndpush(and)
if errcnt = 0 then ndstack.append(and) fi;

proc ndpop()
if errcnt = 0 then return(ndstack.delete) fi;

	# Pushing and popping the operand stack				#

proc priofdef(nf)
	return(if nf = 1 then 13 else 9 fi);
	# The standard f-priorities (monadic: 13, dyadic: 9) for user	#
	# defined operators.						#

proc priogdef(nf)
	return(if nf = 1 then 14 else 9 fi);
	# The standard g-priorities for user defined operators.		#

proc treatop(newop)
(	var prg, oldop;

	if errcnt = 0 then prg := newop[O_PRIOG] fi;
	while  errcnt = 0 & opstack.last[O_PRIOF] >= prg
	do	oldop := opop();
		if oldop[O_STATUS] = 0
		then	if oldop[O_ADIC] = 1 then
			   ndpush(MONOP(oldop[O_NAME], ndpop()))
		        else
		   	   var right := ndpop(), left := ndpop();
			   ndpush(DYOP(oldop[O_NAME], left, right))
			fi;
		else	if oldop[O_ADIC] = 1 then
			   ndpush(OPCALL(oldop, [ndpop()]))
			else
			   var right := ndpop(), left := ndpop();
			   ndpush(OPCALL(oldop, [left, right]))
			fi
		fi
	od;
	opush(newop)
);
	# The argument is an operator (or, more accurately, an entry	#
	# from 'montab' or 'dytab') to be pushed on the operator stack.	#
	# Before this is done, operators are popped from opstack and	#
	# handed to MONOP or DYADOP until one is found with an		#
	# f-priority lower than the g-priority of the new operator. 	#
	# A left parenthesis has an f-priority lower than the g-priority#
	# of any operator and is hence never popped.			#
	# 'treatop' has to distinguish built-in from user defined	#
	# operators; the latter are operands of the operator 'o_opcall'.#

proc emptystack()
( var oldop, osp := opstack.size;

	while osp > 0 & errcnt = 0
	do	oldop := opop(); osp := osp - 1;
		if oldop[O_NAME] = lpar
		then return(ndpop());
		elif oldop[O_STATUS] = 0
		then	if oldop[O_ADIC] = 1 then
			   ndpush(MONOP(oldop[O_NAME], ndpop()))
			else
			   var right := ndpop(), left := ndpop();
			   ndpush(DYOP(oldop[O_NAME], left, right))
			fi;
		else	if oldop[O_ADIC] = 1 then
				ndpush(OPCALL(oldop, [ndpop()]))
			else
			   var right := ndpop(), left := ndpop();
			   ndpush(OPCALL(oldop, [left, right]))
			fi
		fi
	od;
	return(UNDEFINED)
);
	# Resembles 'treatop', but pops operators until either the	#
	# stack is empty or a left parenthesis (which is also popped)	#
	# is found.							#

#******************* Symbol table routines *****************************#

class VARIABLE(name, kind)
begin fetch kind, name, seq, code, can_call, can_assign, isglobal, tag;
      var seq;

      proc isglobal()
        if kind = GlobalVar then return(True) else freturn fi;

      proc tag()
	if kind = GlobalVar then return('G' || string(seq)) else freturn fi;

      proc code(lab, rval)
      ( case kind of
	LocalVar:	if rval = Assign then
			   exp_op1('asloc', seq)
			elif rval = Value then
			   exp_op1('loc', seq)
			fi,
	GlobalVar:	if rval = Assign then
			   exp_op1('asglob', seq)
			elif rval = Value then
			   exp_op1('glob', seq)
			fi,
	ClassVar:	if rval = Assign then
			   if fieldtab[name].is_unique_field then
			      exp_op1('ascloc', seq)
			   else
			      exp_op0('self');
			      exp_op2('iasfld', fieldtab[name].seq, 1)
			   fi
			elif rval = Value then
			   if fieldtab[name].is_unique_field then
			      exp_op1('cloc', seq)
			   else
			      exp_op0('self');
			      exp_op2('ifld', fieldtab[name].seq, 1)
			   fi
			fi,
	esac;
	return(rval);
      );

      proc can_call() freturn;

      proc can_assign() return(True);

init: case kind of
      LocalVar:		seq := loccnt; loccnt := loccnt + 1;
			if name = '' then name := '_' || string(loccnt) fi,
      GlobalVar:	seq := glcnt; glcnt := glcnt + 1;
			if name = '' then name := '_' || string(glcnt) fi,
      ClassVar:		seq := offset
      esac
end VARIABLE;

class FORWARD(name, lino)
begin fetch lino, kind, code, can_call, can_assign, isglobal, tag, resolved,
	    name, seq, nformals, complete, generate_body, retcnt, procs,
	    src_file;
      store resolved : asg_resolved;
      var resolved, src_file := src.name;

      proc kind()
        return(if resolved = undefined then Forward else resolved.kind fi);

      proc can_call()
        return(if resolved = undefined then True else resolved.can_call fi);

      proc can_assign()
	return(if resolved = undefined then True else resolved.can_assign fi);

      proc isglobal()
      ( assert resolved ~= undefined;
	return(resolved.isglobal)
      );

      proc tag()
      ( assert resolved ~= undefined;
	return(resolved.tag)
      );

      proc code(lab, rval)
      ( if resolved ~= undefined then
	   return(resolved.code(lab,rval))
	elif symtab[name] ~= undefined then
	   resolved := symtab[name][S_VALUE];
	   return(resolved.code(lab, rval))
	else
	   assert fieldtab[name] ~= undefined;
	   return(FIELDSEL(SUBJECT, name, []).code(lab, rval))
	fi
      );

      proc asg_resolved(val)
      ( if type(val) = 'FORWARD' then
	   if val.lino < lino then lino := val.lino fi;
	   resolved := val.resolved;
	else
	   resolved := val
	fi;
	return(val)
      );

      proc nformals() return(resolved.nformals);

      proc seq() return(resolved.seq);


      proc complete() resolved.complete;

      proc generate_body() resolved.generate_body;

      proc retcnt() return(resolved.retcnt);

      proc procs() return(resolved.procs);

end FORWARD;

class CONSTANT(val)
begin fetch val, kind, code, can_call, can_assign;

      proc code(lab, rval)
      ( if rval = Value then
	   case type(val) of
	   'integer':	exp_op1('int', val),
	   'string':	if val.size = 0 then
			   exp_op0('nullstr')
			else
			   exp_opw1('load', stringtab[val])
			fi,
	   'real':	exp_real(val),
	   'undefined':	exp_op0('undef')
	   esac
	elif rval = Assign then
	   ermsg('illegal assignment to ' || type(val), lnr)
	fi;
	return(rval);
      );

      proc can_call() freturn;

      proc can_assign() freturn;

      proc kind() return(Constant);

init: if type(val) = 'string' then
	declstring(val);
      fi;
end CONSTANT;

class FIELD(fieldname, classname, ftype, intern, ffetch, fstore)
begin fetch fieldname, classname, ftype, intern, ffetch, fstore;
      store fieldname, classname, ftype, intern, ffetch, fstore;
end FIELD;

class FIELD_DECL(fieldname, builtin_tag)
begin fetch fieldname, builtin_tag, generate, seq, last, add, locate_fld,
            redeffld, addglobf, is_unique_field, kind, name, can_call,
	    can_assign,code;

      var seq, global_alias, singlefields := [];

      proc kind() return(Field);

      proc name() return(fieldname);

      proc can_call() return(True);

      proc can_assign() return(True);

      proc code(lab, rval)
        return(CALL(self, []).code(lab, rval));

      proc last()
	if singlefields.size > 0 then
	   return(singlefields.last)
	else
	   freturn
	fi;

      proc add(field_descr)
        singlefields.append(field_descr);

      proc redeffld(fdes)
      (	var old := singlefields.last;

	if old.ftype = VAR
	then	if fdes.ftype ~= VAR
		then	ermsg('inherited variable redefined as procedure', lnr)
		else	fdes.intern := old.intern;
			offset := offset-1
		fi
	else	if fdes.ftype ~= PROC
		then	ermsg('inherited procedure redefined as variable', lnr)
		fi
	fi;
	singlefields[singlefields.size-1] := fdes;
      );
	# redeffld is called when a field inherited from a superclass is #
	# redefined in the subclass. The old entry is removed. Allowing  #
	# variables to be redefined as procedures and vice versa requires#
	# the following additions: if x was a var and becomes a proc, it #
	# must be removed from data_flds and added to proc_flds. All     #
	# offsets of data-fields > offset(x) must be decremented.     	 #
	# In the reverse case, x must be transferred from proc_flds to	 #
	# data_flds.							 #

       proc addglobf(proc_decl)
       ( assert global_alias = undefined;

	 global_alias := proc_decl;

       );
	# 'addglobf' makes an additional entry with class name '~global'#
	# for user defined operators which are declared both globally	#
	# and within a class.						#


       proc locate_fld(cl)
       ( var e ;

	for e in singlefields do if e.classname = cl then return(e) fi od;
	freturn;
       );
	# locate_fld finds the fieldtable entry created for field 'fld' #
	# in class 'cl'.						#

       proc is_unique_field() return(singlefields.size = 1);

       proc generate()
       ( var n, sep, x, switch := array(nclasses, -1);

	 for n in singlefields.index
	 do 
	    switch[classtab[singlefields[n].classname][5]] := n;
	 od;
	 f_s.put('FLDSW', seq, ': ');
	 sep := '.byte ';
	 for n in switch do f_s.put(sep, n); sep := sc od;
	 f_s.put(newl);

	 if builtin_tag ~= '' then
	    f_s.put('.globl _f_', builtin_tag, '; _f_', builtin_tag, ':\n');
	 fi;

	 f_s.put('FLD', seq, ':\n');
	 f_s.put(long, declstring(fieldname), newl);	# fdesc_name #
	 f_s.put(long, 'FLDSW', seq, newl);		# fdesc_switch #
	 f_s.put(long,					# fdesc_alias #
		 if global_alias=undefined then 'nil' else global_alias.tag fi,
		 newl);

	 for x in singlefields
	 do var fetch_assoc := x.ffetch, store_assoc := x.fstore;

	    if x.ftype = VAR then
              f_s.put(long, dec(0), ';',		# fld_type #
		      long, dec(x.intern), ';');	# fld_offset #
	    else  
	      f_s.put(long, if type(x.intern) = 'string' &
			       x.intern = fieldname then
	         	       '_' || typetag[x.classname] || fieldname
	      		    else
	         	       x.intern.tag
	      		    fi, ';',			# fld_type #
		      long, dec(-1), ';');		# fld_offset #
	    fi;

	    f_s.put(long, if type(fetch_assoc) = 'string' then
				if fetch_assoc = fieldname then
			   	   '_' || typetag[x.classname] || fieldname;
		  		else
		     	   	   fetch_assoc
	          		fi
	    	    	  else
	    			fetch_assoc.tag
	    	    	  fi, ';');

	    f_s.put(long, if type(store_assoc) = 'string' then
	          		if store_assoc = fieldname then
		     	   	   '_' || typetag[x.classname] || fieldname
	   	  		else store_assoc
				fi
	       	    	  else
	          		store_assoc.tag
	       	    	  fi, newl);
         od;
      );

init: seq := nfields;
      nfields := nfields + 1;

end FIELD_DECL;

class BUILT_IN_PROC_DECL(name, kind, nformals)
begin fetch name, kind, nformals, code, isglobal, can_call, can_assign, seq, tag;
      var seq;

      proc isglobal() return(True);

      proc can_call() return(True);

      proc can_assign() freturn;

      proc tag()
	return(
	case kind of
	BuiltinProc: 'BP',
	BuiltinClass: 'BC'
	esac || string(seq));

      proc code(lab, rval)
      ( var nf;
	nf := if kind = BuiltinClass then 1 else 0 fi;
	if nformals > 0 & nformals ~= nf then
	   ermsg(name || ': argument list missing', lnr)
	else
	   CALL(self, []).code(empty, rval);
	   if rval = Assign then
	      ermsg('assignment to procedure not allowed', lnr);
	      rval := Value
	   fi
	fi;
	return(rval);
      );
init: seq := glcnt; glcnt := glcnt + 1;

end BUILT_IN_PROC_DECL;

class PROC_DECL(kind)
begin fetch kind, complete, generate_body, code, body, retcnt, isglobal,
	    name, can_call, can_assign, seq, tag, nformals, procs;
      store body, retcnt, seq;
      var name, fnms, stlnr, elnr, body, retcnt, lnames, procs,
	  the_classcnt, seq;

      proc isglobal() return(True);

      proc tag()
        return(
	case kind of
	Program:
	GlobalProc:	'P',
	ClassProc:	'FLDP',
	Class:		'C'
	esac || string(seq));

      proc nformals() return(fnms.size);

      proc code(lab, rval)
      ( var nf;
	nf := if kind = Class | kind = ClassProc then 1 else 0 fi;
	if nformals > 0 & nformals ~= nf then
	   ermsg(name || ': argument list missing', lnr)
	else
	   CALL(self, []).code(empty, rval);
	   if rval = Assign then
	      ermsg('assignment to procedure not allowed', lnr);
	      rval := Value
	   fi
	fi;
	return(rval);
      );

      proc can_call() return(True);

      proc can_assign() freturn;

      proc complete(aname, afnms, abody)
      ( name := aname;
	fnms := afnms;
	remove(fnms);
	body := abody;
	elnr := lnr;
	lnames := loclist;
	if retcnt = undefined then retcnt := 0 fi;
	if kind = Class then
	   procs := classprocs;
	   classvarinit.append(body);
	   body := SEMI(classvarinit);
	   the_classcnt := nclasses;
	fi;
	inproc := 0;
	level := level-1
      );
	
      proc convlocs(list)
      if list.size = 0 then
         return('nil')
      else
	var l, s := '';
	for l in list do s := s || l || sc od;
	return(declstring(s));
      fi;

      proc generate_body()
      ( var nf, nloc;
        if errcnt = 0
	then	var fldlab;
		if kind = Class then
		   var p;
		   curclassname := name;
		   for p in procs do p.generate_body od;
		   curclassname := undefined;
		   fldlab := dec(-1);		# class creation proc #
		else
		   var fld := fieldtab[name];
		   if fld = undefined then
		   	fldlab := 'nil'		# global proc #
		   else
			fldlab := 'FLD' || string(fld.seq);
						# field proc #
		   fi;
		fi;
		nf := fnms.size;
		nloc := lnames.size;
		lnr := stlnr;
		lineflush();
		if kind = Program then
		   f_s.put('.globl _program', newl);
		   f_s.put('_program:', newl);
		fi;
		f_s.put(tag, ':', '\t# proc ', name, newl);
		f_s.put(long, 'dt_proc', newl,
			long, fldlab, newl,
			long, dec(nf), newl,
			long, dec(nloc-nf), newl,
			long, dec(nloc), newl,
			long, dec(stlnr), newl,
			long, dec(elnr), newl,
			long, convlocs(lnames), newl,
			long, dec(0), newl,		# freq #
			long, dec(0), newl);		# prof #
		if kind = Class then
		   newfl('nil');
		   exp_op1('newclass', classtab[name][5]);
		   exp_op1('asloc', 0);
		   exp_op0('void');
		   oldfl()
		fi;
		body.code(empty, Novalue);
		if kind = Class then
		   exp_op1('loc', 0);
		   retu(1)
		fi;
		if kind = Program
		then exp_op0('ihalt')
		else
		    if retcnt = 0 then retu(0) else ercode('ret') fi;
		fi;
		lineflush();
	fi;
      );

init:  	seq := glcnt; glcnt := glcnt + 1;
	stlnr := lastlnr := lnr;
	retcnt := undefined;
	inproc := 1;
	level := level+1;
	loccnt := 0;
	if kind = Class | kind = ClassProc then
	   symentry('self', level, VARIABLE('self', LocalVar));
	   loclist := ['self']
 	else
	   loclist := []
	fi;
end PROC_DECL;

class SOURCE(name, previous)
begin fetch name, previous, decls, get, back_to_previous, generate_body, errors;
      store errors;
      var decls := [], save, f, errors := 0;
	proc get()
	( if line := scan_string(f.get) fails
	  then line := scan_string('');
	       freturn
	  fi;
	  lnr := lnr + 1
	);

	proc generate_body()
	( var d;
	  save := [lnr, lastlnr];
	  lnr := lastlnr := 1;
	  src := self;
	  errors := 0;
	  for d in decls do d.generate_body od;
	  [lnr, lastlnr] := save;
	  if errors  = 1 then previous.errors := 0 fi;
	  src := previous;
	);

	proc back_to_previous()
	( if previous = undefined then freturn fi;
	  f.close;
	  [line, lnr, lastlnr] := save;
	  if errors = 1 then previous.errors := 0 fi;
	  src := previous;
	);

init:	if f := file(name, 'r') fails then freturn fi;
	save := [line, lnr, lastlnr];
	line := scan_string(f.get | '');
	lnr := lastlnr := 1;
end SOURCE;

proc symentry(name, lev, val)
(	var oldentry;

	oldentry := symtab[name];
	if oldentry = undefined | oldentry[S_LEVEL] ~= lev then
	   symtab[name] := [lev, oldentry, val];
	   return(True)
	elif oldentry[S_VALUE].kind = Forward then
	     if type(val) = 'CONSTANT' then
		ermsg('illegal forward reference(s) to constant "' ||
		name || '" ; first in line ' ||
		string(oldentry[S_VALUE].lino), lnr)
	     else
		oldentry[S_VALUE].resolved := val;
	     fi;
	     return(True)
	else
	   ermsg('"' || name || '" redeclared', lnr);
	   return(False)
	fi
);
	# Enters 'name' in symtab with value 'entry'. If an entry with	#
	# the same level already exists which is not a forward declara-	#
	# tion, a 'redeclared' error is issued. See also 'level' and	#
	# 'symtab'. 							#

proc fieldentry(fieldname, classname, ftype, intern, ffetch, fstore)
(	var s := symtab[fieldname],
	    f := fieldtab[fieldname],
            fdes := FIELD(fieldname,classname,ftype,intern,ffetch,fstore);

	if f = undefined
	then	f := FIELD_DECL(fieldname, '');
		fieldtab[fieldname] := f
	fi;
	if s ~= undefined
	then	if s[S_VALUE].kind = Forward
		then	symtab[fieldname] := undefined;
			s[S_VALUE].resolved := f;
		else	while s[S_NEXT] ~= undefined
			do	if (s[S_NEXT][S_VALUE]).kind = Forward
				then	s[S_NEXT][S_VALUE].resolved := f;
					s[S_NEXT] := undefined;
				else	s := s[S_NEXT]
				fi
			od;
			s := symtab[fieldname]
		fi
	fi;
	if f.last.classname = clname #! last may not exist#
	then	if inhertab[fieldname] ~= undefined
		then	f.redeffld(fdes);
			inhertab[fieldname] := undefined;
		else	ermsg('"' || fieldname || '" redeclared', lnr)
		fi;
		return(False)
	else	f.add(fdes);
		return(True)
	fi
);
	# Enters 'name' into 'fieldtab' with given initial values. If a #
	# forward declaration for this name is found in symtab it is	#
	# removed. See also FIELD_DECL.					#

proc concat(a, b)
( var x;
  for x in b do a.append(x) od;
  return(a)
);
	# Destructively concatenate two arrays				#

proc remove(names)
(	var nm;

	for nm in names do symtab[nm] := symtab[nm][S_NEXT] od;
);

	# 'remove' resets the symbol table entries for the names in	#
	# its argument to their previous values. The names declared at	#
	# each level are explicitly remembered and passed as an argu-	#
	# ment instead of simply resetting all entries on the current	#
	# level, as this would require constructing the set of keys and	#
	# scanning the complete symbol table on each block exit; both	#
	# are expensive operations.					#

proc checktype(ident)
(	var entry := symtab[ident], r;

	if entry = undefined
	then	if (r := fieldtab[ident]) = undefined
		then	symentry(ident, 0, r := FORWARD(ident, lnr))
		fi;
		return(r)
	else	return(entry[S_VALUE])
	fi
);
	# Ensure that, if an identifier is neither entered		#
	# neither in 'symtab' nor in 'fieldtab', it is put in 'symtab'	#
	# with type indication 'forward' followed by the current line	#
	# number. If the same identifier is encountered later on without#
	# intermediate declaration, its entry in symtab matches lit('f')#

#********** Procedures associated with the treatment of classes *********#

proc putopassoc(opname)
(	var mon := opname || '.1',
	    dy  := opname || '.2',
	    monentry := fieldtab[mon],
	    dyentry  := fieldtab[dy],
	    undef := 0;

	if monentry ~= undefined & monentry.last.classname = clname
	then	monentry.last.ffetch := monentry.last.intern
	else	undef := undef+1
	fi;
	if dyentry ~= undefined & dyentry.last.classname = clname
	then	dyentry.last.ffetch := dyentry.last.intern
	else	undef := undef+1
	fi;
	if undef = 2
	then	ermsg('field "' || opname || '" undefined', lnr)
	fi
);
	# Puts fetch associations for an operator field in 'fieldtab'.	#
	# When, say, a declaration 'fetch @' is encountered, an entry	#
	# in 'fetchtab' is made with key '@' and value '_s'. A monadic	#
	# (dyadic) operator '@' declared within that class is entered	#
	# in 'fieldtab' with key '@.1' ('@.2'). 'Putopassoc' checks	#
	# whether the fetch association is indeed '_s' (the only one	#
	# allowed) and whether at least one version of @ is defined 	#
	# within the class, and adds the fetch association(s).	 	#

proc putassocs(type)
(	var field, fld, fstab, fetching, assoc;

	if type = fetch_type
	then	fstab := fetchtab; fetching := True
	else	fstab := storetab; fetching := False
	fi;
	for field in fstab.index
	do assoc := fstab[field];
	   if assoc ~= '_s'
	   then	fld := fieldtab[assoc];
		if fld = undefined | fld.last.classname ~= clname
	        then	ermsg('fetch/store association "'
			      || assoc || '" undeclared', lnr)
		elif fld.last.ftype ~= PROC
		then	ermsg('fetch/store association "'
			      || assoc || '" is not a procedure', lnr)
		fi
	   fi;
	   if montab[field] ~= undefined | dytab[field] ~= undefined
	   then if type = fetch_type & assoc = '_s'
		then putopassoc(field)
		else ermsg('illegal ' || type ||
			   ' association for "' || field || '"', lnr)
		fi
	   else	var entry;

		entry := fieldtab[field];
		if entry = undefined | entry.last.classname ~= clname
		then ermsg('field "' || field || '" undeclared', lnr)
		elif entry.last.ftype = PROC
		then if type = fetch_type & assoc = '_s'
		     then entry.last.ffetch := entry.last.intern
		     else ermsg('illegal ' || type ||
				' association for "' || field || '"', lnr)
		     fi
		else	if fetching = True then
			   entry.last.ffetch
			else
			   entry.last.fstore
			fi :=
			  if assoc = '_s'
			  then SIMPLE else fieldtab[assoc].last.intern
			  fi
		fi
	   fi
	od
);
	# Sets fetch or store associations for fields of the current	#
	# class, using the entries from 'fetchtab' or 'storetab'	#
	# (depending on the value of 'type').				#
	# 'putassocs' has to distinguish between operators, procedures	#
	# and data fields. For operators 'putopassoc' is called.	#
	# Procedures cannot have a store association. The only value	#
	# allowed for the fetch association in 'fetchtab' is '_s', but	#
	# the entry in 'fieldtab' will be the name of the procedure with#
	# the class suffix appended. Data fields can have both a fetch	#
	# and a store association; both can have value '~simple' or an	#
	# name of an associated procedure. 'putassocs' also check	#
	# whether all fields mentioned in 'fetch' and 'store' declara-	#
	# tions are indeed declared in the current class.		#
	# 'putopassoc' is called), procedures (which cannot have a store#
	# association and for which the only fetch association allowed	#


proc do_subclass(super)
(	var cl_super;

	if (cl_super := classtab[super]) = undefined
	then ermsg('"' || super || '" not (yet) defined as class', lnr)
	else var i, fldlist, fld, sub_entry, super_entry, nosubset := False;

	     fldlist := cl_super[1];		# parameters #
	     for i in fldlist.index
	     do	if i >= par_flds.size | par_flds[i] ~= fldlist[i]
		 then nosubset := True
		 fi;
	     od;
	     if nosubset = True
	     then ermsg('parameters of "' || clname ||
			'" should include those of "' || super || '"', lnr)
	     else for fld in fldlist
		  do sub_entry := fieldtab[fld].last;
		     super_entry := fieldtab[fld].locate_fld(super);
		     sub_entry.ffetch := super_entry.ffetch;
		     sub_entry.fstore := super_entry.fstore;
		  od
	     fi;
	     for fld in cl_super[2]		# data fields #
	     do super_entry := fieldtab[fld].locate_fld(super);
	        fieldentry(fld, clname, VAR, offset := offset + 1,
			   super_entry.ffetch, super_entry.fstore);
		data_flds.append(fld);
		symentry(fld, level, VARIABLE(fld, ClassVar));
		inhertab[fld] := 1;
	     od;
	     for fld in cl_super[3]		# procedures #
	     do super_entry := fieldtab[fld].locate_fld(super);
	        fieldentry(fld, clname, PROC, super_entry.intern,
			   super_entry.ffetch, NOSTORE);
		proc_flds.append(fld);
		symentry(fld, level, super_entry.intern);
		inhertab[fld] := 1;
	     od;
	     for fld in cl_super[4]		# operators #
	     do super_entry := fieldtab[fld].locate_fld(super);
	        fieldentry(fld, clname, PROC, super_entry.intern,
			   super_entry.ffetch, NOSTORE);
	        op_flds.append(fld);
		inhertab[fld] := 1
	     od
	fi
);
	# All fieldtable entries of the superclass are copied. Parameters #
	# have been entered already; only the fetch and store associations#
	# are changed. They may not be redefined. For all other fields a  # 
	# new entry is created; and they are entered in inhertab to       #
	# denote that they may be redefined.				  #
	# Offsets: if A(a) with datafields x and y is the superclass of	  #
	# B(a,b,c) then after 'do_subclass' B has five datafields:	  #
	# 'a' (offset 0), 'b' (1), 'c' (2), 'x' (3) and 'y' (4).	  #



#****************** Miscellaneous procedures *****************************#


proc check_forward_references()
( var nm, e, ent;

  for nm in montab.index
  do if (e := montab[nm][O_STATUS]) < 0 then
	ermsg('undeclared monadic operator "' || nm || '"', -e)
     fi
  od;
  for nm in dytab.index
  do if (e := dytab[nm][O_STATUS]) < 0 then
	ermsg('undeclared dyadic operator "' || nm || '"', -e)
     fi
  od;
  for ent in symtab
  do var x := ent[S_VALUE];
     if x.kind = Forward then
	var f := x.src_file;
	f := if f ~= src.name then '(on file: "' || f || '") ' else '' fi;
	ermsg(f || '"' || x.name || '" undeclared', x.lino)
     fi
  od;
);

proc comermsg(m)
(	put(string(lnr).right(5, ' '), ': compiler error; ', m, newl);
	stop(-1)
);

proc ermsg(message, lnr)
(	if src.errors = 0
	then	f_er.put(newl, 'errors in ', src.name, ':', newl);
		src.errors := 1;
	fi;
	f_er.put(string(lnr).right(5, ' ') , ': ', message, newl);
	errcnt := errcnt + 1;
);

proc cant(name)
(	put('Cannot open ', name, '\n');
	stop(1);
);

#********** low-level assembly language generation procedures *************#

var	clab	:= labelgenerator('CS'),
		# labels generated in case statements #
	f_s,	# assembler output file #
	nrc	:= 0,
		# try statement (recovery cache) nesting level #
	nsubj	:= 0,
		# scan statement (subject) nesting level #
	flstack := array(30,''),
	flstp	:= -1;
		# fail label stack and stackpointer #

		# Following vars and constants determine the dimensions	#
		# of assembler output.					#
var	linesize:= 0,
	opsep	:= '.byte ',
	n256	:= 256;
const	opsize0 := 5,
	opsize1 := 9,
	opsize2 := 13,
	linemax := 100;

proc lineflush()
( if linesize > 0 then
     f_s.put(newl);
     opsep := '.byte ';
     linesize := 0
  fi
);

proc dec(n) return(string(n));

proc exp_op0(opc)
( if linesize > linemax then lineflush() fi;
  f_s.put(opsep, opc);
  linesize := linesize + opsize1;
  opsep := sc
);

proc exp_op1(opc, arg)
  if 0 <= arg < n256 then
     if linesize > linemax then lineflush() fi;
     f_s.put(opsep, opc, sc, dec(arg));
     linesize := linesize + opsize2;
     opsep := sc
  else
     f_s.put(opsep, 'x' || opc);
     linesize := linesize + opsize1;
     lineflush();
     f_s.put('.long ', dec(arg), newl)
  fi;

proc exp_op2(opc, arg1, arg2)
  if 0 <= arg1 < n256 then
     if linesize > linemax then lineflush() fi;
     f_s.put(opsep, opc, sc, dec(arg1), sc, dec(arg2));
     linesize := linesize + opsize2;
     opsep := sc
  else
     f_s.put(opsep,  'x' || opc);
     linesize := linesize + opsize0;
     lineflush();
     f_s.put('.long ', dec (arg1), newl);
     f_s.put(opsep, arg2);
     linesize := linesize + opsize0;
     opsep := sc;
  fi;

proc exp_opw1(opc, arg)
( f_s.put(opsep, opc);
  linesize := linesize + opsize1;
  lineflush();
  f_s.put('.long ', arg, newl)
);

proc declstring(s)
( if s.size > 0 & stringtab[s] = undefined then
     stringtab[s] := slab.next
  fi;
  return(stringtab[s])
);

proc declstrings()
(	var lab, str, i, sep;
	const linemax := 40;

	if errcnt ~= 0 then return fi;
	for str in stringtab.index
	do lab := stringtab[str];
	   f_s.put(lab, ':\n',
	   	   long, 'dt_string', newl,
          	   long, dec(str.size));
	   if str.size < 80 & ~scan str for break(NON_STANDARD_CHARS) rof
	   then
	      f_s.put(newl, '.ascii "', str, '"')
	   else
	      for i in str.index
	      do if i % linemax * linemax = i then
           	    f_s.put(newl, '.byte ');
	   	    sep := ''
        	 fi;
                 f_s.put(sep, char_to_int[str[i]]);
        	 sep := sc
     	      od;
   	   fi;
   	   f_s.put(newl)
	od;
);

proc exp_real(realval)
( exp_op0('undef'); exp_op0('load');
  lineflush();
  f_s.put('.long ', declstring(string(realval)), newl);
  exp_op2('call', symtab['real'][S_VALUE].seq, 2);
);

proc exp_classes()
( var cname, s, sizes := array(nclasses, 0), names := array(nclasses, '');

  f_s.put('.globl _class_sizes\n',
          '_class_sizes:\n');
  for cname in classtab.index
  do var descr := classtab[cname];
     sizes[descr[5]] := descr[0];
     names[descr[5]] := cname;
  od;
  for s in sizes do f_s.put(long, s, newl) od;
  f_s.put('.globl _class_names\n',
          '_class_names:\n');
  for cname in names
  do f_s.put(long, '\t', declstring(cname), newl);
  od;
);


proc exp_fields()
( var fld, n;

  for fld in fieldtab do fld.generate od;

  f_s.put('.globl _fields', newl);
  f_s.put('_fields:', newl);
  for n in interval(0, nfields - 1, 1) do f_s.put(long, '\tFLD', n, newl) od;
);

proc exp_terminate()
( var i, nm,
      globval := array(glcnt, 0),
      globname:= array(glcnt, 0);
  if errcnt ~= 0 then return fi;
  f_s.put('.globl _nclasses; _nclasses:', newl,
	long, dec(nclasses), newl,
	'.globl _nfields; _nfields:', long, dec(nfields), newl,
	'.globl _globals', newl,
	'.globl _eglobals', newl,
	'.globl _globnames', newl,
	'.globl _stand_in', newl,
	'.globl _stand_out', newl,
	'.globl _stand_er', newl);
  for nm in symtab.index
  do var entry := symtab[nm][S_VALUE], pre;
     if entry.isglobal then
	case nm of
	'stand_in':
	'stand_out':
	'stand_er':
		pre := '_' || nm || ':'
	default:
		pre := ''
	esac;
        globval[entry.seq] := pre || long ||
	   if entry.kind = GlobalVar then 'nil' else entry.tag fi;
	globname[entry.seq] := nm;
	if entry.kind = Class then
	   var p;
	   for p in entry.procs
	   do globval[p.seq] := long || p.tag;
	      globname[p.seq] := p.name;
	   od;
	elif entry.kind = BuiltinProc | entry.kind = BuiltinClass then
	   var refname := '__' || entry.name;
	   f_s.put(entry.tag, ':', newl);
	   f_s.put(long, 'dt_subr', newl);
	   f_s.put(long, if entry.kind = BuiltinClass then -1 else 'nil' fi, newl);
	   f_s.put('\t.globl\t', refname, newl,
		   long, refname, newl,
		   long, dec(0), newl,		# freq #
		   long, dec(0), newl);		# prof #
	fi
     fi;
  od;
  f_s.put('_globals:\n');
  for i in globval do f_s.put(i, newl) od;
  f_s.put('_eglobals:\n',
          '_globnames:\n');
  for i in globname.index
  do 
     f_s.put(long, declstring(globname[i]), newl)
  od;
  declstrings();
);

proc inspect(rval, expr)
(	if rval = Value
	then	ermsg(expr || ': value required', lnr)
	elif rval = Assign
	then	ermsg('illegal assignment to ' || expr, lnr)
	fi
);

proc void(aval)
(	if aval ~= Novalue
	then	exp_op0('void')
	fi
);

proc voidcall(rval)
(	if rval = Novalue
	then	exp_op0('void')
	fi
);

proc abs(rval)
	return(if rval < 0 then -rval else rval fi);

var flab	:= labelgenerator('F');

var llab	:= labelgenerator('L');

proc label(l)	(lineflush(); f_s.put(l, ':'));

proc gofl()	exp_op0('gofl');

proc newrc()	exp_op0('newrc');

proc oldrc()	exp_op0('oldrc');

proc resrc()	exp_op0('resrc');

proc close_rc()
( var i;
  for i in interval(1, nrc, 1) do exp_op0('oldrc') od;
);

proc newsubj()	exp_op0('newsubj');

proc oldsubj()	exp_op0('oldsubj');

proc close_subj()
( var i;
  for i in interval(1, nsubj, 1) do exp_op0('oldsubj') od;
);

proc go(l)	exp_opw1('go', l);

proc retu(n)
( close_rc();
  close_subj();
  exp_op1('return', n);
);

proc fretu()
( close_rc();
  close_subj();
  exp_op0('freturn');
);

proc ercode(c)
( exp_op0('error');
  exp_op0('er_' || c)
);

proc pushfl(f)
if errcnt = 0
then	flstack[flstp := flstp + 1] := f
fi;

proc popfl()
if errcnt = 0
then	if flstp < 0
	then	comermsg('pop tried from empty flstack')
	else	flstack[flstp] := '';
		flstp := flstp - 1
	fi
fi;

proc newfl(f)
if errcnt = 0
then	if flstp = -1 | ~(flstack[flstp] = f = NIL)
	then	exp_opw1('newfl', f)
	fi;
	pushfl(f)
fi;

proc oldfl()
if errcnt = 0
then	if flstp <= 0 | ~(flstack[flstp] = flstack[flstp-1] = NIL)
	then	exp_op0('oldfl')
	fi;
	popfl()
fi;
# end of parser.ud #
	var
	 	keytab := table(20,undefined) init [
		'assert' : 0,
		'begin' : 1,
		'case' : 2,
		'class' : 3,
		'const' : 4,
		'default' : 5,
		'do' : 6,
		'dyadic' : 7,
		'elif' : 8,
		'else' : 9,
		'end' : 10,
		'esac' : 11,
		'fails' : 12,
		'fetch' : 13,
		'fi' : 14,
		'for' : 15,
		'freturn' : 16,
		'if' : 17,
		'in' : 18,
		'include' : 19,
		'monadic' : 20,
		'od' : 21,
		'of' : 22,
		'op' : 23,
		'proc' : 24,
		'program' : 25,
		'return' : 26,
		'rof' : 27,
		'scan' : 28,
		'self' : 29,
		'store' : 30,
		'subclass' : 31,
		'subject' : 32,
		'succeeds' : 33,
		'table' : 34,
		'then' : 35,
		'try' : 36,
		'undefined' : 37,
		'until' : 38,
		'var' : 39,
		'while' : 40,
		'yrt' : 41,
		'array' : 42
	],


	kartab := table(20,undefined) init [
		')' : 43,
		',' : 44,
		'.' : 45,
		':' : 46,
		';' : 47,
		'[' : 48,
		']' : 49,
		'eof_include' : 50,
		'init' : 51,
		'('  : 52
	],


	predef := table(10,undefined) init [
		'identifier' : 53,
		'integer_constant' : 54,
		'operator_symbol' : 55,
		'real_constant' : 56,
		'string_constant' : 57,
		'EOF' : 58
	],



	SETSIZE := 59,
	f_actuals_0_1 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_array_expression_0_1 := SET([52,48]),
	f_array_or_table_initialization_0_1_1_1_2_2_0_1 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_array_or_table_initialization_0_1_1_1 := SET([44,46,49]),
	f_array_or_table_initialization_0_1_1 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_array_or_table_initialization_0_1 := SET([52,48,49,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_block_0_0 := SET([4,39]),
	f_block_0_1_0_0 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_block_0_1 := SET([52,47,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_block := SET([52,47,48,42,0,2,4,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,39,40]),
	f_case_entry := SET([52,46,47,48,42,0,2,4,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,39,40]),
	f_case_expression_0_3_0_0_0 := SET([52,46,47,48,42,0,2,4,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,39,40]),
	f_case_expression_0_3_0_0_1 := SET([]),
	f_case_expression_0_3_0_0 := SET([52,46,47,48,42,0,2,4,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,39,40]),
	f_case_expression_0_3 := SET([52,44,46,47,48,42,0,2,4,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,39,40]),
	f_case_expression_0_4_1 := SET([]),
	f_class_declaration_0_7 := SET([4,23,24,39]),
	f_class_declaration_0_8_1 := SET([]),
	f_constant := SET([54,56,57,37]),
	f_empty := SET([]),
	f_expression := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_expression_list := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_fetch_associations_0_0_0_1_0_0_0_0 := SET([53,55]),
	f_fetch_associations_0_0_0_1_0_0_0_1_1 := SET([]),
	f_fetch_associations_0_0_0_1_0_0 := SET([53,55]),
	f_fetch_associations_0_0_0_1 := SET([53,55]),
	f_global_operator_declaration_0_3_0 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_global_operator_declaration_0_3_1 := SET([]),
	f_global_operator_declaration_0_3 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_global_procedure_declaration_0_3_0 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_global_procedure_declaration_0_3_1 := SET([]),
	f_global_procedure_declaration_0_3 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_if_body_0_3_2 := SET([]),
	f_if_body_0_3 := SET([8,9]),
	f_if_body := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_local_initialization_0_1_1 := SET([]),
	f_monadic_expression := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_operator_field_declaration_0_3_0 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_operator_field_declaration_0_3_1 := SET([]),
	f_operator_field_declaration_0_3 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_primary_0_1 := SET([45,48]),
	f_primary := SET([52,48,42,0,2,15,16,53,17,54,56,26,28,29,57,32,34,36,37,40]),
	f_procedure_field_declaration_0_3_0 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_procedure_field_declaration_0_3_1 := SET([]),
	f_procedure_field_declaration_0_3 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_program_declaration_0_3_0 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_program_declaration_0_3_1 := SET([]),
	f_program_declaration_0_3 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_return_expression_0_1_0_1_0 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_return_expression_0_1_0_1_1 := SET([]),
	f_return_expression_0_1_0_1 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_return_expression_0_1_1 := SET([]),
	f_return_expression := SET([16,26]),
	f_store_associations_0_0_0_1_0_0_0_0 := SET([53,55]),
	f_store_associations_0_0_0_1_0_0_0_1_1 := SET([]),
	f_store_associations_0_0_0_1_0_0 := SET([53,55]),
	f_store_associations_0_0_0_1 := SET([53,55]),
	f_summer_program := SET([3,4,7,50,19,20,23,24,25,39]),
	f_table_element := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_table_element_tail := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_table_expression_0_1 := SET([52,48]),
	f_table_initialization_0_1 := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_test_0_1 := SET([12,33]),
	f_test := SET([52,48,42,0,2,15,16,53,17,54,55,56,26,28,29,57,32,34,36,37,40]),
	f_try_expression_0_2_1 := SET([]),
	f_unit_0 := SET([54,56,57,37]),
	f_unit_10 := SET([16,26]),
	f_unit := SET([52,48,42,0,2,15,16,53,17,54,56,26,28,29,57,32,34,36,37,40]),
	s_0 := SET([0]),
	s_1 := SET([1]),
	s_2 := SET([2]),
	s_3 := SET([3]),
	s_4 := SET([4]),
	s_5 := SET([5]),
	s_6 := SET([6]),
	s_7 := SET([7]),
	s_8 := SET([8]),
	s_9 := SET([9]),
	s_10 := SET([10]),
	s_11 := SET([11]),
	s_12 := SET([12]),
	s_13 := SET([13]),
	s_14 := SET([14]),
	s_15 := SET([15]),
	s_16 := SET([16]),
	s_17 := SET([17]),
	s_18 := SET([18]),
	s_19 := SET([19]),
	s_20 := SET([20]),
	s_21 := SET([21]),
	s_22 := SET([22]),
	s_23 := SET([23]),
	s_24 := SET([24]),
	s_25 := SET([25]),
	s_26 := SET([26]),
	s_27 := SET([27]),
	s_28 := SET([28]),
	s_29 := SET([29]),
	s_30 := SET([30]),
	s_31 := SET([31]),
	s_32 := SET([32]),
	s_33 := SET([33]),
	s_34 := SET([34]),
	s_35 := SET([35]),
	s_36 := SET([36]),
	s_37 := SET([37]),
	s_38 := SET([38]),
	s_39 := SET([39]),
	s_40 := SET([40]),
	s_41 := SET([41]),
	s_42 := SET([42]),
	s_43 := SET([43]),
	s_44 := SET([44]),
	s_45 := SET([45]),
	s_46 := SET([46]),
	s_47 := SET([47]),
	s_48 := SET([48]),
	s_49 := SET([49]),
	s_50 := SET([50]),
	s_51 := SET([51]),
	s_52 := SET([52]),
	s_53 := SET([53]),
	s_54 := SET([54]),
	s_55 := SET([55]),
	s_56 := SET([56]),
	s_57 := SET([57]),
	s_58 := SET([58]),
	EMPTY := SET([]),
	r_actuals_0_1 := s_43,
	r_actuals_0_0 := UN2(f_actuals_0_1,r_actuals_0_1),
	r_actuals_0_1_0_0 := r_actuals_0_1,
	r_array_expression_0_0 := f_array_expression_0_1,
	r_array_expression_0_1_0_0 := s_51,
	r_array_expression_0_1_0_1_0_0 := s_48,
	r_array_initialization_0_1 := s_49,
	r_array_initialization_0_0 := UN2(f_expression_list,r_array_initialization_0_1),
	r_array_or_table_initialization_0_0 := f_array_or_table_initialization_0_1,
	r_array_or_table_initialization_0_1_1_0 := f_array_or_table_initialization_0_1_1_1,
	r_array_or_table_initialization_0_1_1_1_1_1 := s_49,
	r_array_or_table_initialization_0_1_1_1_1_0 := UN2(f_expression_list,r_array_or_table_initialization_0_1_1_1_1_1),
	r_array_or_table_initialization_0_1_1_1_2_2 := s_49,
	r_array_or_table_initialization_0_1_1_1_2_1 := UN2(s_44,r_array_or_table_initialization_0_1_1_1_2_2),
	r_array_or_table_initialization_0_1_1_1_2_0 := UN2(f_table_element_tail,r_array_or_table_initialization_0_1_1_1_2_1),
	r_array_or_table_initialization_0_1_1_1_2_2_0_1 := UN2(r_array_or_table_initialization_0_1_1_1_2_2,f_array_or_table_initialization_0_1_1_1_2_2_0_1),
	r_array_or_table_initialization_0_1_1_1_2_2_0_0 := UN2(f_array_or_table_initialization_0_1_1_1_2_2_0_1,r_array_or_table_initialization_0_1_1_1_2_2_0_1),
	r_array_or_table_initialization_0_1_1_1_2_2_0_1_0_1 := r_array_or_table_initialization_0_1_1_1_2_2_0_1,
	r_array_or_table_initialization_0_1_1_1_2_2_0_1_0_0 := UN2(s_44,r_array_or_table_initialization_0_1_1_1_2_2_0_1_0_1),
	r_assert_expression_0_0 := f_expression,
	r_block_0_1 := f_block_0_1,
	r_block_0_0 := UN3(f_block_0_1,r_block_0_1,f_block_0_0),
	r_block_0_0_0_0 := r_block_0_0,
	r_block_0_0_1_0 := r_block_0_0,
	r_block_0_1_0_1 := r_block_0_1,
	r_block_0_1_0_0 := UN2(s_47,r_block_0_1_0_1),
	r_block_0_1_0_0_0_0 := r_block_0_1_0_0,
	r_case_entry_0_1 := s_46,
	r_case_entry_0_0 := UN2(s_46,r_case_entry_0_1),
	r_case_entry_0_1_0_1 := r_case_entry_0_1,
	r_case_entry_0_1_0_0 := UN2(f_block,r_case_entry_0_1_0_1),
	r_case_expression_0_4 := s_11,
	r_case_expression_0_3 := UN3(s_5,r_case_expression_0_4,f_case_expression_0_3),
	r_case_expression_0_2 := UN2(f_case_expression_0_3,r_case_expression_0_3),
	r_case_expression_0_1 := UN2(s_22,r_case_expression_0_2),
	r_case_expression_0_0 := UN2(f_expression,r_case_expression_0_1),
	r_case_expression_0_3_0_1 := r_case_expression_0_3,
	r_case_expression_0_3_0_0 := UN2(s_44,r_case_expression_0_3_0_1),
	r_case_expression_0_3_0_0_0_0 := r_case_expression_0_3_0_0,
	r_case_expression_0_3_0_0_1_0 := r_case_expression_0_3_0_0,
	r_case_expression_0_4_0_2 := r_case_expression_0_4,
	r_case_expression_0_4_0_1 := UN2(f_block,r_case_expression_0_4_0_2),
	r_case_expression_0_4_0_0 := UN2(s_46,r_case_expression_0_4_0_1),
	r_case_expression_0_4_1_0 := r_case_expression_0_4,
	r_class_declaration_0_10 := s_47,
	r_class_declaration_0_9 := UN2(s_53,r_class_declaration_0_10),
	r_class_declaration_0_8 := UN2(s_10,r_class_declaration_0_9),
	r_class_declaration_0_7 := UN3(s_51,r_class_declaration_0_8,f_class_declaration_0_7),
	r_class_declaration_0_6 := UN2(f_class_declaration_0_7,r_class_declaration_0_7),
	r_class_declaration_0_5 := UN2(s_30,r_class_declaration_0_6),
	r_class_declaration_0_4 := UN2(s_13,r_class_declaration_0_5),
	r_class_declaration_0_3 := UN2(s_31,r_class_declaration_0_4),
	r_class_declaration_0_2 := UN2(s_1,r_class_declaration_0_3),
	r_class_declaration_0_1 := UN2(s_52,r_class_declaration_0_2),
	r_class_declaration_0_0 := UN2(s_53,r_class_declaration_0_1),
	r_class_declaration_0_7_0_0 := r_class_declaration_0_7,
	r_class_declaration_0_7_1_0 := r_class_declaration_0_7,
	r_class_declaration_0_7_2_0 := r_class_declaration_0_7,
	r_class_declaration_0_7_3_0 := r_class_declaration_0_7,
	r_class_declaration_0_8_0_2 := r_class_declaration_0_8,
	r_class_declaration_0_8_0_1 := UN2(f_block,r_class_declaration_0_8_0_2),
	r_class_declaration_0_8_0_0 := UN2(s_46,r_class_declaration_0_8_0_1),
	r_class_declaration_0_8_1_0 := r_class_declaration_0_8,
	r_constant_declaration_0_1 := UN2(s_47,s_53),
	r_constant_declaration_0_0 := UN2(s_53,r_constant_declaration_0_1),
	r_constant_declaration_0_1_0_1 := r_constant_declaration_0_1,
	r_constant_declaration_0_1_0_0 := UN2(s_44,r_constant_declaration_0_1_0_1),
	r_constant_initialization_0_1 := f_expression,
	r_constant_initialization_0_0 := UN2(s_55,r_constant_initialization_0_1),
	r_data_field_declaration_0_1 := UN2(s_47,s_53),
	r_data_field_declaration_0_0 := UN2(s_53,r_data_field_declaration_0_1),
	r_data_field_declaration_0_1_0_1 := r_data_field_declaration_0_1,
	r_data_field_declaration_0_1_0_0 := UN2(s_44,r_data_field_declaration_0_1_0_1),
	r_dyadic_symbol_declaration_0_1 := UN2(s_47,s_55),
	r_dyadic_symbol_declaration_0_0 := UN2(s_55,r_dyadic_symbol_declaration_0_1),
	r_dyadic_symbol_declaration_0_1_0_1 := r_dyadic_symbol_declaration_0_1,
	r_dyadic_symbol_declaration_0_1_0_0 := UN2(s_44,r_dyadic_symbol_declaration_0_1_0_1),
	r_expression_0_1 := s_55,
	r_expression_0_0 := UN2(s_55,r_expression_0_1),
	r_expression_0_1_0_1 := r_expression_0_1,
	r_expression_0_1_0_0 := UN2(f_monadic_expression,r_expression_0_1_0_1),
	r_expression_list_0_0 := f_expression_list,
	r_expression_list_0_0_0_1 := r_expression_list_0_0,
	r_expression_list_0_0_0_0 := UN2(s_44,r_expression_list_0_0_0_1),
	r_fetch_associations_0_0_0_1 := UN2(s_47,f_fetch_associations_0_0_0_1),
	r_fetch_associations_0_0_0_0 := UN2(f_fetch_associations_0_0_0_1,r_fetch_associations_0_0_0_1),
	r_fetch_associations_0_0_0_1_0_1 := r_fetch_associations_0_0_0_1,
	r_fetch_associations_0_0_0_1_0_0 := UN2(s_44,r_fetch_associations_0_0_0_1_0_1),
	r_fetch_associations_0_0_0_1_0_0_0_1 := r_fetch_associations_0_0_0_1_0_0,
	r_fetch_associations_0_0_0_1_0_0_0_0 := UN2(s_46,r_fetch_associations_0_0_0_1_0_0_0_1),
	r_fetch_associations_0_0_0_1_0_0_0_0_0_0 := r_fetch_associations_0_0_0_1_0_0_0_0,
	r_fetch_associations_0_0_0_1_0_0_0_0_1_0 := r_fetch_associations_0_0_0_1_0_0_0_0,
	r_fetch_associations_0_0_0_1_0_0_0_1_0_1 := r_fetch_associations_0_0_0_1_0_0_0_1,
	r_fetch_associations_0_0_0_1_0_0_0_1_0_0 := UN2(s_53,r_fetch_associations_0_0_0_1_0_0_0_1_0_1),
	r_fetch_associations_0_0_0_1_0_0_0_1_1_0 := r_fetch_associations_0_0_0_1_0_0_0_1,
	r_field_initialization_0_0 := s_55,
	r_field_initialization_0_1_0_0 := f_expression,
	r_for_expression_0_5 := s_21,
	r_for_expression_0_4 := UN2(f_block,r_for_expression_0_5),
	r_for_expression_0_3 := UN2(s_6,r_for_expression_0_4),
	r_for_expression_0_2 := UN2(f_expression,r_for_expression_0_3),
	r_for_expression_0_1 := UN2(s_18,r_for_expression_0_2),
	r_for_expression_0_0 := UN2(s_53,r_for_expression_0_1),
	r_formals_of_class_0_1 := UN2(s_43,s_53),
	r_formals_of_class_0_0 := UN2(s_53,r_formals_of_class_0_1),
	r_formals_of_class_0_1_0_1 := r_formals_of_class_0_1,
	r_formals_of_class_0_1_0_0 := UN2(s_44,r_formals_of_class_0_1_0_1),
	r_formals_of_procedure_0_1 := UN2(s_43,s_53),
	r_formals_of_procedure_0_0 := UN2(s_53,r_formals_of_procedure_0_1),
	r_formals_of_procedure_0_1_0_1 := r_formals_of_procedure_0_1,
	r_formals_of_procedure_0_1_0_0 := UN2(s_44,r_formals_of_procedure_0_1_0_1),
	r_global_initialization_0_0 := s_55,
	r_global_initialization_0_1_0_0 := f_expression,
	r_global_operator_declaration_0_3 := s_47,
	r_global_operator_declaration_0_2 := UN2(f_global_operator_declaration_0_3,r_global_operator_declaration_0_3),
	r_global_operator_declaration_0_1 := UN2(s_52,r_global_operator_declaration_0_2),
	r_global_operator_declaration_0_0 := UN2(s_55,r_global_operator_declaration_0_1),
	r_global_operator_declaration_0_3_0_0 := r_global_operator_declaration_0_3,
	r_global_operator_declaration_0_3_1_0 := r_global_operator_declaration_0_3,
	r_global_procedure_declaration_0_3 := s_47,
	r_global_procedure_declaration_0_2 := UN2(f_global_procedure_declaration_0_3,r_global_procedure_declaration_0_3),
	r_global_procedure_declaration_0_1 := UN2(s_52,r_global_procedure_declaration_0_2),
	r_global_procedure_declaration_0_0 := UN2(s_53,r_global_procedure_declaration_0_1),
	r_global_procedure_declaration_0_3_0_0 := r_global_procedure_declaration_0_3,
	r_global_procedure_declaration_0_3_1_0 := r_global_procedure_declaration_0_3,
	r_global_variable_declaration_0_1 := UN2(s_47,s_53),
	r_global_variable_declaration_0_0 := UN2(s_53,r_global_variable_declaration_0_1),
	r_global_variable_declaration_0_1_0_1 := r_global_variable_declaration_0_1,
	r_global_variable_declaration_0_1_0_0 := UN2(s_44,r_global_variable_declaration_0_1_0_1),
	r_identifier_or_call_0_0 := s_52,
	r_if_body_0_2 := f_if_body_0_3,
	r_if_body_0_1 := UN2(f_block,r_if_body_0_2),
	r_if_body_0_0 := UN2(s_35,r_if_body_0_1),
	r_if_body_0_3_0_0 := f_if_body,
	r_if_body_0_3_1_0 := f_block,
	r_if_expression_0_1 := s_14,
	r_if_expression_0_0 := UN2(f_if_body,r_if_expression_0_1),
	r_include_file_0_1 := s_47,
	r_include_file_0_0 := UN2(s_57,r_include_file_0_1),
	r_local_initialization_0_0 := s_55,
	r_local_initialization_0_1_0_0 := f_expression,
	r_local_variable_declaration_0_1 := UN2(s_47,s_53),
	r_local_variable_declaration_0_0 := UN2(s_53,r_local_variable_declaration_0_1),
	r_local_variable_declaration_0_1_0_1 := r_local_variable_declaration_0_1,
	r_local_variable_declaration_0_1_0_0 := UN2(s_44,r_local_variable_declaration_0_1_0_1),
	r_monadic_expression_0_0 := UN2(f_primary,s_55),
	r_monadic_symbol_declaration_0_1 := UN2(s_47,s_55),
	r_monadic_symbol_declaration_0_0 := UN2(s_55,r_monadic_symbol_declaration_0_1),
	r_monadic_symbol_declaration_0_1_0_1 := r_monadic_symbol_declaration_0_1,
	r_monadic_symbol_declaration_0_1_0_0 := UN2(s_44,r_monadic_symbol_declaration_0_1_0_1),
	r_operator_field_declaration_0_3 := s_47,
	r_operator_field_declaration_0_2 := UN2(f_operator_field_declaration_0_3,r_operator_field_declaration_0_3),
	r_operator_field_declaration_0_1 := UN2(s_52,r_operator_field_declaration_0_2),
	r_operator_field_declaration_0_0 := UN2(s_55,r_operator_field_declaration_0_1),
	r_operator_field_declaration_0_3_0_0 := r_operator_field_declaration_0_3,
	r_operator_field_declaration_0_3_1_0 := r_operator_field_declaration_0_3,
	r_parenthesized_expression_0_1 := s_43,
	r_parenthesized_expression_0_0 := UN2(f_block,r_parenthesized_expression_0_1),
	r_primary_0_1 := f_primary_0_1,
	r_primary_0_0 := UN2(f_primary_0_1,r_primary_0_1),
	r_primary_0_1_0_0 := r_primary_0_1,
	r_primary_0_1_1_0 := r_primary_0_1,
	r_procedure_field_declaration_0_3 := s_47,
	r_procedure_field_declaration_0_2 := UN2(f_procedure_field_declaration_0_3,r_procedure_field_declaration_0_3),
	r_procedure_field_declaration_0_1 := UN2(s_52,r_procedure_field_declaration_0_2),
	r_procedure_field_declaration_0_0 := UN2(s_53,r_procedure_field_declaration_0_1),
	r_procedure_field_declaration_0_3_0_0 := r_procedure_field_declaration_0_3,
	r_procedure_field_declaration_0_3_1_0 := r_procedure_field_declaration_0_3,
	r_program_declaration_0_3 := s_47,
	r_program_declaration_0_2 := UN2(f_program_declaration_0_3,r_program_declaration_0_3),
	r_program_declaration_0_1 := UN2(s_52,r_program_declaration_0_2),
	r_program_declaration_0_0 := UN2(s_53,r_program_declaration_0_1),
	r_program_declaration_0_3_0_0 := r_program_declaration_0_3,
	r_program_declaration_0_3_1_0 := r_program_declaration_0_3,
	r_return_expression_0_0 := s_52,
	r_return_expression_0_1_0_1 := s_43,
	r_return_expression_0_1_0_0 := UN2(f_return_expression_0_1_0_1,r_return_expression_0_1_0_1),
	r_return_expression_0_1_0_1_0_0 := r_return_expression_0_1_0_1,
	r_return_expression_0_1_0_1_1_0 := r_return_expression_0_1_0_1,
	r_scan_expression_0_3 := s_27,
	r_scan_expression_0_2 := UN2(f_block,r_scan_expression_0_3),
	r_scan_expression_0_1 := UN2(s_15,r_scan_expression_0_2),
	r_scan_expression_0_0 := UN2(f_expression,r_scan_expression_0_1),
	r_select_0_1 := s_52,
	r_select_0_0 := UN2(s_53,r_select_0_1),
	r_size_definition_0_3 := s_43,
	r_size_definition_0_2 := UN2(f_expression,r_size_definition_0_3),
	r_size_definition_0_1 := UN2(s_44,r_size_definition_0_2),
	r_size_definition_0_0 := UN2(f_expression,r_size_definition_0_1),
	r_store_associations_0_0_0_1 := UN2(s_47,f_store_associations_0_0_0_1),
	r_store_associations_0_0_0_0 := UN2(f_store_associations_0_0_0_1,r_store_associations_0_0_0_1),
	r_store_associations_0_0_0_1_0_1 := r_store_associations_0_0_0_1,
	r_store_associations_0_0_0_1_0_0 := UN2(s_44,r_store_associations_0_0_0_1_0_1),
	r_store_associations_0_0_0_1_0_0_0_1 := r_store_associations_0_0_0_1_0_0,
	r_store_associations_0_0_0_1_0_0_0_0 := UN2(s_46,r_store_associations_0_0_0_1_0_0_0_1),
	r_store_associations_0_0_0_1_0_0_0_0_0_0 := r_store_associations_0_0_0_1_0_0_0_0,
	r_store_associations_0_0_0_1_0_0_0_0_1_0 := r_store_associations_0_0_0_1_0_0_0_0,
	r_store_associations_0_0_0_1_0_0_0_1_0_1 := r_store_associations_0_0_0_1_0_0_0_1,
	r_store_associations_0_0_0_1_0_0_0_1_0_0 := UN2(s_53,r_store_associations_0_0_0_1_0_0_0_1_0_1),
	r_store_associations_0_0_0_1_0_0_0_1_1_0 := r_store_associations_0_0_0_1_0_0_0_1,
	r_subclass_declaration_0_0_0_2 := s_47,
	r_subclass_declaration_0_0_0_1 := UN2(s_53,r_subclass_declaration_0_0_0_2),
	r_subclass_declaration_0_0_0_0 := UN2(s_22,r_subclass_declaration_0_0_0_1),
	r_subscript_0_1 := s_49,
	r_subscript_0_0 := UN2(f_expression,r_subscript_0_1),
	r_summer_program_0_0 := f_summer_program,
	r_summer_program_0_0_0_0 := r_summer_program_0_0,
	r_summer_program_0_0_1_0 := r_summer_program_0_0,
	r_summer_program_0_0_2_0 := r_summer_program_0_0,
	r_summer_program_0_0_3_0 := r_summer_program_0_0,
	r_summer_program_0_0_4_0 := r_summer_program_0_0,
	r_summer_program_0_0_5_0 := r_summer_program_0_0,
	r_summer_program_0_0_6_0 := r_summer_program_0_0,
	r_summer_program_0_0_7_0 := r_summer_program_0_0,
	r_summer_program_0_0_8_0 := r_summer_program_0_0,
	r_summer_program_0_0_9_0 := r_summer_program_0_0,
	r_table_element_0_0 := f_table_element,
	r_table_element_0_0_0_1 := r_table_element_0_0,
	r_table_element_0_0_0_0 := UN2(s_46,r_table_element_0_0_0_1),
	r_table_element_tail_0_0 := f_table_element_tail,
	r_table_element_tail_0_0_0_1 := r_table_element_tail_0_0,
	r_table_element_tail_0_0_0_0 := UN2(s_46,r_table_element_tail_0_0_0_1),
	r_table_expression_0_0 := f_table_expression_0_1,
	r_table_expression_0_1_0_0 := s_51,
	r_table_expression_0_1_0_1_0_0 := s_48,
	r_table_initialization_0_1 := UN2(s_49,f_table_initialization_0_1),
	r_table_initialization_0_0 := UN2(f_table_initialization_0_1,r_table_initialization_0_1),
	r_table_initialization_0_1_0_1 := r_table_initialization_0_1,
	r_table_initialization_0_1_0_0 := UN2(s_44,r_table_initialization_0_1_0_1),
	r_test_0_0 := f_test_0_1,
	r_try_expression_0_2 := s_41,
	r_try_expression_0_1 := UN2(s_38,r_try_expression_0_2),
	r_try_expression_0_0 := UN2(f_expression_list,r_try_expression_0_1),
	r_try_expression_0_2_0_1 := r_try_expression_0_2,
	r_try_expression_0_2_0_0 := UN2(f_block,r_try_expression_0_2_0_1),
	r_try_expression_0_2_1_0 := r_try_expression_0_2,
	r_while_expression_0_3 := s_21,
	r_while_expression_0_2 := UN2(f_block,r_while_expression_0_3),
	r_while_expression_0_1 := UN2(s_6,r_while_expression_0_2),
	r_while_expression_0_0 := UN2(f_test,r_while_expression_0_1);

#*************************************************************************#
#**									**#
#**			SUMMER COMPILER					**#
#**									**#
#** This is a compiler for the SUMMER programming language as described **#
#** in:									**#
#**	Klint, P., An overview of the SUMMER programming language,	**#
#**	Conference Record of the 7th Annual ACM Symposium on		**#
#**	Principles of Programming Languages, ACM, 1980, 47-55.		**#
#** or:									**#
#**	Klint, P., From SPRING to SUMMER: Design, definition and	**#
#**	implementation of programming languages for string manipulation **#
#**	and pattern matching, (dissertation), Amsterdam, 1982.		**#
#**									**#
#** The compiler uses the parsergenerator "pgen" as described in	**#
#**	Florijn, G. & Rolf, G.,						**#
#**	Pgen - a general purpose parser generator,			**#
#**	Mathematical Centre Report IW 157/81.				**#
#**									**#
#** The compiler consists of three parts:				**#
#**	1. (file: "parser.ns"): lexical scanner.			**#
#**	2. (file: "parser.syn"): grammar + actions.			**#
#**	3. (file: "parser.ud"): symboltable routines, codegeneration.	**#
#**									**#
#*************************************************************************#
#**                                                                  	**#
#** 	SUMMER COMPILER PART I:  lexical scanner			**#
#**                                                                  	**#
#** This file contains procedures which form a lexical scanner	     	**#
#** for SUMMER. The following variables/procedures/constants are	**#
#** (pre)defined by the	parser generator:				**#
#**									**#
#**		line:		current line,				**#
#**		lnr:		current line number,			**#
#**		ermsg:		produces error messages,		**#
#**		errcnt:		number of errors in source,		**#
#**		sy:		current symbol,				**#
#**		t_sy:		current symbol type,			**#
#**		predef:		types of predefined LEXICAL classes,	**#
#**		keytab:		types of keywords,			**#
#**		kartab:		types of "literals" (e.g. ':', ':='),	**#
#**		lower:		lower case letters,			**#
#**		upper:		upper case letters,			**#
#**		digit:		digits,					**#
#**		ASCII:		ordered string of ASCII characters,	**#
#**				the first one is the space.		**#
#**									**#
#** The following variables and constants are defined in parser.ud:	**#
#**		montab:		contains monadic operators,		**#
#**		dytab:		contains dyadic operators,		**#
#**									**#
#*************************************************************************#
#*************************************************************************#

const	alpha		:= 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
	alphanum	:= 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_',
	ops		:= '*+-/:<=>|&~!$%\\@?',
	empty_string	:= '',
	layout		:= ' \t';

var     ascii		:= '\000\001\002\003\004\005\006\007' ||
			   '\010\011\012\013\014\015\016\017' ||
			   '\020\021\022\023\024\025\026\027' ||
			   '\030\031\032\033\034\035\036\037' ||
			   ASCII || '\177';

var	NON_STANDARD_CHARS := ascii.substr(0,31) || '\\' || '"' || '\177';

var	ILLEGAL_CHARS	:= '\000\001\002\003\004\005\006\007' ||
	                               '\013\014'||'\016\017' ||
	    		   '\020\021\022\023\024\025\026\027' ||
	    		   '\030\031\032\033\034\035\036\037' ||
	    		   '\177',
	STOP_CHARS	:= '\\''' || ILLEGAL_CHARS;

var	f_src,
		# File containing the SUMMER source #
	char_to_int;
		# octal conversion table #

var	t_str, t_int, t_real, t_op, t_ident, t_dot, t_lp, t_rp, t_lbr,
	t_rbr, t_comma, t_semi, t_colon, t_EOF, t_EOF_INCLUDE;

proc init_scanner()
(	var i, c;

	t_str	:= predef['string_constant'];
	t_int	:= predef['integer_constant'];
	t_real	:= predef['real_constant'];
	t_op	:= predef['operator_symbol'];
	t_ident	:= predef['identifier'];
	t_dot	:= kartab['.'];
	t_lp	:= kartab['('];
	t_rp	:= kartab[')'];
	t_lbr	:= kartab['['];
	t_rbr	:= kartab[']'];
	t_comma	:= kartab[','];
	t_semi	:= kartab[';'];
	t_colon	:= kartab[':'];
	t_EOF	:= predef['EOF'];
	t_EOF_INCLUDE := kartab['eof_include'];

	keytab['init'] := kartab['init'];

	#*******************************************************#
	# 'init' is a keyword, but the syntax of parsgen	#
	# does not allow writing it as INIT. Nevertheless, it	#
	# should be in keytab, in order to retrieve its type	#
	# correctly.						#
	#*******************************************************#

	char_to_int := table(128, undefined);
	for i in interval(0, 32, 1) do char_to_int[ascii[i]] := i od;
	for c in ASCII do char_to_int[c] := '''' || c od;
	char_to_int['\\'] := 92;
	char_to_int['\177'] := 127;

);
	#***************************************************************#
	# This procedure initializes symbol types. It is called just	#
	# before the first call to nextsym; in that way it is certain	#
	# that predef and kartab are initialized at the moment these	#
	# types are initialized.					#
	#***************************************************************#

proc comment()
(	var cseen := True, readln := True;

        while True
        do      if cseen = False
		then	line.span(layout) | empty_string;
			if line.lit('#')
			then	cseen := True; readln := False;
			elif line.rpos(0)
			then	readln := True;
			else	return
			fi;
		fi;
		if cseen = True 
		then	if line.break('#') & line.move(1)
			then	cseen := False;
				readln :=
				if line.rpos(0) then True else False fi;
			else	readln := True
			fi
		fi;
		if readln=True & ~src.get
		then	if cseen = True
			then	ermsg('non closed comment', lnr) fi;
			return
		fi;
	od;
);

proc get_str()
(	var c;

	t_sy := t_str;
	sy := '';
	scan line for
	while sy := sy || break(STOP_CHARS)
	do	if lit('''') then
		   if lit('''') then sy := sy || ''''
		   else
		      return
		   fi
		elif lit('\\\\') then sy := sy || '\\'
		elif lit('\\t')  then sy := sy || '\t'
		elif lit('\\n')  then sy := sy || '\n'
		elif lit('\\b')  then sy := sy || '\b'
		elif lit('\\r')  then sy := sy || '\r'
		elif lit('\\') then
		   if c := integer((lit('0') | lit('1'))) * 64 +
			   integer(any('01234567')) * 8 +
			   integer(any('01234567'))
		   then sy := sy || ascii[c]
		   else
		        ermsg('illegal escape sequence in string', lnr);
		   fi
		else
		     ermsg('illegal character in string', lnr);
		     move(1);
		fi;
	od;
	rtab(0);
	ermsg('string not terminated', lnr);
	rof;
);

proc get_number()
assert  scan line
	for   var tail;
	      if tail := span(digit)
	      then sy := if sy = '0' then tail else sy || tail fi
	      fi &
	      t_sy := t_int &
	      if sy := sy || lit('.') || (span(digit) | '')
	      then t_sy := t_real
	      fi &
	      if sy := sy || lit('e') || (any('+-') | '') || span(digit)
	      then t_sy := t_real
	      fi
	rof;

	#***************************************************************#
	#    Get_number parses a number which start with a digit	#
	#    (and not with a dot). After parsing a sequence of digits,	#
	#    type t_int is assigned. If that sequence is followed by	#
	#    either a dot (possibly followed by another string of 	#
	#    digits), or e [+|-|nothing] followed by a string of digits,#
	#    or both, the type is t_real.				#
	#***************************************************************#

proc get_real_or_dot()
scan line
for   if sy := sy || span(digit) ||
	       ( lit('e') || (any('+-') | '') || span(digit)
		 | '')
      then t_sy := t_real
      else t_sy := t_dot
      fi
rof;
	#***************************************************************#
	# 3. To parse a single dot, or a real denotation which starts	#
	#    with a dot, and then must be followed by at least one	#
	#    digit. '.e3' is not a legal real denotation because of the	#
	#    difficulties it would cause 'nextsym' to distinguish	#
	#    between a field selection and a real.			#
	#***************************************************************#


proc get_opname()
scan line
for	sy := sy || span(alphanum) | 'OK';
	t_sy := t_op;
	if montab[sy] ~= undefined | dytab[sy] ~= undefined
	then return
	elif scan sy for lit('_') & any(alpha) & rtab(1) & lit('_') rof fails
	then	ermsg('illegal operator name "' || sy || '"', lnr)
	fi
rof;

proc nextsym()
while True
do line.span(layout) | empty_string;
   if sy := line.any(alpha) || (line.span(alphanum) | empty_string)
   then
	t_sy := (undefined ~= keytab[sy] | t_ident);
	return;
   elif sy := line.move(1)
   then 
	case sy
	of	'0':		# skip leading zeros #
				line.span('0') | empty_string;
				get_number();
				return,
		'1': '2': '3': '4': '5': '6': '7': '8': '9':
				get_number();
				return,
		'.':
				get_real_or_dot();
				return,
		'''':
				get_str();
				return,
		'_':		get_opname();
				return,
		'*': '+': '-': '/': ':': '<': '=': '>': '?':
		'|': '&': '~': '!': '$': '%': '\\': '@':
				sy := sy || line.span(ops) | 'OK';
				if sy = ':'
				then	t_sy := t_colon
				else	t_sy := t_op
				fi;
				return,
		'(':
				t_sy := t_lp;
				return,
		')':
				t_sy := t_rp;
				return,
		'[':
				t_sy := t_lbr;
				return,
		']':
				t_sy := t_rbr;
				return,
		',':
				t_sy := t_comma;
				return,
		';':
				t_sy := t_semi;
				return,
		'#':
				comment(),
		default:
				ermsg('illegal character "' || sy || '"', lnr)
	esac
   elif src.get
   then # noop #
   elif src.previous ~= undefined
   then sy := 'EOF_INCLUDE';
	t_sy := t_EOF_INCLUDE;
	return
   else sy := 'EOF';
	t_sy := t_EOF;
	return
   fi
od;
	#***************************************************************#
	# comment must be updated					#
	# 'nextsym' determines the next lexical symbol (in 'sy') and	#
	# its type (in 't_sy'). First, tabs and spaces are skipped.	#
	# If then nothing is left on the current line, the proecdure	#
	# reads new lines until it finds one with a meaningful symbol.	#
	# There are altogether 15 possibilities:			#
	# 1. Identifiers and keywords, which get a separate treatment	#
	#    to speed up their recognition. Their type is either	#
	#    extracted from keytab, or t_int.				#
	# 2. Integers, and reals for so far they start with a digit.	#
	# 3. A single dot, which could also be the start of a real.	#
	# 4. A string.							#
	# 5. An operator name starting with an underline.		#
	# 6. An operator consisting of a sequence of operator symbols.	#
	#    An explicit test for a single colon is included here.	#
	# 7. A left parenthesis.					#
	# 8. A right parenthesis.					#
	# 9. A left bracket.						#
	#10. A right bracket.						#
	#11. A comma.							#
	#12. A semi_colon.						#
	#13. The start of a comment. After the comment has been parsed,	#
	#    a next pass through the loop is executed, to retrieve	#
	#    a meaningful symbol.					#
	#14. If the current line contains a non_layout character which	#
	#    is none of the above, it is illegal. An error message is	#
	#    issued an a new pass through the loop executed.		#
	#15. If the current line is empty and no new line can be read	#
	#    from the source file, we are at end-of-file.		#
	#***************************************************************#



proc  p_actuals(dont_skip)
(
  var exprs ;
  # line: 666#
  exprs := [];
  if t_sy ~= 52 then testsym(s_52,dont_skip,'<actuals>') fi;
  if t_sy = 52
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_actuals_0_0[t_sy]=0 then testsymee(dont_skip,r_actuals_0_0,EMPTY,'') fi;
    if f_actuals_0_1[t_sy] = 1
    then
      exprs := p_expression_list(dont_skip.disj(r_actuals_0_1_0_0));
    fi;
    if t_sy = 43
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('")"',lnr);
    fi;
  fi;
  # line: 667#
  return(exprs);
);


proc  p_array_expression(dont_skip)
(
  var exprs,sd ;
  # line: 893#
  var args, s, d;
  exprs := [];
  if t_sy ~= 42 then testsym(s_42,dont_skip,'<array_expression>') fi;
  if t_sy = 42
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_array_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_array_expression_0_0,EMPTY,'') fi;
    if f_array_expression_0_1[t_sy]=0 then testsym(f_array_expression_0_1,dont_skip,'"(" or "["') fi;
    if t_sy = 52
    then
      sd := p_size_definition(dont_skip.disj(r_array_expression_0_1_0_0));
      if t_sy = 51
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_array_expression_0_1_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_array_expression_0_1_0_1_0_0,EMPTY,'') fi;
        exprs := p_array_initialization(dont_skip);
      fi;
    elif t_sy = 48
    then
      exprs := p_array_initialization(dont_skip);
    fi;
  fi;
  # line: 896#
  if sd = undefined then
  s := CONSTANT(exprs.size); d := UNDEFINED
  else
  s := sd[0]; d := sd[1]
  fi;
  return(ARINIT(s, d, exprs));
);


proc  p_array_initialization(dont_skip)
(
  var e ;
  if t_sy ~= 48 then testsym(s_48,dont_skip,'<array_initialization>') fi;
  if t_sy = 48
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_array_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_array_initialization_0_0,EMPTY,'') fi;
    e := p_expression_list(dont_skip.disj(r_array_initialization_0_1));
    if t_sy = 49
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"]"',lnr);
    fi;
  fi;
  # line: 908#
  return(e);
);


proc  p_array_or_table_initialization(dont_skip)
(
  var e1,elist,telem ;
  # line: 960#
  var args := [], res, nelem := 0, te := [], laste,
  def := UNDEFINED;
  if t_sy ~= 48 then testsym(s_48,dont_skip,'<array_or_table_initialization>') fi;
  if t_sy = 48
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_array_or_table_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_array_or_table_initialization_0_0,EMPTY,'') fi;
    if f_array_or_table_initialization_0_1[t_sy]=0 then testsym(f_array_or_table_initialization_0_1,dont_skip,'"(","[","]","array" or "assert" etc.') fi;
    if t_sy = 49
    then
      # line: 964#
      res := ARINIT(CONSTANT(args.size), def, args);
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    elif f_array_or_table_initialization_0_1_1[t_sy] = 1
    then
      e1 := p_expression(dont_skip.disj(r_array_or_table_initialization_0_1_1_0));
      if f_array_or_table_initialization_0_1_1_1[t_sy]=0 then testsym(f_array_or_table_initialization_0_1_1_1,dont_skip,'",",":" or "]"') fi;
      if t_sy = 49
      then
        # line: 962#
        args := [e1];
        # line: 964#
        res := ARINIT(CONSTANT(args.size), def, args);
        nextsym;
        if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
      elif t_sy = 44
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_array_or_table_initialization_0_1_1_1_1_0[t_sy]=0 then testsymee(dont_skip,r_array_or_table_initialization_0_1_1_1_1_0,EMPTY,'') fi;
        elist := p_expression_list(dont_skip.disj(r_array_or_table_initialization_0_1_1_1_1_1));
        # line: 963#
        args := concat([e1], elist);
        if t_sy = 49
        then
          # line: 964#
          res := ARINIT(CONSTANT(args.size), def, args);
          nextsym;
          if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
        else error('"]"',lnr);
        fi;
      elif t_sy = 46
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_array_or_table_initialization_0_1_1_1_2_0[t_sy]=0 then testsymee(dont_skip,r_array_or_table_initialization_0_1_1_1_2_0,EMPTY,'') fi;
        elist := p_table_element_tail(dont_skip.disj(r_array_or_table_initialization_0_1_1_1_2_1));
        # line: 965#
        nelem := nelem + elist.size;
        laste := elist.delete;
        te.append(KEY(concat([e1], elist), laste));
        if t_sy = 44
        then
          nextsym;
          if dont_skip[t_sy]=0 & r_array_or_table_initialization_0_1_1_1_2_2_0_0[t_sy]=0 then testsymee(dont_skip,r_array_or_table_initialization_0_1_1_1_2_2_0_0,EMPTY,'') fi;
          while f_array_or_table_initialization_0_1_1_1_2_2_0_1[t_sy] = 1
          do
            telem := p_table_element(dont_skip.disj(r_array_or_table_initialization_0_1_1_1_2_2_0_1_0_0));
            # line: 968#
            nelem := nelem + telem[0];
            te.append(telem[1]);
            if t_sy = 44
            then
              nextsym;
              if f_table_element[t_sy]=0 then testsymdd(f_table_element,dont_skip,r_array_or_table_initialization_0_1_1_1_2_2_0_1_0_1,'<table_element>') fi;
            elif f_table_element[t_sy] = 1
            then error('Separating ","',lnr);
            fi;
          od;
        fi;
        if t_sy = 49
        then
          # line: 970#
          res := TABINIT(CONSTANT(nelem), def, nelem, te);
          nextsym;
          if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
        else error('"]"',lnr);
        fi;
      fi;
    fi;
  fi;
  # line: 971#
  return(res);
);


proc  p_assert_expression(dont_skip)
(
  var e ;
  if t_sy ~= 0 then testsym(s_0,dont_skip,'<assert_expression>') fi;
  if t_sy = 0
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_assert_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_assert_expression_0_0,EMPTY,'') fi;
    e := p_expression(dont_skip);
  fi;
  # line: 884#
  return(ASSERT(e));
);


proc  p_block(dont_skip)
(
  var c,e,v ;
  # line: 986#
  var n, exprs := [], cnms := [], vnms := [];
  level := level+1;
  if f_block[t_sy]=0 & dont_skip[t_sy]=0 then testsymee(f_block,dont_skip,EMPTY, '') fi;
      while f_block_0_0[t_sy] = 1
    do
      if t_sy = 39
      then
        v := p_local_variable_declaration(dont_skip.disj(r_block_0_0_0_0));
        # line: 990#
        vnms := concat(vnms, v[0]);
        exprs := concat(exprs, v[1]);
      elif t_sy = 4
      then
        c := p_constant_declaration(dont_skip.disj(r_block_0_0_1_0));
        # line: 993#
        cnms := concat(cnms, c);
      fi;
    od;
    # line: 995#
    loclist := concat(loclist, vnms);
    while f_block_0_1[t_sy] = 1
    do
      if f_block_0_1_0_0[t_sy] = 1
      then
        e := p_expression(dont_skip.disj(r_block_0_1_0_0_0_0));
        # line: 998#
        exprs.append(e);
      fi;
      if t_sy = 47
      then
        nextsym;
        if f_block_0_1_0_0[t_sy]=0 & dont_skip[t_sy]=0 & r_block_0_1_0_1[t_sy] = 0 then testsymeee(f_block_0_1_0_0,dont_skip,r_block_0_1_0_0,EMPTY, '') fi;
      elif f_block_0_1_0_0[t_sy] = 1
      then error('Separating ";"',lnr);
      fi;
    od;
  # line: 1000#
  n := exprs.size;
  if n = 0
  then	e := UNDEFINED
  elif n  = 1
  then
  e := exprs[0]
  else
  e := SEMI(exprs)
  fi;
  remove(vnms);
  remove(cnms);
  level := level - 1;
  return(e);
);


proc  p_case_entry(dont_skip)
(
  var b ;
  # line: 778#
  var cl := 'C0', exprs := [];
  if errcnt = 0
  then	cl := clab.next();
  fi;
  if f_case_entry[t_sy]=0 then testsym(f_case_entry,dont_skip,'<case_entry>') fi;
  if f_case_entry[t_sy] = 1
  then
    b := p_block(dont_skip.disj(r_case_entry_0_0));
    if t_sy ~= 46 then testsymdd(s_46,dont_skip,r_case_entry_0_1,'":"') fi;
    while s_46[t_sy] = 1
    do
      if t_sy = 46
      then
        # line: 784#
        if errcnt = 0 then
        if type(b) = 'CONSTANT' then
        exprs.append(b)
        else
        ermsg('key in case not constant', lnr)
        fi
        fi;
        nextsym;
        if dont_skip[t_sy]=0 & r_case_entry_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_case_entry_0_1_0_0,EMPTY,'') fi;
        b := p_block(dont_skip.disj(r_case_entry_0_1_0_1));
      fi;
    od;
  fi;
  # line: 792#
  return([cl, b, KEY(exprs, cl)]);
  #***************************************************************#
  # In order to enforce the LL(1) property, the constant key in	#
  # a case is parsed as a block. The procedure key_out afterwards	#
  # checks, whether this block was indeed a simple constant: if	#
  # not, an error message is issued.				#
  # The LL(1) restrictions also require that <case_entry>s cannot #
  # produce empty, hence the repetition.				#
  #***************************************************************#
);


proc  p_case_expression(dont_skip)
(
  var ce,def,e ;
  # line: 756#
  var caselabs := [], caseexprs := [], cinit := [],
  res, deflab, gnm, stlnr := lnr, l := LINE();
  if t_sy ~= 2 then testsym(s_2,dont_skip,'<case_expression>') fi;
  if t_sy = 2
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_case_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_case_expression_0_0,EMPTY,'') fi;
    e := p_expression(dont_skip.disj(r_case_expression_0_1));
    if t_sy = 22
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_case_expression_0_2[t_sy]=0 then testsymee(dont_skip,r_case_expression_0_2,EMPTY,'') fi;
    else error('"of"',lnr);
    fi;
    while f_case_expression_0_3[t_sy] = 1
    do
      if f_case_expression_0_3_0_0_0[t_sy] = 1
      then
        ce := p_case_entry(dont_skip.disj(r_case_expression_0_3_0_0_0_0));
        # line: 758#
        caselabs.append(ce[0]); caseexprs.append(ce[1]);
        cinit.append(ce[2]);
      else
        p_empty(dont_skip.disj(r_case_expression_0_3_0_0_1_0));
      fi;
      if t_sy = 44
      then
        nextsym;
        if f_case_expression_0_3_0_0[t_sy]=0 & dont_skip[t_sy]=0 & r_case_expression_0_3_0_1[t_sy] = 0 then testsymeee(f_case_expression_0_3_0_0,dont_skip,r_case_expression_0_3_0_0,EMPTY, '') fi;
      elif f_case_expression_0_3_0_0[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 5
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_case_expression_0_4_0_0[t_sy]=0 then testsymee(dont_skip,r_case_expression_0_4_0_0,EMPTY,'') fi;
      if t_sy = 46
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_case_expression_0_4_0_1[t_sy]=0 then testsymee(dont_skip,r_case_expression_0_4_0_1,EMPTY,'') fi;
      else error('":"',lnr);
      fi;
      def := p_block(dont_skip.disj(r_case_expression_0_4_0_2));
    else
      p_empty(dont_skip.disj(r_case_expression_0_4_1_0));
    fi;
    if t_sy = 11
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"esac"',lnr);
    fi;
  fi;
  # line: 760#
  if errcnt = 0
  then	deflab := clab.next;
  gnm := VARIABLE('', GlobalVar);
  symentry(gnm.name, 0, gnm);
  caseinit.append(VARINIT(
  stlnr,
  gnm,
  TABINIT(CONSTANT(30),
  deflab,
  caseexprs.size,
  cinit),
  lnr));
  res := CASE(l, gnm, e, deflab, def, caselabs, caseexprs)
  fi;
  return(res);
);


proc  p_class_declaration(dont_skip)
(
  var c,fnms,p,self_init,super ;
  # line: 236#
  var nf := 0,
  stlnr,
  cnms := [],
  sup_init, loc;
  offset := -1;
  classvarinit := [];
  classprocs := [];
  if t_sy ~= 3 then testsym(s_3,dont_skip,'<class_declaration>') fi;
  if t_sy = 3
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_class_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_0,EMPTY,'') fi;
    if t_sy = 53
    then
      # line: 245#
      clname := sy;
      level := level+1;
      nextsym;
      if dont_skip[t_sy]=0 & r_class_declaration_0_1[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_1,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    fnms := p_formals_of_class(dont_skip.disj(r_class_declaration_0_2));
    # line: 248#
    par_flds := copy(fnms);
    if t_sy = 1
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_class_declaration_0_3[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_3,EMPTY,'') fi;
    else error('"begin"',lnr);
    fi;
    super := p_subclass_declaration(dont_skip.disj(r_class_declaration_0_4));
    p_fetch_associations(dont_skip.disj(r_class_declaration_0_5));
    p_store_associations(dont_skip.disj(r_class_declaration_0_6));
    while f_class_declaration_0_7[t_sy] = 1
    do
      if t_sy = 24
      then
        p := p_procedure_field_declaration(dont_skip.disj(r_class_declaration_0_7_0_0));
        # line: 252#
        classprocs.append(p);
      elif t_sy = 23
      then
        p := p_operator_field_declaration(dont_skip.disj(r_class_declaration_0_7_1_0));
        # line: 252#
        classprocs.append(p);
      elif t_sy = 39
      then
        p_data_field_declaration(dont_skip.disj(r_class_declaration_0_7_2_0));
      elif t_sy = 4
      then
        c := p_constant_declaration(dont_skip.disj(r_class_declaration_0_7_3_0));
        # line: 250#
        cnms := concat(cnms, c);
      fi;
    od;
    # line: 255#
    curproc := PROC_DECL(Class);
    fnms := concat(['self'], par_flds);
    symentry(clname, 0, curproc);
    # the formal parameters of the class creation procedure	#
    # are teated as class variables and not as local vars.	#
    loclist := copy(fnms);
    loccnt := loclist.size;
    if super ~= undefined
    then	var su := symtab[super][S_VALUE],
    nfs := su.nformals, i,
    args := array(nfs, 0);
    for i in args.index
    do args[i] := symtab[fnms[i]][S_VALUE] od;
    sup_init := SUP_CALL(su, args);
    fi;
    #*******************************************************#
    # If the current class is a subclass, a call to the	#
    # init-procedure of the superclass is generated.	#
    # If the superclass had n-1 declared parameter, then	#
    # the actual parameters of this call are exactly the	#
    # first n parameters of the current class (including	#
    # the parameter which equals the "self" object.		#
    # This accounts for the pushing on the stack of the	#
    # locals.						#
    #*******************************************************#
    if t_sy = 51
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_class_declaration_0_8_0_0[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_8_0_0,EMPTY,'') fi;
      if t_sy = 46
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_class_declaration_0_8_0_1[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_8_0_1,EMPTY,'') fi;
      else error('":"',lnr);
      fi;
      self_init := p_block(dont_skip.disj(r_class_declaration_0_8_0_2));
      # line: 283#
      if super ~= undefined
      then	
      self_init := SEMI([sup_init, self_init])
      fi;
    else
      p_empty(dont_skip.disj(r_class_declaration_0_8_1_0));
      # line: 288#
      if super = undefined then
      self_init := UNDEFINED
      else
      self_init := sup_init
      fi;
    fi;
    if t_sy = 10
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_class_declaration_0_9[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_9,EMPTY,'') fi;
    else error('"end"',lnr);
    fi;
    if t_sy = 53
    then
      # line: 294#
      if sy ~= clname
      then	ermsg('"end" not followed by class name "' ||
      clname ||'"', lnr)
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_class_declaration_0_10[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_10,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 299#
  putassocs(fetch_type); putassocs(store_type);
  fetchtab := table(5, undefined);
  storetab := table(5, undefined);
  assoctab := table(5, undefined);
  curproc.complete(clname, fnms, self_init);
  classtab[clname] :=
  [offset+1, par_flds, data_flds, proc_flds, op_flds, nclasses];
  nclasses := nclasses + 1;
  # par_flds already remove by cuproc.complete #
  remove(data_flds);
  remove(proc_flds);
  remove(cnms);
  level := level-1;
  par_flds := [];
  data_flds := [];
  proc_flds := [];
  op_flds := [];
  clname := '';
  inhertab := table(10, undefined);
  return(curproc);
);


proc  p_constant(dont_skip)
(
  # line: 645#
  var res;
  if f_constant[t_sy]=0 then testsym(f_constant,dont_skip,'<constant>') fi;
  if t_sy = 57
  then
    # line: 646#
    res := CONSTANT(sy);
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  elif t_sy = 54
  then
    # line: 647#
    if sy.size > MAXINT.size | sy.right(MAXINT.size, '0') > MAXINT then
    ermsg('too large integer constant ' || sy, lnr);
    sy := '0'
    fi;
    res := CONSTANT(integer(sy));
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  elif t_sy = 56
  then
    # line: 652#
    res := CONSTANT(real(sy));
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  elif t_sy = 37
  then
    # line: 653#
    res := UNDEFINED;
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  fi;
  # line: 654#
  return(res);
);


proc  p_constant_declaration(dont_skip)
(
  var ci ;
  # line: 100#
  var nms := [];
  if t_sy ~= 4 then testsym(s_4,dont_skip,'<constant_declaration>') fi;
  if t_sy = 4
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_constant_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_constant_declaration_0_0,EMPTY,'') fi;
    if t_sy ~= 53 then testsymdd(s_53,dont_skip,r_constant_declaration_0_1,'"identifier"') fi;
    while s_53[t_sy] = 1
    do
      ci := p_constant_initialization(dont_skip.disj(r_constant_declaration_0_1_0_0));
      # line: 102#
      if ci ~= undefined then nms.append(ci) fi;
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 53 then testsymdd(s_53,dont_skip,r_constant_declaration_0_1_0_1,'<constant_initialization>') fi;
      elif s_53[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 104#
  return(nms);
);


proc  p_constant_initialization(dont_skip)
(
  var e ;
  # line: 109#
  var name := '';
  if t_sy ~= 53 then testsym(s_53,dont_skip,'<constant_initialization>') fi;
  if t_sy = 53
  then
    # line: 111#
    name := sy;
    nextsym;
    if dont_skip[t_sy]=0 & r_constant_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_constant_initialization_0_0,EMPTY,'') fi;
    if t_sy = 55
    then
      # line: 113#
      if sy ~= ':='
      then	ermsg('":=" expected instead of "' || sy || '"', lnr)
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_constant_initialization_0_1[t_sy]=0 then testsymee(dont_skip,r_constant_initialization_0_1,EMPTY,'') fi;
    else error('"operator_symbol"',lnr);
    fi;
    e := p_expression(dont_skip);
  fi;
  # line: 117#
  if errcnt = 0 then
  if type(e) ~= 'CONSTANT' then
  ermsg('constant expression required', lnr);
  e := UNDEFINED
  fi
  else e := UNDEFINED
  fi;
  if name ~= '' & symentry(name, level, e) = True
  then
  return(name)
  else
  return(undefined)
  fi;
);


proc  p_data_field_declaration(dont_skip)
(
  if t_sy ~= 39 then testsym(s_39,dont_skip,'<data_field_declaration>') fi;
  if t_sy = 39
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_data_field_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_data_field_declaration_0_0,EMPTY,'') fi;
    if t_sy ~= 53 then testsymdd(s_53,dont_skip,r_data_field_declaration_0_1,'"identifier"') fi;
    while s_53[t_sy] = 1
    do
      p_field_initialization(dont_skip.disj(r_data_field_declaration_0_1_0_0));
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 53 then testsymdd(s_53,dont_skip,r_data_field_declaration_0_1_0_1,'<field_initialization>') fi;
      elif s_53[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
);


proc  p_dyadic_symbol_declaration(dont_skip)
(
  if t_sy ~= 7 then testsym(s_7,dont_skip,'<dyadic_symbol_declaration>') fi;
  if t_sy = 7
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_dyadic_symbol_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_dyadic_symbol_declaration_0_0,EMPTY,'') fi;
    if t_sy ~= 55 then testsymdd(s_55,dont_skip,r_dyadic_symbol_declaration_0_1,'"operator_symbol"') fi;
    while s_55[t_sy] = 1
    do
      # line: 516#
      dytab[sy] :=
      [sy || '.2', 2, -lnr, priofdef(2), priogdef(2), '*error*'];
      nextsym;
      if dont_skip[t_sy]=0 & r_dyadic_symbol_declaration_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_dyadic_symbol_declaration_0_1_0_0,EMPTY,'') fi;
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 55 then testsymdd(s_55,dont_skip,r_dyadic_symbol_declaration_0_1_0_1,'"operator_symbol"') fi;
      elif s_55[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
);


proc  p_empty(dont_skip)
(
  );


proc  p_expression(dont_skip)
(
  # line: 560#
  var res;
  opush(dytab[o_lpar]);
  if f_expression[t_sy]=0 then testsym(f_expression,dont_skip,'<expression>') fi;
  if f_expression[t_sy] = 1
  then
    p_monadic_expression(dont_skip.disj(r_expression_0_0));
    while s_55[t_sy] = 1
    do
      if t_sy = 55
      then
        # line: 563#
        check_dyop(sy);
        treatop(dytab[sy]);
        nextsym;
        if dont_skip[t_sy]=0 & r_expression_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_expression_0_1_0_0,EMPTY,'') fi;
        p_monadic_expression(dont_skip.disj(r_expression_0_1_0_1));
      fi;
    od;
  fi;
  # line: 566#
  res := emptystack();
  return(res);
);


proc  p_expression_list(dont_skip)
(
  var e ;
  # line: 671#
  var exprs := [];
  if f_expression_list[t_sy]=0 then testsym(f_expression_list,dont_skip,'<expression_list>') fi;
  if f_expression_list[t_sy] = 1
  then
    while f_expression_list[t_sy] = 1
    do
      e := p_expression(dont_skip.disj(r_expression_list_0_0_0_0));
      # line: 672#
      exprs.append(e);
      if t_sy = 44
      then
        nextsym;
        if f_expression[t_sy]=0 then testsymdd(f_expression,dont_skip,r_expression_list_0_0_0_1,'<expression>') fi;
      elif f_expression[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
  fi;
  # line: 673#
  return(exprs);
  #***************************************************************#
  # Expression_list parses at least one expression;		#
  # empty alternatives are always included explicitly		#
  # in the calling rule.						#
  #***************************************************************#
);


proc  p_fetch_associations(dont_skip)
(
  # line: 348#
  var field;
  if t_sy ~= 13 & dont_skip[t_sy]=0 then testsymee(s_13,dont_skip,EMPTY, '') fi;
      if t_sy = 13
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_fetch_associations_0_0_0_0[t_sy]=0 then testsymee(dont_skip,r_fetch_associations_0_0_0_0,EMPTY,'') fi;
      if f_fetch_associations_0_0_0_1[t_sy]=0 then testsymdd(f_fetch_associations_0_0_0_1,dont_skip,r_fetch_associations_0_0_0_1,'"identifier" or "operator_symbol"') fi;
      while f_fetch_associations_0_0_0_1[t_sy] = 1
      do
        if f_fetch_associations_0_0_0_1_0_0[t_sy] = 1
        then
          if t_sy = 53
          then
            # line: 350#
            field := sy;
            nextsym;
            if dont_skip[t_sy]=0 & r_fetch_associations_0_0_0_1_0_0_0_0_0_0[t_sy]=0 then testsymee(dont_skip,r_fetch_associations_0_0_0_1_0_0_0_0_0_0,EMPTY,'') fi;
          elif t_sy = 55
          then
            # line: 350#
            field := sy;
            nextsym;
            if dont_skip[t_sy]=0 & r_fetch_associations_0_0_0_1_0_0_0_0_1_0[t_sy]=0 then testsymee(dont_skip,r_fetch_associations_0_0_0_1_0_0_0_0_1_0,EMPTY,'') fi;
          fi;
          if t_sy = 46
          then
            nextsym;
            if dont_skip[t_sy]=0 & r_fetch_associations_0_0_0_1_0_0_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_fetch_associations_0_0_0_1_0_0_0_1_0_0,EMPTY,'') fi;
            if t_sy = 53
            then
              # line: 352#
              fetchtab[field] := sy;
              assoctab[sy] := fetch_type;
              nextsym;
              if dont_skip[t_sy]=0 & r_fetch_associations_0_0_0_1_0_0_0_1_0_1[t_sy]=0 then testsymee(dont_skip,r_fetch_associations_0_0_0_1_0_0_0_1_0_1,EMPTY,'') fi;
            else error('"identifier"',lnr);
            fi;
          else
            p_empty(dont_skip.disj(r_fetch_associations_0_0_0_1_0_0_0_1_1_0));
            # line: 355#
            if field ~= undefined
            then	fetchtab[field] := '_s'
            fi;
          fi;
        fi;
        if t_sy = 44
        then
          nextsym;
          if f_fetch_associations_0_0_0_1_0_0[t_sy]=0 then testsymdd(f_fetch_associations_0_0_0_1_0_0,dont_skip,r_fetch_associations_0_0_0_1_0_1,'"identifier" or "operator_symbol"') fi;
        elif f_fetch_associations_0_0_0_1_0_0[t_sy] = 1
        then error('Separating ","',lnr);
        fi;
      od;
      if t_sy = 47
      then
        nextsym;
        if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
      else error('";"',lnr);
      fi;
    fi;
);


proc  p_field_initialization(dont_skip)
(
  var e ;
  # line: 489#
  var name := '',
  v := '',
  stlnr := lnr;
  if t_sy ~= 53 then testsym(s_53,dont_skip,'<field_initialization>') fi;
  if t_sy = 53
  then
    # line: 493#
    name := sy;
    offset := offset+1;
    v := VARIABLE(name, ClassVar);
    if fieldentry(name, clname, VAR, offset, NOFETCH, NOSTORE) = True
    then	symentry(name, level, v);
    data_flds.append(sy);
    fi;
    nextsym;
    if dont_skip[t_sy]=0 & r_field_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_field_initialization_0_0,EMPTY,'') fi;
    if t_sy = 55
    then
      # line: 501#
      if sy ~= ':='
      then	ermsg('":=" expected instead of "' || sy || '"', lnr)
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_field_initialization_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_field_initialization_0_1_0_0,EMPTY,'') fi;
      e := p_expression(dont_skip);
      # line: 505#
      if errcnt = 0
      then	classvarinit.append(VARINIT(stlnr, v, e, lnr));
      fi;
    fi;
  fi;
);


proc  p_for_expression(dont_skip)
(
  var b,e ;
  # line: 813#
  var l, typ, var1, var2;
  inloop := inloop + 1;
  l := LINE();
  if t_sy ~= 15 then testsym(s_15,dont_skip,'<for_expression>') fi;
  if t_sy = 15
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_for_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_for_expression_0_0,EMPTY,'') fi;
    if t_sy = 53
    then
      # line: 818#
      typ := checktype(sy);
      if  ~typ.can_assign
      then	ermsg('illegal control variable in for loop', lnr)
      fi;
      if errcnt = 0
      then	if inproc = True
      then	var1 := VARIABLE('', LocalVar);
      var2 := VARIABLE('', LocalVar);
      loclist.append(''); loclist.append('');
      # to keep the relationship between local #
      # number and position in loclist valid   #
      # for the sake of the tracer. 	    #
      else	var1 := VARIABLE('', GlobalVar);
      var2 := VARIABLE('', GlobalVar);
      symentry(var1.name, 0, var1);
      symentry(var2.name, 0, var2);
      fi;
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_for_expression_0_1[t_sy]=0 then testsymee(dont_skip,r_for_expression_0_1,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    if t_sy = 18
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_for_expression_0_2[t_sy]=0 then testsymee(dont_skip,r_for_expression_0_2,EMPTY,'') fi;
    else error('"in"',lnr);
    fi;
    e := p_expression(dont_skip.disj(r_for_expression_0_3));
    if t_sy = 6
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_for_expression_0_4[t_sy]=0 then testsymee(dont_skip,r_for_expression_0_4,EMPTY,'') fi;
    else error('"do"',lnr);
    fi;
    b := p_block(dont_skip.disj(r_for_expression_0_5));
    if t_sy = 21
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"od"',lnr);
    fi;
  fi;
  # line: 837#
  inloop := inloop - 1;
  return(SEMI([ASSIGN(var1, UNDEFINED),
  ASSIGN(var2, e),
  WHILEDO(l,
  ASSIGN(ARINIT(CONSTANT(2),
  UNDEFINED,
  [typ,  var1]),
  FIELDSEL(var2, 'next', [var1])),
  b)]));
  #***************************************************************#
  # 'for x in c do e od' is translated as if it reads		#
  #	var1 := undefined;					#
  #	var2 := c;						#
  #	while [x,var1] := var2.next(var1) do e od;		#
  #***************************************************************#
);


proc  p_formals_of_class(dont_skip)
(
  # line: 322#
  var nms := [];
  if t_sy ~= 52 then testsym(s_52,dont_skip,'<formals_of_class>') fi;
  if t_sy = 52
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_formals_of_class_0_0[t_sy]=0 then testsymee(dont_skip,r_formals_of_class_0_0,EMPTY,'') fi;
    while s_53[t_sy] = 1
    do
      # line: 324#
      offset := offset + 1;
      if fieldentry(sy, clname, VAR, offset, NOFETCH, NOSTORE) = True
      then	symentry(sy, level, VARIABLE(sy, ClassVar));
      nms.append(sy);
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_formals_of_class_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_formals_of_class_0_1_0_0,EMPTY,'') fi;
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 53 then testsymdd(s_53,dont_skip,r_formals_of_class_0_1_0_1,'"identifier"') fi;
      elif s_53[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 43
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('")"',lnr);
    fi;
  fi;
  # line: 330#
  return(nms);
);


proc  p_formals_of_procedure(dont_skip)
(
  # line: 153#
  var nms := [];
  if t_sy ~= 52 then testsym(s_52,dont_skip,'<formals_of_procedure>') fi;
  if t_sy = 52
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_formals_of_procedure_0_0[t_sy]=0 then testsymee(dont_skip,r_formals_of_procedure_0_0,EMPTY,'') fi;
    while s_53[t_sy] = 1
    do
      # line: 155#
      if symentry(sy, level, VARIABLE(sy, LocalVar)) = True
      then	nms.append(sy)
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_formals_of_procedure_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_formals_of_procedure_0_1_0_0,EMPTY,'') fi;
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 53 then testsymdd(s_53,dont_skip,r_formals_of_procedure_0_1_0_1,'"identifier"') fi;
      elif s_53[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 43
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('")"',lnr);
    fi;
  fi;
  # line: 159#
  return(nms);
);


proc  p_global_initialization(dont_skip)
(
  var e ;
  # line: 82#
  var name := '',
  v := '',
  stlnr := lnr;
  if t_sy ~= 53 then testsym(s_53,dont_skip,'<global_initialization>') fi;
  if t_sy = 53
  then
    # line: 86#
    name := sy;
    v := VARIABLE(name, GlobalVar);
    symentry(name, level, v);
    nextsym;
    if dont_skip[t_sy]=0 & r_global_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_global_initialization_0_0,EMPTY,'') fi;
    if t_sy = 55
    then
      # line: 90#
      if sy ~= ':='
      then	ermsg('":=" expected instead of "' || sy || '"', lnr)
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_global_initialization_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_global_initialization_0_1_0_0,EMPTY,'') fi;
      e := p_expression(dont_skip);
      # line: 94#
      if errcnt = 0
      then	globinit.append(VARINIT(stlnr, v, e, lnr))
      fi;
    fi;
  fi;
);


proc  p_global_operator_declaration(dont_skip)
(
  var e,fnms ;
  # line: 165#
  var name := '', nf := 0;
  fnms := [];
  curproc := PROC_DECL(GlobalProc);
  if t_sy ~= 23 then testsym(s_23,dont_skip,'<global_operator_declaration>') fi;
  if t_sy = 23
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_global_operator_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_global_operator_declaration_0_0,EMPTY,'') fi;
    if t_sy = 55
    then
      # line: 170#
      name := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_global_operator_declaration_0_1[t_sy]=0 then testsymee(dont_skip,r_global_operator_declaration_0_1,EMPTY,'') fi;
    else error('"operator_symbol"',lnr);
    fi;
    fnms := p_formals_of_procedure(dont_skip.disj(r_global_operator_declaration_0_2));
    # line: 172#
    nf := fnms.size;
    if ~ (1 <= nf <= 2)
    then	ermsg('operator should have one or two parameters', lnr)
    fi;
    loclist := copy(fnms);
    if name ~= ''
    then	var entry, tab, intname := name || '.' || string(nf);
    tab := if nf = 1 then montab else dytab fi;
    entry := tab[name];
    if   entry = undefined
    then tab[name] :=
    [intname,nf,1,priofdef(nf),priogdef(nf),'*error*']
    elif entry[O_STATUS] < 0
    then	entry[O_STATUS] := 1;
    elif entry[O_STATUS] = 3
    then	entry[O_STATUS] := 2;
    fieldtab[intname].addglobf(curproc);
    else ermsg('global operator "' || name || '" redeclared', lnr)
    fi;
    # make symbol table entry for the benefit	#
    # <operator_field_dclation> and exp_terminate	#
    symentry(intname, 0, curproc);
    fi;
    #*******************************************************#
    # This creates a correct entry for the global operator	#
    # in montab or dytab.  From the following possibilities #
    # only cases a, b and e are legal:			#
    # a. (entry undefined)					#
    #	the operator was never declared before;		#
    # b. (state < 0)					#
    #	the operator was declared in a MONADIC or	#
    #	DYADIC statement;				#
    # c. (state = 1)					#
    #	the operator was declared before as a global	#
    #	operator only;					#
    # d. (state = 2)					#
    #	the operator was declared in a another class	#
    #	and was also defined globally;			#
    # e. (state = 3)					#
    #	the operator was declared in another class.	#
    #*******************************************************#
    if f_global_operator_declaration_0_3_0[t_sy] = 1
    then
      e := p_expression(dont_skip.disj(r_global_operator_declaration_0_3_0_0));
    else
      p_empty(dont_skip.disj(r_global_operator_declaration_0_3_1_0));
      # line: 216#
      e := UNDEFINED;
    fi;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 218#
  curproc.complete(name, fnms, e);
  return(curproc);
);


proc  p_global_procedure_declaration(dont_skip)
(
  var e,fnms ;
  # line: 135#
  var name := '';
  curproc := PROC_DECL(GlobalProc);
  if t_sy ~= 24 then testsym(s_24,dont_skip,'<global_procedure_declaration>') fi;
  if t_sy = 24
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_global_procedure_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_global_procedure_declaration_0_0,EMPTY,'') fi;
    if t_sy = 53
    then
      # line: 139#
      name := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_global_procedure_declaration_0_1[t_sy]=0 then testsymee(dont_skip,r_global_procedure_declaration_0_1,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    fnms := p_formals_of_procedure(dont_skip.disj(r_global_procedure_declaration_0_2));
    # line: 141#
    loclist := copy(fnms);
    if name ~= ''
    then	symentry(name, level-1, curproc)
    fi;
    if f_global_procedure_declaration_0_3_0[t_sy] = 1
    then
      e := p_expression(dont_skip.disj(r_global_procedure_declaration_0_3_0_0));
    else
      p_empty(dont_skip.disj(r_global_procedure_declaration_0_3_1_0));
      # line: 146#
      e := UNDEFINED;
    fi;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 148#
  curproc.complete(name, fnms, e);
  return(curproc);
);


proc  p_global_variable_declaration(dont_skip)
(
  if t_sy ~= 39 then testsym(s_39,dont_skip,'<global_variable_declaration>') fi;
  if t_sy = 39
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_global_variable_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_global_variable_declaration_0_0,EMPTY,'') fi;
    if t_sy ~= 53 then testsymdd(s_53,dont_skip,r_global_variable_declaration_0_1,'"identifier"') fi;
    while s_53[t_sy] = 1
    do
      p_global_initialization(dont_skip.disj(r_global_variable_declaration_0_1_0_0));
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 53 then testsymdd(s_53,dont_skip,r_global_variable_declaration_0_1_0_1,'<global_initialization>') fi;
      elif s_53[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
);


proc  p_identifier_or_call(dont_skip)
(
  var act ;
  # line: 658#
  var res, typ;
  if t_sy ~= 53 then testsym(s_53,dont_skip,'<identifier_or_call>') fi;
  if t_sy = 53
  then
    # line: 659#
    res := typ := checktype(sy);
    nextsym;
    if dont_skip[t_sy]=0 & r_identifier_or_call_0_0[t_sy]=0 then testsymee(dont_skip,r_identifier_or_call_0_0,EMPTY,'') fi;
    if t_sy = 52
    then
      act := p_actuals(dont_skip);
      # line: 660#
      if ~typ.can_call then ermsg('illegal call', lnr) fi;
      res := CALL(typ, act);
    fi;
  fi;
  # line: 662#
  return(res);
);


proc  p_if_body(dont_skip)
(
  var b1,b2,t ;
  # line: 739#
  var res, l := LINE();
  if f_if_body[t_sy]=0 then testsym(f_if_body,dont_skip,'<if_body>') fi;
  if f_if_body[t_sy] = 1
  then
    t := p_test(dont_skip.disj(r_if_body_0_0));
    if t_sy = 35
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_if_body_0_1[t_sy]=0 then testsymee(dont_skip,r_if_body_0_1,EMPTY,'') fi;
    else error('"then"',lnr);
    fi;
    b1 := p_block(dont_skip.disj(r_if_body_0_2));
    if t_sy = 8
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_if_body_0_3_0_0[t_sy]=0 then testsymee(dont_skip,r_if_body_0_3_0_0,EMPTY,'') fi;
      b2 := p_if_body(dont_skip);
      # line: 741#
      res := IFELSE(l, t, b1, b2);
    elif t_sy = 9
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_if_body_0_3_1_0[t_sy]=0 then testsymee(dont_skip,r_if_body_0_3_1_0,EMPTY,'') fi;
      b2 := p_block(dont_skip);
      # line: 741#
      res := IFELSE(l, t, b1, b2);
    else
      p_empty(dont_skip);
      # line: 743#
      res := IFTHEN(l, t, b1);
    fi;
  fi;
  # line: 744#
  return(res);
);


proc  p_if_expression(dont_skip)
(
  var e ;
  if t_sy ~= 17 then testsym(s_17,dont_skip,'<if_expression>') fi;
  if t_sy = 17
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_if_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_if_expression_0_0,EMPTY,'') fi;
    e := p_if_body(dont_skip.disj(r_if_expression_0_1));
    if t_sy = 14
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"fi"',lnr);
    fi;
  fi;
  # line: 719#
  return(e);
  #***************************************************************#
  # The syntax of the if-then-else deviates from the one given	#
  # in the formal definition of SUMMER. This is a consequence	#
  # of the parsetree structure, which for e.g.			#
  # "if t1 then e1 elif t2 then e2 fi" looks like			#
  # ife(t1, e1, ife(t2, e2, e3)). Building the innermost "ife"	#
  # first is simplified by the recursion.				#
  # Another possibility would be, to make 'ife' an n-adic operator#
  # like ";".							#
  #***************************************************************#
);


proc  p_include_file(dont_skip)
(
  # line: 546#
  var filename, newsrc;
  if t_sy ~= 19 then testsym(s_19,dont_skip,'<include_file>') fi;
  if t_sy = 19
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_include_file_0_0[t_sy]=0 then testsymee(dont_skip,r_include_file_0_0,EMPTY,'') fi;
    if t_sy = 57
    then
      # line: 548#
      filename := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_include_file_0_1[t_sy]=0 then testsymee(dont_skip,r_include_file_0_1,EMPTY,'') fi;
    else error('"string_constant"',lnr);
    fi;
    if t_sy = 47
    then
      # line: 550#
      if newsrc := SOURCE(filename, src) fails
      then ermsg('cannot open "' || filename || '"', lnr)
      else src.decls.append(newsrc);
      src := newsrc
      fi;
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
);


proc  p_local_initialization(dont_skip)
(
  var e ;
  # line: 1034#
  var name := '', v;
  e := undefined;
  if t_sy ~= 53 then testsym(s_53,dont_skip,'<local_initialization>') fi;
  if t_sy = 53
  then
    # line: 1037#
    name := sy;
    v := VARIABLE(name, LocalVar);
    if symentry(sy, level, v) = False
    then
    name := undefined
    fi;
    nextsym;
    if dont_skip[t_sy]=0 & r_local_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_local_initialization_0_0,EMPTY,'') fi;
    if t_sy = 55
    then
      # line: 1044#
      if sy ~= ':='
      then	ermsg('":=" expected instead of "' || sy || '"', lnr)
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_local_initialization_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_local_initialization_0_1_0_0,EMPTY,'') fi;
      e := p_expression(dont_skip);
      # line: 1048#
      e := ASSIGN(v, e);
    else
      p_empty(dont_skip);
      # line: 1051#
      if inloop > 0 then
      e := ASSIGN(v, UNDEFINED);
      fi;
    fi;
  fi;
  # line: 1055#
  return([name, e]);
  #***************************************************************#
  # All declarations of local variables are translated as assign-	#
  # ments, either of the initialisation expression, or of the	#
  # value 'undefined'. The latter is done to assure that variables#
  # local to a loop body are re-initialised on each new entry of	#
  # the body.							#
  #***************************************************************#
);


proc  p_local_variable_declaration(dont_skip)
(
  var e ;
  # line: 1017#
  var names := [], exprs := [];
  if inproc = False
  then	ermsg('local variable declarations outside procedure',
  lnr)
  fi;
  if t_sy ~= 39 then testsym(s_39,dont_skip,'<local_variable_declaration>') fi;
  if t_sy = 39
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_local_variable_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_local_variable_declaration_0_0,EMPTY,'') fi;
    if t_sy ~= 53 then testsymdd(s_53,dont_skip,r_local_variable_declaration_0_1,'"identifier"') fi;
    while s_53[t_sy] = 1
    do
      e := p_local_initialization(dont_skip.disj(r_local_variable_declaration_0_1_0_0));
      # line: 1024#
      if e[0] ~= undefined then names.append(e[0]) fi;
      if e[1] ~= undefined then exprs.append(e[1]) fi;
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 53 then testsymdd(s_53,dont_skip,r_local_variable_declaration_0_1_0_1,'<local_initialization>') fi;
      elif s_53[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 1027#
  return([names, exprs]);
);


proc  p_monadic_expression(dont_skip)
(
  if f_monadic_expression[t_sy]=0 then testsym(f_monadic_expression,dont_skip,'<monadic_expression>') fi;
  if f_monadic_expression[t_sy] = 1
  then
    while t_sy = 55
    do
      # line: 571#
      check_monop(sy);
      treatop(montab[sy]);
      nextsym;
      if dont_skip[t_sy]=0 & r_monadic_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_monadic_expression_0_0,EMPTY,'') fi;
    od;
    p_primary(dont_skip);
  fi;
);


proc  p_monadic_symbol_declaration(dont_skip)
(
  if t_sy ~= 20 then testsym(s_20,dont_skip,'<monadic_symbol_declaration>') fi;
  if t_sy = 20
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_monadic_symbol_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_monadic_symbol_declaration_0_0,EMPTY,'') fi;
    if t_sy ~= 55 then testsymdd(s_55,dont_skip,r_monadic_symbol_declaration_0_1,'"operator_symbol"') fi;
    while s_55[t_sy] = 1
    do
      # line: 511#
      montab[sy] :=
      [sy || '.1', 1, -lnr, priofdef(1), priogdef(1), '*error*'];
      nextsym;
      if dont_skip[t_sy]=0 & r_monadic_symbol_declaration_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_monadic_symbol_declaration_0_1_0_0,EMPTY,'') fi;
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 55 then testsymdd(s_55,dont_skip,r_monadic_symbol_declaration_0_1_0_1,'"operator_symbol"') fi;
      elif s_55[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
);


proc  p_operator_field_declaration(dont_skip)
(
  var e,n_nms ;
  # line: 425#
  var name := '',
  nf := 0,
  fnms := '';
  curproc := PROC_DECL(ClassProc);
  if t_sy ~= 23 then testsym(s_23,dont_skip,'<operator_field_declaration>') fi;
  if t_sy = 23
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_operator_field_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_operator_field_declaration_0_0,EMPTY,'') fi;
    if t_sy = 55
    then
      # line: 431#
      name := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_operator_field_declaration_0_1[t_sy]=0 then testsymee(dont_skip,r_operator_field_declaration_0_1,EMPTY,'') fi;
    else error('"operator_symbol"',lnr);
    fi;
    n_nms := p_formals_of_procedure(dont_skip.disj(r_operator_field_declaration_0_2));
    # line: 433#
    loclist := concat(loclist, n_nms);
    fnms := copy(loclist);
    nf := fnms.size ;		# including 'self' #
    if nf > 2
    then	ermsg('operator has too many parameters', lnr)
    fi;
    if name ~= ''
    then	var intname := name || '.' || string(nf), entry, tab;
    if fieldentry(intname,clname,PROC,curproc,NOFETCH,NOSTORE)=True
    then	op_flds.append(intname)
    fi;
    tab := if nf = 1 then montab else dytab fi;
    entry := tab[name];
    if entry = undefined  # not existing ? #
    then    tab[name] :=
    [intname,nf,3,priofdef(nf),priogdef(nf),'*error*']
    elif entry[O_STATUS] < 0 # MONADIC or DYADIC decl ? #
    then	entry[O_STATUS] := 3;
    elif entry[O_STATUS] = 1 # user, global ? #
    then    fieldtab[intname].addglobf(symtab[intname][S_VALUE]);
    entry[O_STATUS] := 2
    fi
    fi;
    #*******************************************************#
    # A fieldentry and an entry in an operator table are	#
    # created. From the following possibilities all cases	#
    # are legal:						#
    # a. (entry undefined)					#
    #	the operator was never declared before;		#
    # b. (state < 0)					#
    #	the operator was declared in a MONADIC or	#
    #	DYADIC statement;				#
    # c. (state = 1)					#
    #	the operator was declared before as a global	#
    #	operator only;					#
    # d. (state = 2)					#
    #	the operator was declared in a another class	#
    #	and was also defined globally;			#
    # e. (state = 3)					#
    #	the operator was declared in another class.	#
    # In cases d and e nothing needs to be done. Note that	#
    # fieldentry checks for redeclarations.			#
    #*******************************************************#
    if f_operator_field_declaration_0_3_0[t_sy] = 1
    then
      e := p_expression(dont_skip.disj(r_operator_field_declaration_0_3_0_0));
    else
      p_empty(dont_skip.disj(r_operator_field_declaration_0_3_1_0));
      # line: 479#
      e := UNDEFINED;
    fi;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 481#
  curproc.complete(name, fnms, e);
  return(curproc);
);


proc  p_parenthesized_expression(dont_skip)
(
  var b ;
  if t_sy ~= 52 then testsym(s_52,dont_skip,'<parenthesized_expression>') fi;
  if t_sy = 52
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_parenthesized_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_parenthesized_expression_0_0,EMPTY,'') fi;
    b := p_block(dont_skip.disj(r_parenthesized_expression_0_1));
    if t_sy = 43
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('")"',lnr);
    fi;
  fi;
  # line: 887#
  return(b);
);


proc  p_primary(dont_skip)
(
  var se,su,u ;
  # line: 576#
  var m_sub, m_sel, a, p;
  if f_primary[t_sy]=0 then testsym(f_primary,dont_skip,'<primary>') fi;
  if f_primary[t_sy] = 1
  then
    u := p_unit(dont_skip.disj(r_primary_0_0));
    # line: 578#
    m_sub := may_sub; m_sel := may_sel;
    while f_primary_0_1[t_sy] = 1
    do
      if t_sy = 48
      then
        # line: 579#
        if m_sub = False
        then	ermsg('illegal subscription', lnr);
        m_sub := True
        fi;
        su := p_subscript(dont_skip.disj(r_primary_0_1_0_0));
        # line: 583#
        u := ARIND(u, su);
      elif t_sy = 45
      then
        # line: 585#
        if m_sel = False
        then	ermsg('illegal field selection', lnr);
        m_sel := True
        fi;
        se := p_select(dont_skip.disj(r_primary_0_1_1_0));
        # line: 589#
        u := FIELDSEL(u, se[0], se[1]);
      fi;
    od;
  fi;
  # line: 590#
  ndpush(u);
);


proc  p_procedure_field_declaration(dont_skip)
(
  var e,n_nms ;
  # line: 381#
  var name := '',
  nf := 0,
  fnms := '', nm;
  curproc := PROC_DECL(ClassProc);
  if t_sy ~= 24 then testsym(s_24,dont_skip,'<procedure_field_declaration>') fi;
  if t_sy = 24
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_procedure_field_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_procedure_field_declaration_0_0,EMPTY,'') fi;
    if t_sy = 53
    then
      # line: 387#
      name := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_procedure_field_declaration_0_1[t_sy]=0 then testsymee(dont_skip,r_procedure_field_declaration_0_1,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    n_nms := p_formals_of_procedure(dont_skip.disj(r_procedure_field_declaration_0_2));
    # line: 389#
    loclist := concat(loclist, n_nms);
    fnms := copy(loclist);
    nf := fnms.size - 1;		#excluding 'self' #
    if name ~= ''
    then 	if assoctab[name] = store_type
    then if nf ~= 1
    then ermsg('store assoc "' || name ||
    '" should have one parameter', lnr)
    fi
    elif assoctab[name] = fetch_type
    then if nf ~= 0
    then ermsg('fetch assoc "' || name ||
    '" cannot have parameters', lnr)
    fi
    fi;
    if fieldentry(name,clname,PROC,curproc,NOFETCH,NOSTORE) = True
    then	proc_flds.append(name);
    symentry(name, level-1, curproc)
    fi;
    fi;
    if f_procedure_field_declaration_0_3_0[t_sy] = 1
    then
      e := p_expression(dont_skip.disj(r_procedure_field_declaration_0_3_0_0));
    else
      p_empty(dont_skip.disj(r_procedure_field_declaration_0_3_1_0));
      # line: 410#
      e := UNDEFINED;
    fi;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 412#
  curproc.complete(name, fnms, e);
  if assoctab[name] ~= undefined
  then	if curproc.retcnt ~= 1
  then	ermsg('fetch or store association "' ||
  name || '" does not return value', lnr)
  fi
  fi;
  return(curproc);
);


proc  p_program_declaration(dont_skip)
(
  var e,fnms ;
  # line: 523#
  var name := '';
  curproc := PROC_DECL(Program);
  if t_sy ~= 25 then testsym(s_25,dont_skip,'<program_declaration>') fi;
  if t_sy = 25
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_program_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_program_declaration_0_0,EMPTY,'') fi;
    if t_sy = 53
    then
      # line: 527#
      name := sy;
      if symtab[name] ~= undefined
      then	ermsg('"' || name || '" redeclared',lnr)
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_program_declaration_0_1[t_sy]=0 then testsymee(dont_skip,r_program_declaration_0_1,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    fnms := p_formals_of_procedure(dont_skip.disj(r_program_declaration_0_2));
    # line: 532#
    loclist := copy(fnms);
    if fnms.size > 1
    then	ermsg('program can have at most one parameter', lnr)
    fi;
    if name ~= ''
    then	symentry(name, 0, curproc)
    fi;
    if f_program_declaration_0_3_0[t_sy] = 1
    then
      e := p_expression(dont_skip.disj(r_program_declaration_0_3_0_0));
    else
      p_empty(dont_skip.disj(r_program_declaration_0_3_1_0));
      # line: 540#
      e := UNDEFINED;
    fi;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    fi;
  fi;
  # line: 542#
  curproc.complete(name, fnms, e);
  return(curproc);
);


proc  p_return_expression(dont_skip)
(
  var e ;
  # line: 695#
  var n := 0;
  if f_return_expression[t_sy]=0 then testsym(f_return_expression,dont_skip,'<return_expression>') fi;
  if t_sy = 26
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_return_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_return_expression_0_0,EMPTY,'') fi;
    if t_sy = 52
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_return_expression_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_return_expression_0_1_0_0,EMPTY,'') fi;
      if f_return_expression_0_1_0_1_0[t_sy] = 1
      then
        e := p_expression(dont_skip.disj(r_return_expression_0_1_0_1_0_0));
        # line: 697#
        n := 1;
      else
        p_empty(dont_skip.disj(r_return_expression_0_1_0_1_1_0));
        # line: 699#
        e := undefined;
      fi;
      if t_sy = 43
      then
        nextsym;
        if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
      else error('")"',lnr);
      fi;
    else
      p_empty(dont_skip);
      # line: 699#
      e := undefined;
    fi;
    # line: 701#
    if curproc.retcnt = undefined
    then	curproc.retcnt := n
    elif curproc.retcnt ~= n
    then	ermsg('incompatible number of return values', lnr)
    fi;
    e := RETURN(e);
  elif t_sy = 16
  then
    # line: 708#
    e := FRETURN;
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  fi;
  # line: 709#
  return(e);
  #***************************************************************#
  # There is a slight deviation here from the syntax accepted	#
  # by the "formal" imlementation: this rule accepts "return"	#
  # as well as "return()", while the formal syntax only accepts	#
  # "return".							#
  #***************************************************************#
);


proc  p_scan_expression(dont_skip)
(
  var b,e ;
  if t_sy ~= 28 then testsym(s_28,dont_skip,'<scan_expression>') fi;
  if t_sy = 28
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_scan_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_scan_expression_0_0,EMPTY,'') fi;
    e := p_expression(dont_skip.disj(r_scan_expression_0_1));
    if t_sy = 15
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_scan_expression_0_2[t_sy]=0 then testsymee(dont_skip,r_scan_expression_0_2,EMPTY,'') fi;
    else error('"for"',lnr);
    fi;
    b := p_block(dont_skip.disj(r_scan_expression_0_3));
    if t_sy = 27
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"rof"',lnr);
    fi;
  fi;
  # line: 855#
  return(SCAN(e, b));
);


proc  p_select(dont_skip)
(
  var act ;
  # line: 598#
  var fname;
  act := [];
  if t_sy ~= 45 then testsym(s_45,dont_skip,'<select>') fi;
  if t_sy = 45
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_select_0_0[t_sy]=0 then testsymee(dont_skip,r_select_0_0,EMPTY,'') fi;
    if t_sy = 53
    then
      # line: 601#
      fname := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_select_0_1[t_sy]=0 then testsymee(dont_skip,r_select_0_1,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    if t_sy = 52
    then
      act := p_actuals(dont_skip);
    fi;
  fi;
  # line: 603#
  return([fname, act]);
);


proc  p_self(dont_skip)
(
  if t_sy ~= 29 then testsym(s_29,dont_skip,'<self>') fi;
  if t_sy = 29
  then
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  fi;
  # line: 683#
  if clname = '' then ermsg('"self" used outside class', lnr) fi;	
  return(SELF);
);


proc  p_size_definition(dont_skip)
(
  var d,s ;
  if t_sy ~= 52 then testsym(s_52,dont_skip,'<size_definition>') fi;
  if t_sy = 52
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_size_definition_0_0[t_sy]=0 then testsymee(dont_skip,r_size_definition_0_0,EMPTY,'') fi;
    s := p_expression(dont_skip.disj(r_size_definition_0_1));
    if t_sy = 44
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_size_definition_0_2[t_sy]=0 then testsymee(dont_skip,r_size_definition_0_2,EMPTY,'') fi;
    else error('","',lnr);
    fi;
    d := p_expression(dont_skip.disj(r_size_definition_0_3));
    if t_sy = 43
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('")"',lnr);
    fi;
  fi;
  # line: 904#
  return([s, d]);
);


proc  p_store_associations(dont_skip)
(
  # line: 366#
  var field;
  if t_sy ~= 30 & dont_skip[t_sy]=0 then testsymee(s_30,dont_skip,EMPTY, '') fi;
      if t_sy = 30
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_store_associations_0_0_0_0[t_sy]=0 then testsymee(dont_skip,r_store_associations_0_0_0_0,EMPTY,'') fi;
      if f_store_associations_0_0_0_1[t_sy]=0 then testsymdd(f_store_associations_0_0_0_1,dont_skip,r_store_associations_0_0_0_1,'"identifier" or "operator_symbol"') fi;
      while f_store_associations_0_0_0_1[t_sy] = 1
      do
        if f_store_associations_0_0_0_1_0_0[t_sy] = 1
        then
          if t_sy = 53
          then
            # line: 368#
            field := sy;
            nextsym;
            if dont_skip[t_sy]=0 & r_store_associations_0_0_0_1_0_0_0_0_0_0[t_sy]=0 then testsymee(dont_skip,r_store_associations_0_0_0_1_0_0_0_0_0_0,EMPTY,'') fi;
          elif t_sy = 55
          then
            # line: 368#
            field := sy;
            nextsym;
            if dont_skip[t_sy]=0 & r_store_associations_0_0_0_1_0_0_0_0_1_0[t_sy]=0 then testsymee(dont_skip,r_store_associations_0_0_0_1_0_0_0_0_1_0,EMPTY,'') fi;
          fi;
          if t_sy = 46
          then
            nextsym;
            if dont_skip[t_sy]=0 & r_store_associations_0_0_0_1_0_0_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_store_associations_0_0_0_1_0_0_0_1_0_0,EMPTY,'') fi;
            if t_sy = 53
            then
              # line: 370#
              storetab[field] := sy;
              assoctab[sy] := store_type;
              nextsym;
              if dont_skip[t_sy]=0 & r_store_associations_0_0_0_1_0_0_0_1_0_1[t_sy]=0 then testsymee(dont_skip,r_store_associations_0_0_0_1_0_0_0_1_0_1,EMPTY,'') fi;
            else error('"identifier"',lnr);
            fi;
          else
            p_empty(dont_skip.disj(r_store_associations_0_0_0_1_0_0_0_1_1_0));
            # line: 373#
            if field ~= undefined
            then	storetab[field] := '_s'
            fi;
          fi;
        fi;
        if t_sy = 44
        then
          nextsym;
          if f_store_associations_0_0_0_1_0_0[t_sy]=0 then testsymdd(f_store_associations_0_0_0_1_0_0,dont_skip,r_store_associations_0_0_0_1_0_1,'"identifier" or "operator_symbol"') fi;
        elif f_store_associations_0_0_0_1_0_0[t_sy] = 1
        then error('Separating ","',lnr);
        fi;
      od;
      if t_sy = 47
      then
        nextsym;
        if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
      else error('";"',lnr);
      fi;
    fi;
);


proc  p_subclass_declaration(dont_skip)
(
  # line: 334#
  var super;
  if t_sy ~= 31 & dont_skip[t_sy]=0 then testsymee(s_31,dont_skip,EMPTY, '') fi;
      if t_sy = 31
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_subclass_declaration_0_0_0_0[t_sy]=0 then testsymee(dont_skip,r_subclass_declaration_0_0_0_0,EMPTY,'') fi;
      if t_sy = 22
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_subclass_declaration_0_0_0_1[t_sy]=0 then testsymee(dont_skip,r_subclass_declaration_0_0_0_1,EMPTY,'') fi;
      else error('"of"',lnr);
      fi;
      if t_sy = 53
      then
        # line: 336#
        super := sy;
        do_subclass(super);
        nextsym;
        if dont_skip[t_sy]=0 & r_subclass_declaration_0_0_0_2[t_sy]=0 then testsymee(dont_skip,r_subclass_declaration_0_0_0_2,EMPTY,'') fi;
      else error('"identifier"',lnr);
      fi;
      if t_sy = 47
      then
        nextsym;
        if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
      else error('";"',lnr);
      fi;
    fi;
  # line: 339#
  return(super);
);


proc  p_subject(dont_skip)
(
  if t_sy ~= 32 then testsym(s_32,dont_skip,'<subject>') fi;
  if t_sy = 32
  then
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  fi;
  # line: 688#
  return(SUBJECT);
);


proc  p_subscript(dont_skip)
(
  var e ;
  if t_sy ~= 48 then testsym(s_48,dont_skip,'<subscript>') fi;
  if t_sy = 48
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_subscript_0_0[t_sy]=0 then testsymee(dont_skip,r_subscript_0_0,EMPTY,'') fi;
    e := p_expression(dont_skip.disj(r_subscript_0_1));
    if t_sy = 49
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"]"',lnr);
    fi;
  fi;
  # line: 594#
  return(e);
);
program  p_summer_program(args)
(
  var dont_skip := s_58;
  var nms,p ;
  # line: 29#
  var cnms := [], the_program := undefined, pname := args[0];
  if src := SOURCE(pname || '.sm', undefined) fails
  then	cant(pname || '.sm')
  fi;
  if f_er := file(pname || '.er', 'w') fails
  then	cant(pname || '.er');
  fi;
  init_scanner();
  init_tables();
  nextsym;
  if f_summer_program[t_sy]=0 & dont_skip[t_sy]=0 then testsymee(f_summer_program,dont_skip,EMPTY, '') fi;
      while f_summer_program[t_sy] = 1
    do
      if t_sy = 39
      then
        p_global_variable_declaration(dont_skip.disj(r_summer_program_0_0_0_0));
      elif t_sy = 4
      then
        nms := p_constant_declaration(dont_skip.disj(r_summer_program_0_0_1_0));
        # line: 38#
        cnms := concat(cnms, nms);
      elif t_sy = 24
      then
        p := p_global_procedure_declaration(dont_skip.disj(r_summer_program_0_0_2_0));
        # line: 45#
        src.decls.append(p);
      elif t_sy = 23
      then
        p := p_global_operator_declaration(dont_skip.disj(r_summer_program_0_0_3_0));
        # line: 45#
        src.decls.append(p);
      elif t_sy = 3
      then
        p := p_class_declaration(dont_skip.disj(r_summer_program_0_0_4_0));
        # line: 45#
        src.decls.append(p);
      elif t_sy = 20
      then
        p_monadic_symbol_declaration(dont_skip.disj(r_summer_program_0_0_5_0));
      elif t_sy = 7
      then
        p_dyadic_symbol_declaration(dont_skip.disj(r_summer_program_0_0_6_0));
      elif t_sy = 25
      then
        p := p_program_declaration(dont_skip.disj(r_summer_program_0_0_7_0));
        # line: 40#
        if the_program = undefined
        then	the_program := p
        else	ermsg('multiple program declaration', lnr)
        fi;
        src.decls.append(p);
      elif t_sy = 19
      then
        p_include_file(dont_skip.disj(r_summer_program_0_0_8_0));
      elif t_sy = 50
      then
        # line: 47#
        src.back_to_previous;
        nextsym;
        if dont_skip[t_sy]=0 & r_summer_program_0_0_9_0[t_sy]=0 then testsymee(dont_skip,r_summer_program_0_0_9_0,EMPTY,'') fi;
      fi;
    od;
  # line: 50#
  if the_program = undefined
  then	ermsg('program declaration missing', lnr)
  fi;
  src.back_to_previous | '';
  check_forward_references();
  if errcnt = 0 then
  var g;
  # program body := caseinit ; globinit ; program body #
  for g in globinit do caseinit.append(g) od;
  caseinit.append(the_program.body);
  the_program.body := SEMI(caseinit);
  if f_s := file(pname || '.s', 'w') fails
  then
  cant(pname || '.s')
  fi;
  prefix();
  exp_classes();
  exp_fields();
  for p in src.decls do p.generate_body od
  fi;
  remove(cnms);
  exp_terminate();
  if errcnt = 0 then stop(0) else stop(1) fi;
  if errcnt > 0
  then stop(1)
  fi;
);


proc  p_table_element(dont_skip)
(
  var e ;
  # line: 936#
  var laste, m, exprs := [];
  if f_table_element[t_sy]=0 then testsym(f_table_element,dont_skip,'<table_element>') fi;
  if f_table_element[t_sy] = 1
  then
    while f_table_element[t_sy] = 1
    do
      e := p_expression(dont_skip.disj(r_table_element_0_0_0_0));
      # line: 938#
      exprs.append(e);
      if t_sy = 46
      then
        nextsym;
        if f_expression[t_sy]=0 then testsymdd(f_expression,dont_skip,r_table_element_0_0_0_1,'<expression>') fi;
      elif f_expression[t_sy] = 1
      then error('Separating ":"',lnr);
      fi;
    od;
  fi;
  # line: 940#
  m := exprs.size;
  if m < 1 then
  ermsg('key(s) missing in table', lnr);
  laste := UNDEFINED
  else
  laste := exprs.delete
  fi;
  return([m, KEY(exprs, laste)]);
);


proc  p_table_element_tail(dont_skip)
(
  var e ;
  # line: 975#
  var exprs := [];
  if f_table_element_tail[t_sy]=0 then testsym(f_table_element_tail,dont_skip,'<table_element_tail>') fi;
  if f_table_element_tail[t_sy] = 1
  then
    while f_table_element_tail[t_sy] = 1
    do
      e := p_expression(dont_skip.disj(r_table_element_tail_0_0_0_0));
      # line: 977#
      exprs.append(e);
      if t_sy = 46
      then
        nextsym;
        if f_expression[t_sy]=0 then testsymdd(f_expression,dont_skip,r_table_element_tail_0_0_0_1,'<expression>') fi;
      elif f_expression[t_sy] = 1
      then error('Separating ":"',lnr);
      fi;
    od;
  fi;
  # line: 979#
  return(exprs);
);


proc  p_table_expression(dont_skip)
(
  var sd,ti ;
  # line: 915#
  var s, d;
  ti := [0,[]]; # number of table_elements; list of keys #
  if t_sy ~= 34 then testsym(s_34,dont_skip,'<table_expression>') fi;
  if t_sy = 34
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_table_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_table_expression_0_0,EMPTY,'') fi;
    if f_table_expression_0_1[t_sy]=0 then testsym(f_table_expression_0_1,dont_skip,'"(" or "["') fi;
    if t_sy = 52
    then
      sd := p_size_definition(dont_skip.disj(r_table_expression_0_1_0_0));
      if t_sy = 51
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_table_expression_0_1_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_table_expression_0_1_0_1_0_0,EMPTY,'') fi;
        ti := p_table_initialization(dont_skip);
      fi;
    elif t_sy = 48
    then
      ti := p_table_initialization(dont_skip);
    fi;
  fi;
  # line: 918#
  if sd = undefined then
  s := CONSTANT(0); d := UNDEFINED
  else
  s := sd[0]; d := sd[1]
  fi;
  return(TABINIT(s, d, ti[0], ti[1]));
);


proc  p_table_initialization(dont_skip)
(
  var te ;
  # line: 927#
  var tes := [], nel := 0;
  if t_sy ~= 48 then testsym(s_48,dont_skip,'<table_initialization>') fi;
  if t_sy = 48
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_table_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_table_initialization_0_0,EMPTY,'') fi;
    while f_table_initialization_0_1[t_sy] = 1
    do
      te := p_table_element(dont_skip.disj(r_table_initialization_0_1_0_0));
      # line: 929#
      nel := nel + te[0];
      tes.append(te[1]);
      if t_sy = 44
      then
        nextsym;
        if f_table_element[t_sy]=0 then testsymdd(f_table_element,dont_skip,r_table_initialization_0_1_0_1,'<table_element>') fi;
      elif f_table_element[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 49
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"]"',lnr);
    fi;
  fi;
  # line: 932#
  return([nel, tes]);
);


proc  p_test(dont_skip)
(
  var e ;
  if f_test[t_sy]=0 then testsym(f_test,dont_skip,'<test>') fi;
  if f_test[t_sy] = 1
  then
    e := p_expression(dont_skip.disj(r_test_0_0));
    if t_sy = 12
    then
      # line: 748#
      e := MONOP('~', e);
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    elif t_sy = 33
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    fi;
  fi;
  # line: 749#
  return(e);
);


proc  p_try_expression(dont_skip)
(
  var b,exprs ;
  # line: 861#
  var res, l := LINE();
  if t_sy ~= 36 then testsym(s_36,dont_skip,'<try_expression>') fi;
  if t_sy = 36
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_try_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_try_expression_0_0,EMPTY,'') fi;
    exprs := p_expression_list(dont_skip.disj(r_try_expression_0_1));
    if t_sy = 38
    then
      # line: 863#
      inloop := inloop + 1;
      nextsym;
      if dont_skip[t_sy]=0 & r_try_expression_0_2_0_0[t_sy]=0 then testsymee(dont_skip,r_try_expression_0_2_0_0,EMPTY,'') fi;
      b := p_block(dont_skip.disj(r_try_expression_0_2_0_1));
      # line: 865#
      res := TRY(l, exprs, b);
      inloop := inloop - 1;
    else
      p_empty(dont_skip.disj(r_try_expression_0_2_1_0));
      # line: 868#
      res := TRY(l, exprs, undefined);
    fi;
    if t_sy = 41
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"yrt"',lnr);
    fi;
  fi;
  # line: 870#
  return(res);
  #***************************************************************#
  # The code generated for the two forms of the try-statement	#
  # (with or without until) is nearly identical. The value	#
  # delivered is in the first case the value delivered by the	#
  # expression following 'until', and in the second case the value#
  # delivered by the succeeding expression in the list following	#
  # 'try'. This is signalled to the code-generator by the two	#
  # different operator forms.					#
  #***************************************************************#
);


proc  p_unit(dont_skip)
(
  var e ;
  if f_unit[t_sy]=0 then testsym(f_unit,dont_skip,'<unit>') fi;
  if f_unit_0[t_sy] = 1
  then
    e := p_constant(dont_skip);
    # line: 624#
    may_sub := False; may_sel := True;
  elif t_sy = 53
  then
    e := p_identifier_or_call(dont_skip);
    # line: 625#
    may_sub := may_sel := True;
  elif t_sy = 52
  then
    e := p_parenthesized_expression(dont_skip);
    # line: 625#
    may_sub := may_sel := True;
  elif t_sy = 17
  then
    e := p_if_expression(dont_skip);
    # line: 625#
    may_sub := may_sel := True;
  elif t_sy = 15
  then
    e := p_for_expression(dont_skip);
    # line: 623#
    may_sub := False; may_sel := False;
  elif t_sy = 42
  then
    e := p_array_expression(dont_skip);
    # line: 625#
    may_sub := may_sel := True;
  elif t_sy = 34
  then
    e := p_table_expression(dont_skip);
    # line: 625#
    may_sub := may_sel := True;
  elif t_sy = 48
  then
    e := p_array_or_table_initialization(dont_skip);
    # line: 625#
    may_sub := may_sel := True;
  elif t_sy = 2
  then
    e := p_case_expression(dont_skip);
    # line: 625#
    may_sub := may_sel := True;
  elif t_sy = 40
  then
    e := p_while_expression(dont_skip);
    # line: 623#
    may_sub := False; may_sel := False;
  elif f_unit_10[t_sy] = 1
  then
    e := p_return_expression(dont_skip);
    # line: 623#
    may_sub := False; may_sel := False;
  elif t_sy = 28
  then
    e := p_scan_expression(dont_skip);
    # line: 625#
    may_sub := may_sel := True;
  elif t_sy = 36
  then
    e := p_try_expression(dont_skip);
    # line: 625#
    may_sub := may_sel := True;
  elif t_sy = 0
  then
    e := p_assert_expression(dont_skip);
    # line: 625#
    may_sub := may_sel := True;
  elif t_sy = 29
  then
    e := p_self(dont_skip);
    # line: 625#
    may_sub := may_sel := True;
  elif t_sy = 32
  then
    e := p_subject(dont_skip);
    # line: 625#
    may_sub := may_sel := True;
  fi;
  # line: 627#
  return(e);
  #***************************************************************#
  # The formal syntax allows a subscript and a field selection	#
  # following each unit. In some cases, it is however easy to	#
  # detect that subscription and/or selection are illegal: e.g.	#
  # after a while-do expression, which does not yield a value,	#
  # both subscription and selection are illegal; a constant can	#
  # not be subscripted. Therefore, unit returns an array which	#
  # denotes  whether subscription (0) and field selection (1)	#
  # are allowed.							#
  #***************************************************************#
);


proc  p_while_expression(dont_skip)
(
  var b,t ;
  # line: 805#
  var l := LINE();
  inloop := inloop + 1;
  if t_sy ~= 40 then testsym(s_40,dont_skip,'<while_expression>') fi;
  if t_sy = 40
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_while_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_while_expression_0_0,EMPTY,'') fi;
    t := p_test(dont_skip.disj(r_while_expression_0_1));
    if t_sy = 6
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_while_expression_0_2[t_sy]=0 then testsymee(dont_skip,r_while_expression_0_2,EMPTY,'') fi;
    else error('"do"',lnr);
    fi;
    b := p_block(dont_skip.disj(r_while_expression_0_3));
    if t_sy = 21
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"od"',lnr);
    fi;
  fi;
  # line: 808#
  inloop := inloop - 1;
  return(WHILEDO(l, t, b));
);
