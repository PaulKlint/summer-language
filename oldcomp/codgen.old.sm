#****************************************************************
*								*
* SUMMER compiler phase 2 -- codegeneration.			*
*								*
* The codegenerator consists of two completely independent	*
* subparts:							*
*	- an expander from ic code to assembler			*
*	- the codegenerator proper which transforms		*
*	  parsetrees into ic code.				*
*								*
* The interface between these two subparts is as follows:	*
* The expander provides procedures of the form exp_xxx, where	*
* "xxx" stands for some special case. The sequence of calls 	*
* should be:							*
*	expinit							*
*	exp_classes0()						*
*	exp_classes1(line)	(zero or more times)		*
*	exp_classes2()						*
*	exp_fields0()						*
*	exp_fields(line)	(zero or more times)		*
*	exp_fields2()						*
*								*
* followed by an arbitrary number of calls to:			*
*								*
*	exp_op0, exp_op1, exp_glob, exp_real, exp_lab, exp_error*
*	exp_line, exp_proc, exp_procend, exp_subr, exp_dclstr	*
*	exp_call, exp_dclglob, exp_newclass, exp_fld, exp_asfld	*
*								*
* or calls to the procedure "exp(opcode, alist)" which 		*
* represents the general case, i.e. exp selects the appropriate	*
* subcase itself.						*
*								*
* Usage: codgen [-S] [-EXP] [-IC] prefixfile programfile	*
*								*
* prefixfile contains assembly language equates used to		*
* synchronize the compiler and the interpreter.			*
* The machine type is determined by the first line of the       *
* prefix file. (i.e. 'VAX' or 'PDP11')                         *
* programfile contains the user program				*
* -S	suppresses some symbolic info to reduce size		*
* -EXP	performs expansion only					*
* -IC	produces an additional ic file				*
*								*
****************************************************************#

#************************************************************************
* VAX = 0	: pdp11 code						*
* VAX = 1	: VAX code						*
************************************************************************#

var   VAX	:= 1;
var   long;

var   squeeze   := 0;	# 1 => no line instructions, no local symbols #
var   sqtab     := table(100, undefined);
			# strings to be discarded #
var   dot 	:= 0,
      bufmax    := 20,
      buf	:= array(bufmax, 0),

      nglob	:= 0,
      globtab	:= table(350, -1),
      globval	:= array(350, 'nil'),
      globname  := array(350, ''),

      classtab  := table(20, -1),
      nclasses := 0,
      dt_last,

      fdtab     := table(40, -1),
      fldproctab := table(40, undefined),
      nfldproc   := 0,
      realtab   := table(40, undefined),
      nreal     := 0,
      stdclass  := [
		# Note: order must be the same as in summer.h #
		'scan_string',	2,
		'interval',	3
		],
      nfields := 0,

      inprogram	:= 0,
      f_ic,
      f_s,
      digit	:= '0123456789',
      nl	:= '\n',
      letter	:= 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

proc experror(opcode, a) put('>> ', opcode, ' ', a, '\n');

proc bflush()
( if dot > 0 then
     var i := 1;
     f_s.put('.byte ', buf[0]);
     while i < dot do f_s.put(',', buf[i]); i := i + 1 od;
     f_s.put('\n');
     dot := 0;
  fi;
);

proc dec(n)
( if VAX = 0 then
     return(string(n) || '.')
  else
     scan string(n)
     for
         (span('0') | '') &	# remove leading zero's which set base 8 in as #
	 if rpos(0) then return('0') else return(rtab(0)) fi
     rof
  fi
);

proc comment(s)
( return(if VAX = 0 then ' / ' else ' # ' fi || s)
);
proc word(opcode)
( bflush();
  f_s.put(opcode, '\n');
);

proc code1(opcode)
( if dot = bufmax then bflush() fi;
  buf[dot] := opcode;
  dot := dot + 1
);

proc code2(opcode, a)
( if dot + 1 >= bufmax then bflush() fi;
  buf[dot] := opcode;
  buf[dot + 1] := a;
  dot := dot + 2
);

proc code3(opcode, a)(
  code1(opcode);
  if VAX = 1 then
	bflush();
	f_s.put(';.long ', a, '\n')
  else
     code1('[' || a || ']\\>8');
     code1('[' || a || ']&377');
  fi
);

proc genlab(lab)
( if VAX = 1 then
     bflush();
     f_s.put('.long ', lab, '\n');
  else
     code1('[' || lab || '^0]\\>8');
     code1('[' || lab || '^0]&0377');
  fi
);

proc exp_2(opcode, a)(
  var n;

  n := integer(a);
  if n < 256 then code2(opcode, dec(a)) else code3('x' || opcode, dec(a)) fi
);

proc exp_glob(opcode, a)(
  var n := globtab[a];
  if f_ic ~= undefined then f_ic.put(opcode, '\t', a, nl) fi;
  if er ~= 0 then return fi;
  if n < 0 then n := exp_dclglob('dclglob', a) fi;
  if n < 256 then code2(opcode, dec(n)) else code3('x' || opcode, dec(n)) fi
);

proc exp_dclglob(opcode, a)
( var n;
  if f_ic ~= undefined then f_ic.put(opcode, '\t', a, nl) fi;
  if er ~= 0 then return(-1) fi;
  if (n := globtab[a]) < 0 then
     n := globtab[a] := nglob;
     globname[nglob] := a;
     nglob := nglob + 1
  fi;
  return(n)
);
proc enter_real(r)
( var n;
  if (n := realtab[r]) = undefined then
     n := realtab[r] := nreal;
     nreal := nreal + 1;
  fi;
  return('RCON' || string(n))
);

proc enter_proc(name)
( var n;
  if (n := globtab[name]) = -1 then
     globtab[name] := nglob;
     globname[nglob] := name;
     globval[nglob] := 'P' || string(nglob);
     n := nglob;
     nglob := nglob + 1
  fi;
  return(n)
);

proc enter_fldproc(name)
( var n;
  if (n := fldproctab[name]) = undefined then
     n := fldproctab[name] := [nfields - 1, nfldproc];
     nfldproc := nfldproc + 1;
   fi;
   return('FLDP' || string(n[1]));
);


proc exp_call(opcode, a)(
  var nargs, idx;

  if f_ic ~= undefined then f_ic.put(opcode, '\t', a, nl) fi;
  if er ~= 0 then return fi;
  if opcode = 'gcall' then
     if ~ scan a for nargs := rtab(0) rof then
        experror(opcode, a); return
     fi;
     code2(opcode, dec(nargs));
  else
     if ~ scan a for a:=break(',') & lit(',') &
               nargs := rtab(0) rof then
        experror(opcode, a); return
     fi;
     idx := enter_proc(a);
     if idx < 256 then
        code2('call', dec(idx))
     else
        code3('xcall', dec(idx))
     fi;
     code1(dec(nargs));
  fi
);

proc spread(s)
( var t := '', c;
 
  scan s
  for
    while c := move(1)
    do
       if c = '\\' then c := '\\\\'
       elif c = '''' then c := '\\'''
       fi;
       t := t || '''' || c || if rpos(0) then '' else ',' fi
    od
  rof;
  return(t);
);

proc makeoct(s)
( var r := '', t;

  scan s
  for
      while t := break(digit)
      do
         r := r || t || '0' || span(digit)
      od
  rof;
  return(r)
);

proc genstr(lab, nchar, str)
( bflush();
  if VAX = 0 then
     f_s.put('.even\n', lab, '=.\n')
  else
     f_s.put(lab, ':\n')
  fi;
  f_s.put(long, 'dt_string\n');
  f_s.put(long, dec(nchar), '\n');
  if str.size < 60 then
     f_s.put('.byte ', str, '\n');
  else
     scan str
     for var c;
         while c := break(',') & move(1)
         do  f_s.put('.byte ', c, '\n')
         od;
         f_s.put('.byte ', rtab(0), '\n')
     rof
  fi;
  if VAX = 0 then
     if (nchar%2)*2 ~= nchar then f_s.put('\t.even\n') fi;
  fi
);
proc exp_dclstr(opcode, a)(
  var lab, n;

  if f_ic ~= undefined then f_ic.put(opcode, '\t', a, nl) fi;
  if er ~= 0 then return fi;
  if ~ scan a
  for
     lab := break(',') & lit(',') &
     n := span(digit) & lit(',') &
     a := makeoct(rtab(0))
  rof
  then
     experror(opcode, a); return
  fi;
  if (squeeze = 1 & sqtab[lab] = 1) fails then
	genstr(lab, integer(n), a)
  fi
);

proc exp_proc(opcode, a)(
  var name, locnames,  nformals, nlocals, lino, endlino;
  var plab, fldlab, d;

  if f_ic ~= undefined then f_ic.put(opcode, '\t', a, nl) fi;
  if er ~= 0 then return fi;
  if ~ scan a for
     name := break(',') & lit(',') &
     locnames := break(',') & lit(',') &
     nformals := span(digit) & lit(',') &
     nlocals := span(digit) & lit(',') &
     lino := span(digit) & lit(',') &
     endlino := span(digit) & rpos(0)
     rof
  then experror(opcode, a); return fi;
  if VAX = 0 then f_s.put('.even\n') fi;
  if opcode = 'program' then
     inprogram := 1;
     f_s.put('.globl\t_program\n');
     f_s.put('_program:');
  fi;
  if (d := fldproctab[name]) ~= undefined then
     fldlab := 'FLD' || string(d[0]);
     plab := 'FLDP' || string(d[1]);
  else
     fldlab := 'nil';
     plab   := 'P' || string(enter_proc(name))
  fi;
  f_s.put(plab, ':\n');
  f_s.put(long, 'dt_proc\n');
  f_s.put(long, fldlab, comment('fld pointer'), '\n');
  f_s.put(long, dec(nformals), comment('nformals'), '\n');
  f_s.put(long, dec(nlocals), comment('nlocals'), '\n');
  f_s.put(long, dec(integer(nformals) + integer(nlocals)), comment('ntot'), '\n');
  f_s.put(long, dec(lino), comment('lino'), '\n');
  f_s.put(long, dec(endlino), comment('end lino'), '\n');
  if squeeze = 1 then
	sqtab[locnames] := 1;
	locnames := 'nil';
  fi;
  f_s.put(long, locnames, comment('local names'), '\n');
  f_s.put(long, dec(0), comment('freq'), '\n');
  f_s.put(long, dec(0), comment('prof'), '\n');
  dot := 0;
);

proc exp_procend(opcode, a)(

  if f_ic ~= undefined then f_ic.put(opcode, '\t', a, nl) fi;
  if er ~= 0 then return fi;
  if inprogram = 0 then
     exp_2('return', 0)
  else
     inprogram := 0;
  fi;
  code1(if VAX = 0 then 'halt' else 'ihalt' fi);
  bflush();
);

proc exp_subr(opcode, alist)(
  # kludge: avoid redefinition of 'real' #
  if alist = 'real' then return fi;
  if f_ic ~= undefined then f_ic.put(opcode, '\t', alist, nl) fi;
  if er ~= 0 then return fi;
  exp_subr1(opcode, alist);
);

proc exp_subr1(opcode, alist)
(
  if VAX = 0 then f_s.put('.even\n') fi;
  enter_proc(alist);
  f_s.put(globval[globtab[alist]], ':\n');
  f_s.put(long, 'dt_subr\n');
  f_s.put(long, 'nil', comment('fld pointer'), '\n');
  alist := '__' || alist;
  f_s.put('\t.globl\t', alist, '\n');
  f_s.put(long, alist, '\n');
  f_s.put(long, dec(0), comment('freq and prof'), '\n');
  f_s.put(long, dec(0), '\n');
);

proc exp_classes0()
( var i;

  if f_ic ~= undefined then f_ic.put('classes\n') fi;
  f_s.put('.globl _class_sizes\n_class_sizes:\n');
  for nclasses in interval(0, dt_last, 1)
  do f_s.put(long, '\t0\n') od;
  nclasses := nclasses + 1;
  for i in interval(0, stdclass.size - 1, 2)
  do
     f_s.put(long, dec(stdclass[i + 1]), '\n');
     classtab[stdclass[i]] := nclasses;
     nclasses := nclasses + 1;
  od;
);

proc exp_classes1(line)
( var cname, csize;

  if f_ic ~= undefined then f_ic.put(line, '\n') fi;
  if ~ scan line for
            cname := break(',') & move(1) &
	    csize := integer(rtab(0))
       rof
  then
	experror(line, ''); return
  fi;
  f_s.put(long, dec(csize), '\n');
  classtab[cname] := nclasses;
  nclasses := nclasses + 1;
);

proc exp_classes2()
( var i, cname;

  if f_ic ~= undefined then f_ic.put('endclasses\n') fi;
  f_s.put('.globl _class_names\n_class_names:\n');
  for i in interval(0, nclasses - 1, 1)
  do
    if i <= dt_last then
       f_s.put(long, '\t0\n')
    else
       f_s.put(long, '\tCN', i, '\n')
    fi;
  od;

  for cname in classtab.index
  do
     genstr('CN' || string(classtab[cname]), cname.size , spread(cname));
  od
);

proc fieldterm ()
  f_s.put(long, dec(-1), comment('** terminating element'), '\n');

proc exp_fields0()
( var lzero     := long || '0;',
      lzm1      := lzero || long || dec(-1) || ';',
      stdfld1   := table(30, undefined) init [
		'next' :	'.globl _f_next;_f_next:\n' ||
				long || 'dt_array;' ||
				lzm1 ||
				long || '_Anext;' ||
				long || '_storeer\n' ||

				long || 'dt_table;' ||
				lzm1 ||
				long || '_Tnext;' ||
				long || '_storeer\n' ||

				long || 'dt_string;' ||
				lzm1 ||
				long || '_Snext;' ||
				long || '_storeer\n' ||

				long || 'dt_bits;' ||
				lzm1 ||
				long || '_Bnext;' ||
				long || '_storeer\n' ||

				long || 'dt_interval;' ||
				lzm1 ||
				long || '_IVnext;' ||
				long || '_storeer\n',

		'text':		long || 'dt_scan_string;' ||
				long || '0;' ||
				long || '0;' ||
				long || '0;' ||
				long || '_storeer\n',

		'cursor':	long || 'dt_scan_string;' ||
				long || '0;' ||
				long || '1;' ||
				long || '0;' ||
				long || '_storeer\n',
		'update':	'.globl _f_update;_f_update:\n' ||
				long || 'dt_array;' ||
				lzm1 ||
				long || '_Aupdate;' ||
				long || '_storeer\n' ||

				long || 'dt_table;' ||
				lzm1 ||
				long || '_Tupdate;' ||
				long || '_storeer\n' ||

				long || 'dt_bits;' ||
				lzm1 ||
				long || '_Bupdate;' ||
				long || '_storeer\n',

		'retrieve':	'.globl _f_retrieve;_f_retrieve:\n' ||
				long || 'dt_array;' ||
				lzm1 ||
				long || '_Aretrieve;' ||
				long || '_storeer\n' ||

				long || 'dt_table;' ||
				lzm1 ||
				long || '_Tretrieve;' ||
				long || '_storeer\n' ||

				long || 'dt_string;' ||
				lzm1 ||
				long || '_Sretrieve;' ||
				long || '_storeer\n' ||

				long || 'dt_bits;' ||
				lzm1 ||
				long || '_Bretrieve;' ||
				long || '_storeer\n',

		'index':	'.globl _f_index;_f_index:\n',
		'size':		'.globl _f_size;_f_size:\n',
		'conj':		'.globl _f_conj;_f_conj:\n',
		'compl':	'.globl _f_compl;_f_compl:\n',
		'disj':		'.globl _f_disj;_f_disj:\n',
		'put':		'.globl _f_put;_f_put:\n',
		'get':		'.globl _f_get;_f_get:\n',
		'close':	'.globl _f_close;_f_close:\n',
		'center':	'.globl _f_center;_f_center:\n',
		'left':		'.globl _f_left;_f_left:\n',
		'repl':		'.globl _f_repl;_f_repl:\n',
		'replace':	'.globl _f_replace;_f_replace:\n',
		'reverse':	'.globl _f_reverse;_f_reverse:\n',
		'right':	'.globl _f_right;_f_right:\n',
		'substr':	'.globl _f_substr;_f_substr:\n',
		'sort':		'.globl _f_sort;_f_sort:\n',
		'+.2':		'.globl _f_add;_f_add:\n',
		'-.2':		'.globl _f_sub;_f_sub:\n',
		'-.1':		'.globl _f_neg;_f_neg:\n',
		'*.2':		'.globl _f_mul;_f_mul:\n',
		'/.2':		'.globl _f_div;_f_div:\n',
		'%.2':		'.globl _f_idiv;_f_idiv:\n',
		'||.2':		'.globl _f_conc;_f_conc:\n',
		'=.2':		'.globl _f_eq;_f_eq:\n',
		'~=.2':		'.globl _f_ne;_f_ne:\n',
		'>.2':		'.globl _f_gt;_f_gt:\n',
		'>=.2':		'.globl _f_ge;_f_ge:\n',
		'<.2':		'.globl _f_lt;_f_lt:\n',
		'<=.2':		'.globl _f_le;_f_le:\n',
		'lit':		'.globl _f_lit;_f_lit:\n',
		'move':		'.globl _f_move;_f_move:\n',
		'pos':		'.globl _f_pos;_f_pos:\n',
		'rpos':		'.globl _f_rpos;_f_rpos:\n',
		'tab':		'.globl _f_tab;_f_tab:\n',
		'rtab':		'.globl _f_rtab;_f_rtab:\n',
		'any':		'.globl _f_any;_f_any:\n',
		'span':		'.globl _f_span;_f_span:\n',
		'break':	'.globl _f_break;_f_break:\n',
		'bal':		'.globl _f_bal;_f_bal:\n',
		'find':		'.globl _f_find;_f_find:\n'
		   ];

   stdfld := stdfld1;
);

var first := 1, fldname, is_stdfld, stdfld;
proc exp_fields1(line)
( var cname, off, fetch_assoc, store_assoc, i, fldpref,
      ty, basename,
      typetag	:= table(10, '') init [
		'integer':	'I',
		'real':		'R',
		'string':	'S',
		'array':	'A',
		'table':	'T',
		'file':		'F',
		'bits':		'B',
		'scan_string':	'SC',
		'interval':	'IV'
		];
     if f_ic ~= undefined then f_ic.put(line, '\n') fi;
     scan line for
	if cname := break(',') & move(1) &
	   ty    := break(',') & move(1) &
	   off   := break(',') & move(1) &
	   fetch_assoc := break(',') & move(1) &
	   store_assoc := (break(' \t') | rtab(0))
	then
	   if cname ~= '~global' then
	      var classtype := classtab[cname];
	      classtype := if classtype = -1 then 'dt_' || cname
			   else dec(classtype) fi;
	      f_s.put(long, '\t', classtype, ';');
	      if ty = '~var' then
		 f_s.put(long, dec(0), ';');	# fld_type #
		 f_s.put(long, dec(off));	# fld_offset #
	      elif ty = '~proc' then
		 var p;
		 if off = fldname & is_stdfld = 1 then
		    p := '_' || typetag[cname] || fldname
	         else
		    p := enter_fldproc(off)
		 fi;
		 f_s.put(long, p, ';');	# fld_type #
		 f_s.put(long, dec(-1));	# fld_offset #
	      else
	         experror(line, '')
	      fi
	   else

	      f_s.put(long, dec(-2), ';');	# fld_class = -2 implies
						  global alias #
	      f_s.put(long, dec(0), ';');	# fld_type #
	      f_s.put(long, dec(-1), ';');	# fld_offset #
	   fi;
	   if fetch_assoc = '~nil' then fetch_assoc := '_fetcher'
	   elif fetch_assoc = '~simple' then fetch_assoc := '0'
	   elif fetch_assoc = fldname & is_stdfld = 1 then
              fetch_assoc := '_' || typetag[cname] || fldname
	   else
              fetch_assoc := enter_fldproc(fetch_assoc);
	   fi;
	   if store_assoc = '~nil' then store_assoc := '_storeer'
	   elif store_assoc = '~simple' then store_assoc := '0'  else
              store_assoc := enter_fldproc(store_assoc);
	   fi;
	   f_s.put('; ', long, fetch_assoc, '; ', long, store_assoc, '\n');
	 elif tab(0) & lit('fld') & span(' \t') & fldname := rtab(0) then
	   if first = 1 then
	      first := 0
	   else
	      fieldterm();
	   fi;
	   fdtab[fldname] := nfields;
	   genstr('FLDN' || string(nfields), fldname.size , spread(fldname));
	   f_s.put('FLD', nfields, ':\n');
	   nfields := nfields + 1;
	   if (fldpref := stdfld[fldname]) ~= undefined then
	      f_s.put(fldpref);
	      stdfld[fldname] := undefined;
	      is_stdfld := 1;
	   else
	      is_stdfld := 0
           fi;
	 else
	   experror(line, '') & return('')
         fi
     rof;
   return(stdfld);
);
proc exp_fields2()
( var fldname, i;

  if f_ic ~= undefined then f_ic.put('endfields\n') fi;
  fieldterm();
  for fldname in stdfld.index
  do var fldpref;
     if (fldpref := stdfld[fldname]) ~= undefined then
	fdtab[fldname] := nfields;
	fldname := scan fldname for break('.') | fldname rof;
        genstr('FLDN' || string(nfields), fldname.size , spread(fldname));
	f_s.put('FLD', nfields, ':\n', fldpref);
	fieldterm();
	nfields := nfields + 1
     fi;
  od;
  fieldterm();
  f_s.put('.globl _fields\n_fields:\n');
  for i in interval(0, nfields - 1, 1)
  do f_s.put(long, '\tFLD', i, '\n') od;
  f_s.put('.globl _fieldnames; _fieldnames:\n');
  for i in interval(0, nfields - 1, 1)
  do f_s.put(long, '\tFLDN', i, '\n') od;
);

proc exp_fld(opcode, a)
( var fld, ifld, nargs, nret;

  if f_ic ~= undefined then f_ic.put(opcode, '\t', a, nl) fi;
  if er ~= 0 then return fi;
  scan a for
    fld := break(',') & move(1) &
    nargs := rtab(0)
  rof | experror(opcode, a);
  if (ifld := fdtab[fld]) = -1 then experror(opcode, a) fi;
  code1(opcode);
  code1(dec(ifld));
  code1(dec(nargs));
);

proc exp_asfld(opcode, a)
( var fld, ifld, nret;

  if f_ic ~= undefined then f_ic.put(opcode, '\t', a, nl) fi;
  if er ~= 0 then return fi;
  scan a for
     fld := break(',') & move(1) &
     nret := span(digit)
  rof | experror(opcode, a);
  if (ifld := fdtab[fld]) = -1 then experror(opcode, a) fi;
  code1(opcode);
  code1(dec(ifld));
  code1(dec(nret));
);


proc cant(name)(
  put('can''t open ''',  name, '''\n');
  stop(1)
);

proc prefix(prename) (
  var inp, line;

  if ~( inp := file(prename,'r')) then cant(prename) fi;

  line := inp.get ;
  if line = 'VAX' then
     VAX := 1;
     long := '.long '
  elif line = 'PDP11' then
     VAX := 0;
     long := ''
  else
     experror('', 'wrong prefix file');
     stop(1)
  fi;
  while line := inp.get 
  do
    f_s.put(line, '\n');
    scan line
    for
       lit(if VAX = 0 then 'dt_last\t= ' else '.set\tdt_last,' fi) &
       dt_last := integer(span(digit))
     rof | '';
  od;
  inp.close ;
  f_s.put('.data\n');
);
proc expterminate()
( var i, g_er, g_in, g_out;
   if f_ic ~= undefined then f_ic.close fi;
   exp_subr1('dclsubr', 'real');
   if VAX = 0 then f_s.put('.even\n') fi;
  if squeeze = 1 then f_s.put('.globl _squeeze\n') fi;
   f_s.put('.globl _nclasses;_nclasses:');
   f_s.put(long, dec(if nclasses = 0 then dt_last + 1 else nclasses fi), '\n');
   f_s.put('.globl _nfields; _nfields:', long, dec(nfields), '\n');
   f_s.put('.globl _globals\n');
   f_s.put('.globl _eglobals\n');
   f_s.put('.globl _globnames\n');
   f_s.put('.globl _stand_in\n');
   f_s.put('.globl _stand_out\n');
   f_s.put('.globl _stand_er\n');
   g_er := exp_dclglob('', 'stand_er');
   g_in := exp_dclglob('', 'stand_in');
   g_out := exp_dclglob('', 'stand_out');
   f_s.put('_globals:');
   i := 0;
   while i < nglob
   do
      if i = g_er then f_s.put('_stand_er:')
      elif i = g_in then f_s.put('_stand_in:')
      elif i = g_out then f_s.put('_stand_out:')
      fi;
      f_s.put(long, globval[i], '\n'); i := i + 1 od;
   f_s.put('_eglobals:\n');
   i := 0;
   while i < nglob
   do
      genstr('N' || string(i), globname[i].size , spread(globname[i]));
      i := i + 1
   od;
   i := 0;
   f_s.put('_globnames:\n');
   while i < nglob do f_s.put(long, 'N', i, '\n'); i := i + 1 od;
   for i in realtab.index 
   do
	genstr('RCON' || string(realtab[i]), i.size , spread(i))
   od;
   f_s.close ;
);

proc exp_op0(opcode)
( if f_ic ~= undefined then f_ic.put(opcode, nl) fi;
  if er = 0 then code1(opcode) fi;
);

proc exp_op1(opcode, alist)
( if f_ic ~= undefined then f_ic.put(opcode, '\t', alist, nl) fi;
  if er = 0 then exp_2(opcode, alist) fi;
);

proc exp_lab(opcode, alist)
( if f_ic ~= undefined then f_ic.put(opcode, '\t', alist, nl) fi;
  if er ~= 0 then return fi;
  if opcode = 'lab' then
     bflush();
     f_s.put(alist, if VAX = 1 then ':\n' else '=.\n' fi);
  elif opcode = 'gocase' then
     code3(opcode, dec(globtab[alist]))
  else
     code1(opcode);
     genlab(alist)
  fi
);
proc exp_error(opcode, alist)
( if f_ic ~= undefined then f_ic.put(opcode, '\t', alist, nl) fi;
  if er ~= 0 then return fi;
  code2(opcode, 'er_' || alist)
);

proc exp_line(opcode, alist)
( if f_ic ~= undefined then f_ic.put(opcode, '\t', alist, nl) fi;
  if er ~= 0 then return fi;
  if opcode = 'line' & squeeze = 0 then exp_2(opcode, alist)
  elif opcode = 'aline' & squeeze = 0 then code3(opcode, dec(alist)) fi;
);
proc exp_newclass(opcode, alist)
( var t;
  if f_ic ~= undefined then f_ic.put(opcode, '\t', alist, nl) fi;
  if er ~= 0 then return fi;
  if (t := classtab[alist]) = -1 then
     experror(opcode, alist)
  else
     exp_2(opcode, t)
  fi
);
proc exp_real(opcode, alist)
( if f_ic ~= undefined then f_ic.put(opcode, '\t', alist, nl) fi;
  if er ~= 0 then return fi;
  code1('undef');
  code1('load');
  genlab(enter_real(alist));
  exp_call('call', 'real,2')
);

proc exp(opcode, alist)
(
	case opcode of
	'num':
	'int':
	'loc':
	'asloc':
	'rev':
	'xar':
	'cloc':
	'ascloc':
	'return':
			exp_op1(opcode, alist),
	'glob':
	'asglob':
			exp_glob(opcode, alist),
	'real':		exp_real(opcode, alist),
	'add':
	'sub':
	'mul':
	'div':
	'idiv':
	'neg':
	'void':
	'freturn':
	'conc':
	'newrc':
	'oldrc':
	'resrc':
	'gofl':
	'oldfl':
	'newsubj':
	'oldsubj':
	'subject':
	'nullstr':
	'undef':
	'self':
	'eq':
	'ne':
	'lt':
	'gt':
	'le':
	'ge':
	'asind':
	'ind':
	'tabinit':
			exp_op0(opcode),
	'lab':
	'newfl':
	'load':
	'go':
	'gocase':
			exp_lab(opcode, alist),
	'error':	exp_error(opcode, alist),
	'arinit':
	'tabelem':
			code3(opcode, dec(alist)),
	'aline':
	'line':
			exp_line(opcode, alist),
	'program':
	'proc':		exp_proc(opcode, alist),
	'procend':	exp_procend(opcode, alist),
	'subr':
			exp_subr(opcode, alist),
	'dclstr':	exp_dclstr(opcode, alist),
	'gcall':
	'call':		exp_call(opcode, alist),
	'dclglob':	exp_dclglob(opcode, alist),
	'newclass':
			exp_newclass(opcode, alist),
	'ifld':
	'fld':		exp_fld(opcode, alist),
	'iasfld':
	'asfld':	exp_asfld(opcode, alist),
	default:
			experror(opcode, alist)
	esac
);

proc expinit(args)(
 var nargs := args.size, i;

 if nargs < 2 then experror('', 'Too few args'); stop(1) fi;

 prname := args[nargs - 1];
 if f_s := file(prname || '.s', 'w') fails then cant(prname || '.s') fi;
 prefix(args[nargs - 2]);
 for i in interval(0, nargs - 3, 1)
 do if args[i] = '-S' then squeeze := 1
    elif args[i] = '-IC' then
         if f_ic := file(prname || '.ic', 'w') fails then cant(prname || '.ic') fi;
    elif args[i] = '-EXP' then
	 var line, f_icexp;
         if f_icexp := file(prname || '.ic', 'r') fails then cant(prname || '.ic') fi;
	 if (line := f_icexp.get) ~= 'classes' then
	    experror('file does not begin with "classes"', '')
	 fi;
         exp_classes0();
	 while (line := f_icexp.get) ~= 'endclasses' do exp_classes1(line) od;
	 exp_classes2();
	 if (line := f_icexp.get) ~= 'fields' then
	    experror('file does not field decls', '')
	 fi;
	 exp_fields0();
	 while (line := f_icexp.get) ~= 'endfields' do exp_fields1(line) od;
	 exp_fields2();
	 while line := f_icexp.get
	 do scan line
	    for
	        exp(break(' \t'), span(' \t') & rtab(0)) | exp(line, '')
	    rof
	 od;
         expterminate();
	 stop(0)
    else
	 experror('Unrecognized argument ', args[i]);
	 stop(1)
    fi
  od;
);
proc putcode1(opcode)
( if f_ic ~= undefined then f_ic.put(opcode, '\n') fi;
  if er = 0 then exp(opcode, '') fi
);

proc putcode2(opcode, args)
( if f_ic ~= undefined then f_ic.put(opcode, '\t', args, '\n') fi;
  if er = 0 then exp(opcode, args) fi
);

#************************************************************************
*************************************************************************
*									*
*		C O D E G E N E R A T O R				*
*									*
*************************************************************************
************************************************************************#


var	f_im,			# file produced by the parser #
	f_gl,			# file containing initialized globals #
	f_st,			# file containing string constants #
#	f_ic,			  file that will contain the final code #
	prname,			# program name #
	clname,			# name of current class #
	er := 0,		# to stop code generation #
	lastline := 1,		# line number in source file #
	usedsubrs := '',	# used build in procedures #
	skiptab := table(10,''),  # contains ic-code for complex operands #
	symtab := table(100, undefined),
	fieldtab := table(50, undefined),

	flstack := array(10,''),  # faillabel stack #
	flstp := -1,	  	# faillabel stackpointer #
	flsize := 10,
	lab := 0,		# label counter #
	flab := 0;		# faillabel counter #

const	empty := '',
	newl := '\n',
	tabsym := '\t',
	sc   := ',',
	svoid := 'void',
	NIL   := 'nil',
	cl := 'call',
	CASE := 'case';


var	opc	:= table (20, '') init [
			'-1':		'neg',
			'+':		'add',
			'-2':		'sub',
			'*':		'mul',
			'/':		'div',
			'%':		'idiv',
			'||':		'conc',
			'<':		'lt',
			'<=':		'le',
			'>':		'gt',
			'>=':		'ge',
			'=':		'eq',
			'~=':		'ne'
                ];
	# the opcodes for the various operators #

proc error(m)
(	put(string(lastline).right(5, ' '), ': ', m, newl);
	er := 1
);

proc comerr(m)
(	put(string(lastline).right(5, ' '), ': compiler error; ', m, newl);
	stop(-1)
);




proc inspect(rval, expr)
(	if rval > 0
	then	error(expr || ': value required')
	elif rval < 0
	then	error('illegal assignment to ' || expr)
	fi
);

# dummy declarations for exp interface procedures follow:
proc putcode1(opcode)
	if er = 0
	then	f_ic.put(opcode, newl)
	fi;

proc putcode2(opcode, args)
	if er = 0
	then	f_ic.put(opcode, tabsym, args, newl)
	fi;
#

proc splitcode(line)
	scan line
	for	putcode2(break(tabsym), lit(tabsym) & rtab(0)) |
		putcode1(rtab(0))
	rof;
		# calls putcode2 for lines of format opcode-tab-args #
		# and putcode1 otherwise.			     #

proc void(aval)
(	if aval ~= 0
	then	exp_op0(svoid)
	fi
);


proc voidcall(rval)
	if rval = 0
	then	exp_op0(svoid)
	fi;

proc abs(rval)
	return(if rval < 0 then -rval else rval fi);

proc nextflab()		return('F' || string(flab := flab + 1));

proc nextlab()		return('L' || string(lab := lab + 1));

proc opcode(op_)		exp_op0(opc[op_]);

proc label(l)		exp_lab('lab', l);

proc gofl()		exp_op0('gofl');

proc newrc()		exp_op0('newrc');

proc oldrc()		exp_op0('oldrc');

proc resrc()		exp_op0('resrc');

proc go(l)		exp_lab('go', l);

proc ercode(c)		exp_error('error', c);

proc pushfl(f)
if er = 0
then	if flstp >= flsize - 1
	then(	var new := array(flsize + 10, ''),
		    i   := 0;

		for i in flstack.index 
		do new[i] := flstack[i] od;
		flsize := flsize + 10;
		flstack := new
	    )
	fi;
	flstack[flstp := flstp + 1] := f
fi;

proc popfl()
if er = 0
then	if flstp < 0
	then	comerr('pop tried from empty flstack')
	else	flstack[flstp] := '';
		flstp := flstp - 1
	fi
fi;

proc newfl(f)
if er = 0
then	if flstp = -1 | ~(flstack[flstp] = f = NIL)
	then	exp_lab('newfl', f)
	fi;
	pushfl(f)
fi;

proc oldfl()
if er = 0
then	if flstp <= 0 | ~(flstack[flstp] = flstack[flstp-1] = NIL)
	then	exp_op0('oldfl')
	fi;
	popfl()
fi;

proc make_decls()
(	var dcl, line, name, glcnt, i;

	if ~(dcl := file(prname || '.dc','r'))
	then	error('cannot open ' || prname || '.dc');
		stop(1)
	fi;
	scan dcl.get for lit('glcnt:\t') & glcnt := integer(rtab(0)) rof;
	while (line := dcl.get ) ~= 'endsyms'
	do	scan line
		for	name := break(':') &
			lit(':\t') &
			symtab[name] :=  rtab(0)
		rof
	od;
	if dcl.get ~= 'classes' then comerr('dcl does not contain classes') fi;
	exp_classes0();
	while (line := dcl.get ) ~= 'endclasses'
	do	exp_classes1(line) od;
	exp_classes2();
	if dcl.get ~= 'fields' then comerr('dcl does not contains fields') fi;
	exp_fields0();
	line := dcl.get ;		# field ... #
	while line ~= 'endfields'
	do	var x;

		exp_fields1(line);
		name := scan line for lit('fld\t') & rtab(0) rof;
		line := dcl.get ;
		fieldtab[name] := x := 
			[scan line for break(sc) rof, undefined];
		exp_fields1(line);
		while	scan (line := dcl.get )
			for x[1] := [break(sc), undefined] rof
		do exp_fields1(line); x := x[1] od
	od;
	exp_fields2();
	for i in interval(1, glcnt, 1)
	do	exp_dclglob('dclglob', '_' || string(i)) od;
	dcl.close 
);






proc treatclass(rval, name, entry)
(	var tail;

	exp_op0('undef');
	if scan entry
	   for lit('ab') & tail := rtab(0) rof
	then	symtab[name] := entry := 'ap' || tail;
		usedsubrs := usedsubrs || name || sc
	fi;
	if scan entry
	   for	lit('ap') &
		if ~lit('1')
		then	error(name || ': argument list missing')
		else	exp_call(cl, name || ',1');
			voidcall(rval)
		fi &
		return(abs(rval))
	   rof
	then	# ok #
	else	comerr('illegal symentry ' || entry || ' for ' || name)
	fi
);

proc treatglob(rval, name, entry)
(	var tail;

	if scan entry
	   for lit('gb') & tail := rtab(0) rof
	then	symtab[name] := entry := 'gp' || tail;
		usedsubrs := usedsubrs || name || sc
	fi;
	if scan entry
	   for  lit('g') &
		(  lit('p') &
		   if ~lit('0')
		   then error(name || ': argument list missing')
		   else exp_call(cl, name || ',0');
			voidcall(rval)
		   fi &
   		   return(abs(rval))
		 | rpos(0) &
		   if rval = 1
		   then	exp_glob('glob', name);
	   		return(1)
		   elif rval = -1
		   then	exp_glob('asglob', name);
			return(-1)
		   else	inspect(rval, 'global'); return(rval)
		   fi
		)
	   rof
	then	# ok #
	else	comerr('illegal symtab entry for ' || name || ': ' || entry)
	fi
);

proc treatcloc(rval, v)
(	if rval = -1
	then	exp_op0('self');
		exp_asfld('iasfld', v || ',1');
		return(-1)
	else	exp_op0('self');
		exp_fld('ifld', v || ',1');
		voidcall(rval);
		return(rval)
	fi
);

proc classvar(rval)
(	var v, entry;

	v := break(sc) &
	lit(sc) &
	entry := symtab[v] &
	if entry = undefined then comerr('no symtab entry for ' || v) fi &
	return(treatclass(rval, v, entry))
);

proc globvar(rval)
(	var v, entry;

	v := break(sc) &
	lit(sc) &
	entry := symtab[v] &
	if entry = undefined then comerr('no symtab entry for ' || v) fi &
	return(treatglob(rval, v, entry))
);



proc clocvar(rval)
(	var v;

	v := break(sc) &
	lit(sc) &
	return(treatcloc(rval, v))
);

proc identify()
(	var nm, entry, e, t;

	nm := break(sc) &
	lit(sc) &
	e := entry := fieldtab[nm] &
	while entry ~= undefined
	do	if entry[0] = clname
		then	return(['c', nm, entry])
		else	entry := entry[1]
		fi
	od &
	entry := symtab[nm] &
	if entry ~= undefined
	then	if scan entry for lit('a') rof
		then	return(['a', nm, entry])
		else	return(['g', nm, entry])
		fi
	elif e ~= undefined
	then	return(['w', nm, ''])
	else	comerr('unknown not identifiable')
	fi
);

proc unknown(rval)
(	var nm, entry, t;

	[t, nm, entry] := identify() &
	if t = 'a'
	then	return(treatclass(rval, nm, entry))
	elif t = 'g'
	then	return(treatglob(rval, nm, entry))
	elif t = 'c'
	then	return(treatcloc(rval, nm))
	elif t = 'w'
	then	exp_op0('subject');
		if rval = -1 then exp_asfld('asfld', nm || ',1')
			     else exp_fld('fld', nm || ',1')
		fi;
		voidcall(rval);
		return(rval)
	else	comerr('unexpected unknown')
	fi
);

proc locvar(rval)
(	var v;

	v := break(sc) &
	lit(sc) &
        if rval = 1 
	then	exp_op1('loc', v);
		return(1)
	elif rval = -1 
	then	exp_op1('asloc', v);
		return(-1)
	else	inspect(rval, 'local'); return(rval)
	fi
);

proc str(rval)
(	var s;

	s := ('S'|| break(sc)) &
	lit(sc) &
	if rval = 1 
	then	exp_lab('load', s);
		return(1)
	else	inspect(rval, 'string'); return(rval)
	fi
);

proc int(rval)
(	var n;

	n := break(sc) &
	lit(sc) &
	if rval = 1 
	then	exp_op1('int', n);
		return(1)
	else	inspect(rval, 'integer'); return(rval)
	fi
);

proc realnum(rval)
(	var r;

	r := break(sc) &
	lit(sc) &
	if rval = 1
	then	exp_real('real', r);
		return(1)
	else	inspect(rval, 'real'); return(rval)
	fi
);

proc nullstr(rval)
	lit(sc) &
	if rval = 1 
	then	exp_op0('nullstr');
		return(1)
	else	inspect(rval, 'string'); return(rval)
	fi;

proc fret(rval)
	lit(sc) &
	exp_op0('freturn') &
	inspect(rval, 'freturn') &
	return(rval);
                        # hence "if t then freturn else x fi := 3" is illegal #

proc undef(rval)
	lit(sc) &
	if rval = 1 
	then	exp_op0('undef') &
		return(1)
	else	inspect(rval, 'undefined'); return(rval)
	fi;

proc subj(rval)
	lit(sc) &
	if rval = 1
	then	exp_op0('subject');
		return(1)
	else	inspect(rval, 'subject'); return(rval)
	fi;

proc clself(rval)
	lit(sc) &
	if rval = 1
	then	exp_op0('self') &
		return(1)
	else	inspect(rval, 'self'); return(rval)
	fi;

proc lineinc()
(	var i;

	lit('i') & i := break(sc) & lit(sc) &
	lastline := lastline + integer(i) &
	exp_line('line', i)
);

proc monop(lab,rval,op_)
(	var aval;

	treecode(empty,1) &
	opcode(op_) &
	return(1)
);

proc opnot(lab,rval,op_)
(	var f,l,aval;

	newfl(if lab = empty then f := nextflab() else f := lab fi) &
	l := nextlab() &
	aval := treecode(l,0) &
	void(aval) & inspect(rval, 'not') &
	label(l) & oldfl() & gofl() &
	if lab = empty then label(f) fi &
	return(0)
);

		# ~ cannot deliver a value: if ~p succeeds, p has failed #
		# and hence cannot have delivered a value.		 #

proc assign(lab,rval,op_)
(	var aval;

	treecode(empty, 1) &
	aval := treecode(empty, -1) &
	if aval ~= -1
	then	error('illegal asignment: destination not address')
	fi &
	return(1)
);


proc dyop(lab,rval,op_)
	treecode(empty,1) & treecode(empty,1) &
	opcode(op_) &
	return(1);

proc match(lab,rval,op_)
(	var aval;

	treecode(empty,1) &
	exp_op0('newsubj') &
	aval := treecode(empty,rval) &
	exp_op0('oldsubj') &
	return(aval)
);

proc opand(lab,rval,op_)
(	var aval;

	aval := treecode(empty,0) & void(aval) &
	aval := treecode(lab,rval) &
	return(aval)
);

proc opor(lab,rval,op_)
(	var f,l,aval;

	newfl(f := nextflab()) &
	if lab = empty then l := nextlab() else l := lab fi &
	aval := treecode(empty,rval) &
	if   rval = 0 then void(aval)
	elif rval = -1 then rval := aval
	fi &
	oldfl() & go(l) & label(f) &
	aval := treecode(l,rval) &
	if   rval = 0 then void(aval)
	elif rval = -1 then rval := aval
	fi &
	if lab = empty then label(l) fi &
	return(rval)
);

proc whiledo(lab,rval,op_)
(	var f,l1,l2,aval;

	lineinc() &
	label(l1:= nextlab() ) &
	newfl(f := nextflab()) &
	aval := treecode(empty,0) & void(aval) &
	oldfl() & 
	aval := treecode(l1,0) & void(aval) &
	go(l1) & label(f) & inspect(rval, 'whiledo') &
	return(0)
);

proc ifthen(lab,rval,op_)
(	var f, aval;

	newfl(f := nextflab()) &
	lineinc() &
	aval := treecode(empty,0) & void(aval) &
	oldfl() &
	aval := treecode(empty,0) & void(aval) &
	label(f) & inspect(rval, 'ifthen') &
	return(0)
);

proc ifelse(lab,rval,op_)
(	var f,l,aval;

	lineinc() &
	newfl(f := nextflab()) &
	aval := treecode(empty,0) & void(aval) &
	oldfl() &
	if lab = empty then l := nextlab() else l := lab fi &
	aval := treecode(l,rval) &
	if   rval = 0 then void(aval)
	elif rval = -1 then rval := aval
	fi &
	go(l) & label(f) &
	aval := treecode(l,rval) &
	if rval = 0 then void(aval) fi  &
	if lab = empty then label(l) fi &
	return(rval)
);

proc forloop(lab,rval,op_)
(	var name, lg1, lg2, var1, var2, t, e, f, l1, l2, aval;

	lineinc() &
	(  lit('l') & lg1 := 'loc'  & var1 := break(sc)
	 | lit('g') & lg1 := 'glob' & var1 := break(sc)
	) & lit(sc) &
	if er = 0
	then	exp_op0('undef') &
		putcode2('as' || lg1, var1) &
		exp_op0(svoid)
	fi &
	treecode(empty, 1) &
	(  lit('l') & lg2 := 'loc'  & var2 := break(sc)
	 | lit('g') & lg2 := 'glob' & var2 := break(sc)
	) & lit(sc) &
	putcode2('as' || lg2, var2) & exp_op0(svoid) &
	t := move(1) &
	if t = 'w'
	then	[t,name,e] := identify();
		if t ~= 'g' & t ~= 'c'
		then	error('illegal control variable in forloop')
		fi
	else	name := break(sc) & lit(sc)
	fi &
	label(l1:= nextlab ()) &
	newfl(f := nextflab()) &
	putcode2(lg2, var2) &
	putcode2(lg1, var1) &
	exp_fld('fld', 'next,2') &
	exp_op1('xar', '2') &
	if   t = 'l' then exp_op1('asloc', name)
	elif t = 'c' then exp_op0('self') & exp_asfld('iasfld', name || ',1')
	elif t = 'g' then exp_glob('asglob', name)
	else comerr('in forloop')
	fi & 
	exp_op0(svoid) &
	putcode2('as' || lg1, var1) &
	exp_op0(svoid) &
	oldfl() &
	aval := treecode(l1,0) & void(aval) &
	go(l1) & label(f) & inspect(rval, 'forloop') &
	return(0)
);


proc try_yrt(lab, rval, op_)
(	var f, l, n, i, aval,
	    rv := if op_ = 'try' then rval else 0 fi;

	lineinc() &
	lit('n') &
	n := integer(break(sc)) & lit(sc) &
	newrc() & l := nextlab() &
	for i in interval(1, n, 1)
	do	newfl(f := nextflab()) &
		aval := treecode(empty, rv) &
		if   rv = 0 then void(aval)
		elif rv < 0 then error('illegal assignment to try')
		fi &
		go(l) & label(f) &
		resrc()
	od &
	gofl() & label(l) &
	if op_ = 'try'
	then	lit(sc)
	else	aval := treecode(empty, rval) &
		if   rval = 0 then void(aval)
		elif rval < 0 then error('illegal assignment to try')
		fi
	fi &
	oldfl() & oldrc() &
	return(rval)
);



proc assertion(lab,rval,op_)
(	var aval, l, f;

	newfl(f := nextflab()) &
	l := nextlab() &
	aval := treecode(l, rval) &
	oldfl() & go(l) & 
	label(f) & ercode('assert') &
	label(l) &
	return(aval)
);

proc arind(lab,rval,op_)
	treecode(empty,1) & treecode(empty,1) &
	if rval = -1
	then	exp_op0('asind');
		return(-1)
	else	exp_op0('ind');
		return(1)
	fi;


proc opret(lab,rval,op_)
(	var f;

	if lit(sc)
	then	exp_op1('return', 0)
	else	newfl(f:=nextflab()) &
		treecode(empty,1) &
		oldfl() &
		exp_op1('return', 1) &
		label(f) &
		exp_op0('freturn')
	fi &
	inspect(rval,'return') &
	return(0)
);

proc caseclause(lab, rval, op_)
(	var nm, n, lout, aval, l;

	lineinc() &
	treecode(empty, 1) &
	lit('g') & nm := break(sc) & lit(sc) &
	exp_lab('gocase', nm) &
	lit('n') & n := integer(break(sc)) & lit(sc) &
	lout := nextlab() &
	(	var i;

		for i in interval(1,n,1)
		do	l := break(sc) & lit(sc) &
			label(l) &
			aval := treecode(empty, rval) &
			if   rval = 0 then void(aval)
			elif rval = -1 then rval := aval
			fi &
			go(lout)
		od
	) &
	l := break(sc) & lit(sc) &
	label(l) &
	if lit(sc)
	then	ercode(CASE)
	else	aval := treecode(empty, rval) &
		if   rval = 0 then void(aval)
		elif rval = -1 then rval := aval
		fi
	fi &
	label(lout) &
	return(rval)
);


proc semi(lab,rval,op_)
(	var n, i, aval;

	lit('n') &
	n := integer(break(sc)) & lit(sc) &
	newfl(NIL) &
	for i in interval(1, n-1, 1)
	do	aval := treecode(empty,0) &
		void(aval)
	od &
	oldfl() &
	return(treecode(lab, rval))
);

proc acall(rval, name, entry, nargs)
(	var nexp, tail;

	if scan entry
	   for lit('ab') & tail := rtab(0) rof
	then	symtab[name] := entry := 'ap' || tail;
		usedsubrs := usedsubrs || name || sc
	fi &
	scan entry
	for	lit('ap') & nexp := integer(span(digit)) rof &
	if nexp ~= nargs+1
	then	error(name || ' called with wrong number of arguments')
	fi &
	exp_call(cl, name || sc || string(nexp)) &
	voidcall(rval) &
	return(abs(rval))
);

proc gcall(rval, name, entry, nargs)
(	var tail, nexp;

	if scan entry for lit('gb') & tail := rtab(0) rof
	then	symtab[name] := entry := 'gp' || tail;
		usedsubrs := usedsubrs || name || sc
	fi &
	scan entry
	for	  (lit('gp') | lit('ap')) &
		  nexp := (integer(span(digit)) | lit('?') & nargs)
		| lit('g') & rpos(0) &
		  error(name || ' called while not procedure') &
		  return(abs(rval))
	rof &
	if nexp ~= nargs
	then	error(name || ' called with wrong number of arguments')
	fi &
	exp_call(cl, name || sc || string(nexp)) &
	voidcall(rval) &
	return(abs(rval))
);

proc c_call(rval, name, entry, nargs)
(	var nrets, tail;

	exp_fld('ifld', name || sc || string(nargs+1)) &
	voidcall(rval) &
	return(abs(rval))
);

proc ocall(rval, name, nargs)
(	var f := fieldtab[name];

	if f ~= undefined
	then	exp_fld('fld', name || sc || string(nargs))
	else	exp_call(cl, name || sc || string(nargs))
	fi &
	voidcall(rval) &
	return(abs(rval))
);

proc scall(rval, name, nargs)
(	exp_fld('fld', name || sc || string(nargs+1)) &
	voidcall(rval) &
	return(abs(rval))
);

proc call(lab,rval,op_)
(	var nargs := 0, t, name, entry;

	t := move(1) &
	if t = 'w'
	then	[t, name, entry] := identify()
	else	name := break(sc) & lit(sc) &
		if   t = 'a' | t = 'g'
		then	entry := symtab[name]
		elif t = 'c'
	        then    entry := fieldtab[name] &
	                while entry ~= undefined & entry[0] ~= clname
	                do      entry := entry[1] od;
		fi
	fi &
	if   t = 'a'
	then	exp_op0('undef')
	elif t = 'c'
	then	exp_op0('self')
	elif t = 'w'
	then	exp_op0('subject')
	fi &
	lit('n') &
	nargs := integer(break(sc)) & lit(sc) &
	(	var i;
		for i in interval(1,nargs,1)
	 	do treecode(empty,1) od
	) &
	return(if   t = 'a' then acall(rval, name, entry, nargs)
	       elif t = 'g' then gcall(rval, name, entry, nargs)
	       elif t = 'c' then c_call(rval, name, entry, nargs)
	       elif t = 'o' then ocall(rval, name, nargs)
	       elif t = 'w' then scall(rval, name, nargs)
		else	rval
	       fi
	      )
);

proc field(lab, rval, op_)
(	var name, nargs;

	lit('w') & name := break(sc) & lit(sc) &
	if fieldtab[name] = undefined
	then	error('non existing field ' || name || ' selected')
	fi &
	lit('n') & nargs := integer(break(sc)) & lit(sc) &
	(	var i;

		for i in interval(1,nargs,1)
		do	treecode(empty, 1) od
	) &
	if rval = -1
	then	if nargs = 1
		then exp_asfld('asfld', name || ',1') &
			return(-1)
		else	return(1)
		fi
	else	exp_fld('fld', name || sc || string(nargs)) &
		voidcall(rval) &
		return(rval)
	fi
);


proc arinit(lab,rval,op_)
(	var n;

	lit('n') &
	n := integer(break(sc)) & lit(sc) &
	if rval >= 0
	then	var i;

		for i in interval(1,n+1,1)
		do treecode(empty, 1) od &
		(  lit('n0,') & exp_op1('int', n)
		 | treecode(empty,1)
		) &
	        putcode2('arinit', n) &
		return(1)
	else	var i, aval;

		exp_op1('xar', n);
		for i in interval(1,n,1)
		do	aval := treecode(empty, -1) &
			if aval >= 0
			then	error('illegal assignment in tuple')
			fi &
			if i ~= n then void(aval) fi
		od &
		if ~lit('u,n0,')
		then	error('illegal assignment to array');
			rtab(0)
		fi &
		return(-1)
	fi
);

         # tabelem matches one sequence 'key1:...keym: v  #
         # in a table initialisation                      #

proc tabelem(lab,rval,op_)
(	var m;

	lit('n') &
	m := integer(break(sc)) & lit(sc) &
	(	var i;
		for i in interval(1, m+1, 1)
		do treecode(empty, 1) od
	) &
						# expr and m keys #
        putcode2('tabelem', m) &
	return(1)
);

proc tabinit(lab,rval,op_)
(	var n,sumk;

	lit('n') &
	sumk := integer(break(sc)) & lit(sc) &
	treecode(empty,1) &
	(  lit('n0,') & exp_op1('int', sumk)
	  | treecode(empty,1)
	) &
	exp_op0('tabinit') &
	lit('n') &
	n := integer(break(sc)) & lit(sc) &
	(	var i;
		for i in interval(1,n,1)
		do treecode(empty,1) od
	) &				# must be tabelem #
	return(1)
);

proc taberr(l,r,o)
(	comerr('node_case indexed with undefined index ' || o);
	return(undefined)
);





   # node_case contains the patterns according to which each ope-   #
   # rator generates code.                                     #

proc node_case(lab,rval,op_)
return( case op_ of
		'-1' :		monop(lab, rval, op_),
		'+'  :
		'-2' :
		'*'  :
		'/'  :
		'%'  :
		'||' :
		'<'  :
		'<=' :
		'>'  :
		'>=' :
		'='  :
		'~=' :		dyop(lab,rval,op_),
		'~'  :		opnot(lab,rval,op_),
		':=' :		assign(lab,rval,op_),
		'?'  :		match(lab,rval,op_),
		'&'  :		opand(lab,rval,op_),
		'|'  :		opor(lab,rval,op_),
		'wd' :		whiledo(lab,rval,op_),
		'ift':		ifthen(lab,rval,op_),
		'ife':		ifelse(lab,rval,op_),
		'fr' :		forloop(lab,rval,op_),
		'try':
		'tru':		try_yrt(lab,rval,op_),
		'as' :		assertion(lab,rval,op_),
		'ind':		arind(lab,rval,op_),
		'rt' :		opret(lab,rval,op_),
		'cs' :		caseclause(lab,rval,op_),
		';'  :		semi(lab,rval,op_),
		'cl' :
		'clo':		call(lab,rval,op_),
		'fld':		field(lab,rval,op_),
		'ar' :		arinit(lab,rval,op_),
		'key':		tabelem(lab,rval,op_),
		'tb' :		tabinit(lab,rval,op_),
		default:	taberr(lab,rval,op_)
	esac
);


proc leave_case(leave, rval)
return( case leave of
		'a':	classvar(rval),
		'b':	subj(rval),
		'c':	clocvar(rval),
		'f':	fret(rval),
		'g':	globvar(rval),
		'l':	locvar(rval),
		'm':	clself(rval),
		'n':	int(rval),
		'r':	realnum(rval),
		'S':	str(rval),
		'u':	undef(rval),
		'w':	unknown(rval),
		'z':	nullstr(rval),
		default:	undefined
	esac
);



proc treecode(lab,rval)
(	var leave, lproc, op_, aval, sklab;

	if leave := move(1) &
	   (aval := leave_case(leave, rval)) ~= undefined
	 | sklab := leave || break(sc) & lit(sc) &
	   if skiptab[sklab] = ''
	   then	comerr('undefined sklab ' || sklab)
	   elif scan skiptab[sklab]
		for	op_ := break(tabsym) & lit(tabsym) &
			aval := node_case(lab,rval,op_) &
			rpos(0)
		rof
	   then skiptab[sklab] := ''
	   else comerr('incomplete match of treecode on ' || skiptab[sklab])
	   fi
	then return(aval)
	else comerr('treecode fails')
	fi
);

proc labpat()
(	var sklab, stat;

	sklab := (lit('L') || break(':')) & lit(':\t') &
	stat := rtab(0) &
	if skiptab[sklab] ~= ''
	then comerr('label ' || sklab || ' in skiptab redefined')
	else skiptab[sklab] := stat
	fi
);

proc globdecl()
(	var name;

	lit('G:\t') & name := rtab(0) &
	exp_dclglob('dclglob', name)
);

proc varinit()
(	var l, aval;

	lit('I:\t') &
	lastline := integer(break(sc)) & lit(sc) &
	exp_line('aline', lastline) &
	aval := treecode(empty,0) & void(aval) &
	lastline := integer(break(sc)) & lit(sc) &
	exp_line('aline', lastline)
);

proc procedure()
(	var classdecl, heading, returns, aval, name, i;

	(  lit('P:\t') & classdecl := 0
	 | lit('C:\t') & classdecl := 1
	) &
	returns := integer(break(tabsym)) & lit(tabsym) &
	heading := break(tabsym) & lit(tabsym) &
	exp_proc('proc', heading) &
	(	var i := 0;
		scan heading
		for	name := break(sc) & lit(sc) &
			for i in interval(1,3,1)
			do break(sc) & lit(sc) od;
			lastline := integer(break(sc))
		rof
	) &
	if classdecl = 1
	then	var ll := lastline, line;
		newfl(NIL);
		exp_newclass('newclass', clname);
		exp_op1('asloc', 0);
		exp_op0(svoid);
		while (line := f_im.get ) ~= 'CLASSEND'
		do	while scan line for labpat() rof
			do line := f_im.get od;
			if ~scan line for varinit() rof
			then	comerr('class init error on ' || line)
			fi
		od;
		lastline := ll;
		oldfl();
		exp_line('aline', ll)
	fi &
	aval := treecode(empty,0) &
	void(aval) &
	if classdecl = 1
	then	exp_op1('loc', 0);
		exp_op1('return', 1);
		clname := undefined
	fi &
	if returns ~= 0 then ercode('ret') fi &
   	exp_procend('procend', returns) &
	skiptab := table(10,'')
);

proc programme()
(	var	heading, aval, line, ll, f_cs;

	lit('M:\t') & heading := break(tabsym) & lit(tabsym) &
        exp_proc('program', heading) &
	(	var i := 0;
		scan heading
		for	for i in interval(1,4,1)
			do break(sc) & lit(sc) od;
			ll := integer(break(sc))
		rof
	) &
	if ~(f_cs := file(prname || '.cs','r'))
	then	comerr('cannot open ' || prname || '.cs');
		stop(1)
	fi &
	while line := f_cs.get do splitcode(line) od &
	f_cs.close &
	if ~(f_gl := file(prname || '.gl','r'))
	then	comerr('can''t open ' || prname || '.gl');
		stop(1)
	fi &
	newfl(NIL) &
	while line := f_gl.get 
	do	while scan line for labpat() rof
		do line := f_gl.get od;
		if ~ scan line for varinit() rof
		then comerr('unrecognizable line ' || line)
		fi
	od &
	oldfl() &
	lastline := ll &
	exp_line('aline', ll) &
	aval := treecode(empty,0) &
	void(aval) &
	exp_procend('procend', 0) &
	skiptab := table(10, '')
);


program codgen(a)
(	var line;

	expinit(a);	# defines prname #
	make_decls();
	if ~(f_im := file(prname || '.im','r'))
	then	comerr('scan2 cannot open ' || prname || '.im');
		stop(1)
	fi;
	while   line := f_im.get
	do	if scan line
		   for	lit('CLASS:\t') & 
			clname := break(sc) & lit(sc)
		   rof
		then	line := f_im.get 
		fi;
		while scan line for labpat() rof
		do line := f_im.get od;
		if ~ scan line
		     for globdecl() | procedure() | programme() rof
		then comerr('unrecognizable line ' || line)
		fi
	od;
	if er = 0
	then	scan usedsubrs
		for	while exp_subr('subr', break(sc))
			do lit(sc) od
		rof;
		f_st := file(prname || '.st','r')&
		while line := f_st.get 
		do splitcode(line) od
	fi;
	expterminate();
	if er ~= 0 then stop(1) fi
)
