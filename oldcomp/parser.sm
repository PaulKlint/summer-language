# used files:
-r-xr-xr-x  1 paulk      133120 Oct  9 23:43 /userfs1/summer/paulk/sys/pgen/pg
-rw-r--r--  1 paulk        1641 Jan  7  1982 /userfs1/summer/paulk/sys/pgen/pglib
-rw-r--r--  1 paulk       28966 Feb 16  1982 parser.syn
-rw-r--r--  1 paulk       14081 Feb 16  1982 parser.ns
#
const
	lower := 'abcdefghijklmnopqrstuvwxyz',
	upper := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
	digit := '0123456789',
	ASCII := ' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';

var
	lnr := 0, sy, t_sy, line := scan_string(' '), errcnt := 0;

proc SET(syms)
(	var i, b := bits(SETSIZE,0);

	for i in syms
	do
		b[i] := 1;
	od;
	return(b);
);


proc UN2(s1,s2)
(	
	return(s1.disj(s2))
);


proc UN3(s1,s2,s3)
(
	return((s1.disj(s2)).disj(s3))
);


proc error(mess,ln)
(
	ermsg(mess || ' expected', ln);
);


proc testsymee(exp1, exp2, dont_skip, message)
(	testsym(UN2(exp1, exp2), dont_skip, message);
);

proc testsymeee(exp1, exp2, exp3, dont_skip, message)
(	testsym(UN3(exp1, exp2, exp3), dont_skip, message);
);
proc testsymdd(exp, dont_skip1, dont_skip2, message)
(	testsym(exp, UN2(dont_skip1, dont_skip2), message);
);

proc testsym(exp,dont_skip,message)
(	if exp[t_sy] = 0
	then	var mess := '  ',
		    nskipped := 0,
		    erlnr := lnr,
		    both := UN2( exp,dont_skip);


		 	while both[t_sy] = 0
			do	if nskipped < 6
				then	if nskipped < 5
					then mess := mess || sy || ' '
					else mess := mess || sy || ' ...';
					fi;
					nskipped := nskipped + 1;
				fi;
				nextsym;
			od;
                        if mess ~= '  ' 
                        then    mess := ' "'|| mess || '"' || ' skipped.';
				if lnr - erlnr > 2 then
					mess := mess ||
						'\n       scan resumed at "' ||
						sy || '", in line '||string(lnr)
				fi
			fi;
                        if  message ~= ''
			then error(message,erlnr);
			fi;
			if mess ~= '  '
			then ermsg(mess,erlnr);
			fi;
	fi;
);
# user defined:
-rw-r--r--  1 paulk       41513 Jan  7  1982 parser.ud
#
#*************************************************************************#
#*************************************************************************#
#**									**#
#**		INTERMEDIATE CODE GENERATOR				**#
#**									**#
#** This file contains declarations which enable intermediate code	**#
#** generation by the SUMMER parser. Together with the file parser.syn	**#
#** and parser.sn, it form the input for pgen, a parsergenerator written**#
#** in SUMMER.								**#
#**									**#
#** Variables/procedures used here which are (pre)defined by the	**#
#** parsergenerator:							**#
#** 	ermsg:		issues error messages,				**#
#**	errcnt:		number of errors in source,			**#
#**	lnr:		current source line number.			**#
#**									**#
#** Procedure defined in parser.ns:					**#
#**	convstr:	converts a string to internal representation.	**#
#**									**#
#*************************************************************************#
#*************************************************************************#

const	lpar		:= '(',
	colon		:= ':',
	qn		:= 'n',
	tabsym		:= '\t',
	sc		:= ',',
	newl		:= '\n',
	quote		:= '''',
	NIL		:= '~nil',
	SIMPLE		:= '~simple',
	PROC		:= '~proc',
	VAR		:= '~var',
	coltab		:= ':\t',
	prochead	:= 'P:\t',
	classhead	:= 'C:\t',
	classbegin	:= 'CLASS:\t',
	globhead	:= 'G:\t',
	proghead	:= 'M:\t',
	fetch_type	:= 'fetch',
	store_type	:= 'store',

	o_assign	:= ':=',
	o_lpar		:= '(',
	o_whiledo	:= 'wd',
	o_ifthen	:= 'ift',
	o_ifelse	:= 'ife',
	o_scanfor	:= '?',
	o_for		:= 'fr',
	o_case		:= 'cs',
	o_arind		:= 'ind',
	o_field		:= 'fld',
	o_try		:= 'try',
	o_tru		:= 'tru',
	o_assert	:= 'as',
	o_semi		:= ';',
	o_call		:= 'cl',
	o_opcall	:= 'clo',
	o_arinit	:= 'ar',
	o_key		:= 'key',
	o_tabinit	:= 'tb',
	o_ret		:= 'rt',




	S_TYPE		:= 0,
	S_LEVEL		:= 1,
	S_NEXT		:= 2,
	S_VALUE		:= 3,

	F_CLNAME	:= 0,
	F_TYPE		:= 1,
	F_INTERN	:= 2,
	F_FETCH		:= 3,
	F_STORE		:= 4,
	F_NEXT		:= 5,

	O_NAME		:= 0,
	O_ADIC		:= 1,
	O_STATUS	:= 2,
	O_PRIOF		:= 3,
	O_PRIOG		:= 4;






#*************************** GENERAL GLOBAL VARIABLES *********************#


var	f_im,
		# File containing the parsetrees of procedures,		#
		# operators and classes.				#
	f_gl,
		# File containing the parsetree for initialisations of	#
		# globals.						#
	f_init,
		# Scratch file used by 'classdecl' to assemble code	#
		# for initialisation of fields in classes.		#
	f_cs,
		# File containing the case tables.			#
	f_,
		# The current output file for tuples. It is initialized #
		# to f_im. Procedure 'var' sets it to either f_gl (for  #
		# initialisation of globals) or f_in (for initialisation#
		# of fields), and resets it to f_im before returning.	#
		# 'make_tuple' and 'var' itself write to _f.		#

	f_er,
		# error message file					#
	src_name,
		# The name of the current source file			#
	errors_on_tab := table(5, undefined),
		# Administrates on which files errors have occurred, in	#
		# order to produce 'errors on ...' only when 		#
		# necessary. See procedure err				#
	src_stack := [],
		# Source files stack. Pushed by 'include_file' with	#
		# current source file, current linenumber and current	#
		# line. Popped by 'nextsym' on EOF.			#

	opstack := [],
		# The operator stack.					#
		# The stack is pushed by 'opush', popped by 'opush'	#
		# Elements on opstack are entries from montab and dytab.#

	ndstack := [],
		# The operand stack.					#
		# Pushed by 'ndpush', popped by 'ndpop'			#
		# Entries on the stack are operands.        		#

	symtab	  := table (100, undefined) init
	[	'string':	'real':		'integer':
		'scan_string':			   ['ab', 0, undefined, '2'],
		'file':		'bits':		   ['ab', 0, undefined, '3'],
		'interval':			   ['ab', 0, undefined, '4'],
		'stop':		'copy':		'type':
						   ['gb', 0, undefined, '1'],
		'put':		'get':		   ['gb', 0, undefined, '?'],
		'stand_in':	'stand_out':	'stand_er':
						   ['g', 0, undefined, '']
	],
		# Symbol table. Keys are all variables defined at the	#
		# current source program point. Entries contain type,	#
		# level and pointer to namesake.			#

	fieldtab := table(50, undefined) init
	[  'any':    ['scan_string', PROC, 'any'  ,  'any',    NIL, undefined],
	   'append': ['array',       PROC, 'append', 'append', NIL, undefined],
	   'break':  ['scan_string', PROC, 'break',  'break',  NIL, undefined],
	   'center': ['string',      PROC, 'center', 'center', NIL, undefined],
	   'close':  ['file',	     PROC, 'close',  'close',  NIL, undefined],
	   'compl':  ['bits',        PROC, 'compl',  'compl',  NIL, undefined],
	   'conj':   ['bits',        PROC, 'conj',   'conj',   NIL, undefined],
	   'delete': ['array',       PROC, 'delete', 'delete', NIL, undefined],
	   'disj':   ['bits',        PROC, 'disj',   'disj',   NIL, undefined],
	   'find':   ['scan_string', PROC, 'find',   'find',   NIL, undefined],
	   'get':    ['file',        PROC, 'get',    'get',    NIL, undefined],
	   'index':  ['array',       PROC, 'index',  'index',  NIL,
		      ['table',       PROC, 'index',  'index',  NIL,
		       ['string',      PROC, 'index',  'index',  NIL,
			['bits',	PROC, 'index',  'index',  NIL,
			 undefined
		     ]]]],
	   'last':   ['array',       PROC, 'last',   'last',   NIL, undefined],
	   'left':   ['string',      PROC, 'left',   'left',   NIL, undefined],
	   'lit':    ['scan_string', PROC, 'lit',    'lit',    NIL, undefined],
	   'move':   ['scan_string', PROC, 'move',   'move',   NIL, undefined],
	   'next':   ['string',      PROC, 'next',   'next',   NIL,
		      ['array',       PROC, 'next',   'next',   NIL,
		       ['table',       PROC, 'next',   'next',   NIL,
			['interval',    PROC, 'next',   'next',   NIL,
		         ['bits',        PROC, 'next',   'next',   NIL,
                         undefined
                     ]]]]],
	   'pos':    ['scan_string', PROC, 'pos',    'pos',    NIL, undefined],
	   'put':    ['file',        PROC, 'put',    'put',    NIL, undefined],
	   'repl':   ['string',      PROC, 'repl',   'repl',   NIL, undefined],
	   'replace':['string',      PROC, 'replace','replace',NIL, undefined],
	   'retrieve':['array',      PROC, 'retrieve',  'retrieve',  NIL,
		      ['table',       PROC, 'retrieve',  'retrieve',  NIL,
		       ['string',      PROC, 'retrieve',  'retrieve',  NIL,
			['bits',	PROC, 'retrieve',  'retrieve',  NIL,
			 undefined
		     ]]]],
	   'reverse':['string',      PROC, 'reverse','reverse',NIL, undefined],
	   'right':  ['string',      PROC, 'right',  'right',  NIL, undefined],
	   'rpos':   ['scan_string', PROC, 'rpos',   'rpos',   NIL, undefined],
	   'rtab':   ['scan_string', PROC, 'rtab',   'rtab',   NIL, undefined],
	   'size':   ['array',       PROC, 'size',   'size',   NIL,
		      ['bits',        PROC, 'size',   'size',   NIL,
		       ['string',      PROC, 'size',   'size',   NIL,
                        ['table',       PROC, 'size',   'size',   NIL,
		         undefined
		     ]]]],
	   'sort':   ['array',       PROC, 'sort',   'sort',   NIL, undefined],
	   'span':   ['scan_string', PROC, 'span',   'span',   NIL, undefined],
	   'substr': ['string',      PROC, 'substr', 'substr', NIL, undefined],
	   'tab':    ['scan_string', PROC, 'tab',    'tab',    NIL, undefined],
	   'update':['array',        PROC, 'update',  'update',  NIL,
		      ['table',       PROC, 'update',  'update',  NIL,
			['bits',	PROC, 'update',  'update',  NIL,
			 undefined
		     ]]],
	   'bal':    ['scan_string', PROC, 'bal',    'bal',    NIL, undefined],
	   'text':   ['scan_string', VAR,   0,        SIMPLE,  NIL, undefined],
	   'cursor': ['scan_string', VAR,   1,        SIMPLE,  NIL, undefined]
	],
	   	# Fieldtable. Keys are all field names defined up to the#
		# current program point. Entries consist of classname,	#
		# PROC or VAR, the internal name (for procedures) or the#
		# offset (for data-fields), the fetch association, the  #
                # store association, and a successor.			#
		# For operator fields, the key is the internal operator	#
		# name (without class suffix): for a monadic (dyadic)	#
		# operator @, '@.1' ('@.2').				#
	stdops := table(10, undefined) init [
	   '+.2':
	   '-.2':
	   '-.1':
	   '*.2':
	   '/.2':
	   '%.2':
	   '||.2':
	   '=.2':
	   '~=.2':
	   '>.2':
	   '>=.2':
	   '<.2':
	   '<=.2':
			1
	],
		# stdops, table with standard operators, used by	#
		# make_decls to force fld declarations of otherwise	#
		# not redefined standard operators.			#

        classtab := table(10, undefined),
		# Class table. Keys are classnames, entries are arrays	#
		# of five elements. The first one contains the number of#
		# datafields declared within the class (used by		#
		# 'make_decls'), the other four contain the fieldnames, #
		# separated according to their type: the seond element	#
		# contains the parameters, the third the remaining data-#
		# fields, the fourth the procedures, anf the fifth the	#
		# operators. These elements are used by 'do_subclass'	#
		# when a subclass is defined.				#

	inhertab := table(10, undefined),
		# During the parse of a subclass, inhertab contains	#
		# entries for fields which are inherited from the super-#
		# class and may still be redefined.			#

        fetchtab := table(5, undefined),
	storetab := table(5, undefined),
		# Keys are fieldnames occurring in respectively the	#
		# 'fetch' and the 'store' declaration of the current	#
		# class. Values are the associations ('_s' for simple,	#
		# or a name).						#

	assoctab := table(5, undefined),
		# keys are procedure names declared as associations,	#
		# values are fetch_ or store_type. Used to check whether#
		# number of arguments and return values are correct.	#

	loclist := '',
		# Names of locals of the current procedure. Used to	#
		# produce string representing symbolic names (convlocs).#

	par_flds := '',
	data_flds := '',
	proc_flds := '',
	op_flds := '',
		# parameters, data fields and procedure and operator	#
		# fields of current class.				#
		# Names of fields of current class. Used by 'undefine'	#
		# to remove them from symtab on class exit.		#

	level := 0,
		# Current depth of name-nesting. Incremented on proce-	#
		# dure entry, on class entry and on block entry. Decre-	#
		# Used by 'symentry' to check for illegal redefinitions.#
	loccnt := 0,
		# Determines the offset of the next local variable to	#
		# be declared. For global procedures and operators, the	#
		# offset is initially 0; for classes and their associa-	#
		# ted procedures it is 1, as 0 is reserved for the class#
		# object passes as additional argument.			#
		# Because the tracer needs a unique mapping from local	#
		# numbers to associated names, the offset is not reset	#
		# on block exit. This does however cause an inefficient	#
		# use of space in the interpreter.			#

	classcnt := 0,
		# To determine class sequence number. Incremented on 	#
		# entry of a new class.					#

	clsuffix := '',
		# The current class suffix: '.' || classcnt. Used to	#
		# determine internal names of procedures and operators	#
		# defined within a class. (See proceduress 'procedure',#
		# 'operator', 'putopassoc' and 'putassocs'.		#
	retcnt,
		# The current number of return values in a procedure.	#
		# Is set to undefined on procedure entry, and reset to	#
		# 0 or 1 by 'mkrets'.					#

	clab := 0,
		# Determines the next case label. ('nextclab').		#
	glcnt := 0,
		# Determines the next global name invented by the	#
		# parser (see 'nextglob').				#
	imlab,
		# Determines the next label denoting a complex operand.	#
		# Reset to 0 on procedure entry, incremented for each	#
		# new complex operand by 'make_tuple'.			#
	cllab,
		# Guarantees continuity in the numbering of labels	#
		# denoting complex operands in initialisations of data	#
		# fields in a class. 'cllab' is set to 0 on class entry.#
		# It provides a strating value for 'imlab' when parsing	#
		# data field declarations (procedure 'vars') and is set	#
		# to the then current value of 'imlab' at the end of	#
		# such declarations. It also provides the starting value#
		# 'imlab' for parsing the class init statement.		#
	gllab := 0,
		# Plays a similar role for globals; provides the	#
		# starting value for 'imlab' when parsing global initia-#
		# lisations, and when parsing the main program body.	#
	offset,
		# The current class offset. Set to 0 on class entry,	#
		# incremented for each new data field.			#
	pname,
		# Name of the summer source, without the .sm extension.	#
		# Used by 'error', 'make_decls', 'classdecl' and the	#
		# main program to construct the names of intermediate	#
		# files.						#
	clname,
		# The name of the current class. Used to make field-	#
		# entries ('procedure', 'vars', 'operator', 'params')	#
		# and to check whether a field is not redefined within	#
		# the same class ('fieldentry').			#
	inproc := 0,
		# Flag which signals whether the current program point	#
		# lies within a procedure, an operator, a class init	#
		# statement or the main program. Used by 'locvars' to	#
		# detect illegal local declarations (allowed only when	#
		# inproc = 1), and by 'forloop' to recognize whether it	#
		# must invent global or local variables.		#
	inloop := 0,
		# Indicator for nesting level inside while, for or try	#
		# expressions; used to determine whether explicit	#
		# variable initialization should be generated for	#
		# declaration without initializing expression.		#
		# See <local_initialization>.				#

	lastlnr := 1,
		# The source line number on which the most recent line	#
		# increment was generated. (Such an instruction enables	#
		# the interpreter and the tracer to compute source line	#
		# numbers from the ic-code). 'lastlnr' is set to lnr by #
		# 'lineinc' and each time an absolute linenumber is	#
		# generated in the code.				#




	montab := table (20, undefined) init
		[	'-' :		['-1', 1,0,13,14],
			'~' :		['~',  1,0,13,14]
                ],


        dytab := table(20, undefined) init
                [       ':=':           [':=', 2, 0,  7, 8],
                        '+' :           [ '+', 2, 0, 11,11],
                        '-' :           ['-2', 2, 0, 11,11],
                        '*' :           [ '*', 2, 0, 12,12],
                        '/' :           [ '/', 2, 0, 12,12],
                        '%' :           [ '%', 2, 0, 12,12],
                        '||':           ['||', 2, 0, 13,13],
                        '&' :           [ '&', 2, 0,  6, 6],
                        '|' :           [ '|', 2, 0,  4, 5],
                        '<' :           [ '<', 2, 0, 10,10],
                        '<=':           ['<=', 2, 0, 10,10],
                        '>' :           [ '>', 2, 0, 10,10],
                        '>=':           ['>=', 2, 0, 10,10],
                        '=' :           [ '=', 2, 0, 10,10],
                        '~=':           ['~=', 2, 0, 10,10],
                        '(' :           [ '(', 2, 0,  1, 2]
		],
		# 'montab' and 'dytab' map operator names to a 5-tuple,	#
		# consisting of the following items:			#
		# - An internal name (without class suffix). For user	#
		#   defined operators, this is their external name	#
		#   followed by a dot followed by 1 or 2 according to	#
		#   their adicity.					#
		# - A 1 for monadic and a 2 for dyadic operators.	#
		#   Entries from montab and dytab are stacked on the	#
		#   operator stack, and unstacked (by 'treatop' and	#
		#   'emptystack') without knowing from which table they #
		#   originally came. Hence the necessity to include the #
		#   adicity.						#
		# - A declaration status indicator:			#
		#   - 0 for build in, global operators.			#
		#   - 1 for user defined, global operators as yet 	#
		#     without a namesake within a class.		#
		#   - 2 for user defined, global operators with a name-	#
		#     sake within a class. User defined operators which #
		#     occur both globally and within a class, get an    #
                #     additional entry in 'fieldtab'. The 1 and 2 serve #
		#     to see whether this entry has been made already.	#
		#     (see also 'operator' and 'addglobf').		#
		#   - 3 for operators defined as yet only within a class#
		#     Built-in class operators don't occur as yet, but  #
		#     should get the same treatment as user defined	#
		#     ones, i.e. when a global namesake is defined, an  #
		#     additional entry must be amde in the fieldtable.  #
		#   - -lnr for operator names occurring in 'monadic' and#
		#     'dyadic' declarations, but not yet defined. lnr	#
		#     is the source line number on which the declaration#
		#     occurred, rememberd here in order to be able to	#
		#     issue an error message at the correct line when	#
		#     the operator remains undefined.			#
		#   - The f-priority.					#
		#   - The g-priority.					#
		#   All user defined operators get the same priority.   #

	a00 := [0, 0],
	a01 := [0, 1],
	a11 := [1, 1];
		# Three array constants frequently used by <unit>	#



#********* Procedures to produce tuples on the intermediate file *******#

proc ord_choice(opr, n)
return( case opr of
		o_assign:	ord_ass(n),
		o_semi:		ord_semi(n),
		o_call:		ord_call(n),
		o_opcall:	ord_opcall(n),
		o_field:	ord_fields(n),
		o_arinit:	ord_arinit(n),
		o_key:		ord_key(n),
		o_tabinit:	ord_tabinit(n),
		o_case:		ord_case(n),
		o_try:
		o_tru:		ord_try(n),
		default:	ord_def(n)
	esac
       );

	# The order in which the operands are pushed on the operand stack #
	# is not always the one in which they are needed by the code	  #
	# generator. The procedures starting with ord_ return an array	  #
	# in which the i-th index denotes the operand position in the	  #
	# final tuple, of the operand which is the i-th to be popped from #
	# the operand stack.						  #
	# For example, the operands of the operator call '10 @ 11' are	  #
	# popped from the stack in the order 'n2', 'o@.2', 'n11', 'n10',  #
	# but should appear on the im-file in the order 'o@.2', 'n2',	  #
	# 'n10', 'n11'. So for this case, 'ord_opcall' returns [1,0,2,3]. #
	# The comment accompanying each ord_ procedure contains one such  #
	# an example, with the stack groeing to the right.		  #
	# The argument of the ord_ procedures is the number of operands.  #
	# The default case is returned by 'ord_def', which if called with #
	# a number n as argument, returns the integers from n-1 to 0 in	  #
	# that order.							  #
var	ad0	:= [],
	ad1	:= [0],
	ad2	:= [1, 0],
	ad3	:= [2, 1, 0],
	ad4	:= [3, 2, 1, 0],
	ad5	:= [4, 3, 2, 1, 0],
	ad6	:= [5, 4, 3, 2, 1, 0],
	advec	:= [ad0, ad1, ad2, ad3, ad4, ad5, ad6];


proc ord_def(n)
if n <= 6 then return(advec[n])
else
	var o := array(n,0),
	    i;

	for i in o.index do o[i] := n-i-1 od;
	return(o)
fi;
	# a + b.			#
	# stack:	a,b;		#
	# im:		a,b;		#

var	aa01	:= [0,1];

proc ord_ass(n)		return(aa01);
	# x := e.			#
	# stack:	x,e;		#
	# im:		e,x;		#


proc ord_semi(n)
(	var o := array(n,0),
	    i;

	for i in interval(1, n-1, 1)
	do o[i] := n-i od;
	return(o)
);	# o[0] = 0 #
	
	# s1; s2; s3;			#
	# stack:	s1,s2,s3,3;	#
	# im:		3,s1,s2,s3.	#

var	ao1032	:= [1, 0, 3, 2],
	ao102	:= [1, 0, 2];

proc ord_opcall(n)
	if n = 4
	then	return(ao1032)
	elif n = 3
	then	return(ao102)
	else	comermsg('in ord_opcall')
	fi;

	# x @ y;			#
	# stack:	x,y,o@,2;	#
	# im:		o@,2,x,y;	#


proc ord_call(n)
(	var o := array(n,0) init [1],
	    i;

	for i in interval(1, n-2, 1)
	do	o[i] := n-i od;
	return(o)
);	# o[n-1] = 0 #

	# p(a1, a2);			#
	# stack:	p,a1,a2,2;	#
	# im:		p,2,a1,a2;	#

proc ord_fields(n)
(	var o := array(n,0) init [1],
	    i;

	for i in interval(1, n-3, 1)
	do o[i] := n-i od;
	o[n-1] := 2;
	return(o)
);	# o[n-2] = 0 #

	# c.f(a)			#
	# stack:	c,f,a,2;	#
	# im:		f,2,c,a;	#


proc ord_arinit(n)
(	var o := array(n,0),
	    i;

	for i in interval(1, n-3, 1)
	do o[i] := n-i-2 od;
	o[n-2] := n-2;
	o[n-1] := n-1;
	return(o)
);	# o[0] = 0 #

	# array(3,0)[7,8]		#
	# stack:	3,0,7,8,1;	#
	# im:		2,7,8,0,3;	#

proc ord_key(n)
(	var o := array(n,0) init [0,1],
	    i;

	for i in interval(2,n-1,1)
	do o[i] := n-i+1 od;
	return(o)
);
	# 'a': 'b': 1,			#
	# stack:	'a','b',1,2;	#
	# im:		2,1,'a','b';	#

proc ord_tabinit(n)
(	var o := array(n,0) init [0, 3],
	    i;
	for i in interval(2, n-3, 1)
	do o[i] := n-i+1 od;
	o[n-2] := 1;
	o[n-1] := 2;
	return(o)
);
	# table(10,0)['a':'b':1, 'c':2]	#
	# stack:	10,0,k1,k2,2,3;	#
	# im:		3,0,10,2,k1,k2;	#
	# k1 and k2 are produced by	#
	# mk_tuple(o_key, ..).		#

proc ord_case(n)
(	var o := array(n, 0) init [3],
	    i;

	for i in interval(1, n-5, 2)
	do	o[i]   := n-i-1;
		o[i+1] := n-i
	od;
	o[n-3] := 2;
	o[n-2] := 1;
	o[n-1] := 0;
	return(o)
);
	# case e of v1: e1, v2: e2, default: ed esac	#
	# stack: l_inc,e,g_c,e1,C1,e2,C2,ed,Cd,2;	#
	# im:	 l_inc,e,g_c,2,C1,e1,C2,e2,Cd,ed; 	#
	# l_inc is a line increment;			#
	# g_c is the global to which the case_table	#
	# is assigned;					#
	# Lx is the label designating ex.		#

proc ord_try(n)
(	var o := array(n, 0) init [n-1, 1],
	    i;

	for i in interval(2, n-2, 1)
	do o[i] := n-i od;
	return(o)
);	# o[n-1] = 0 #

	# try e1, e2, e3 until eu yrt;	#
	# stack: e1,e2,e3,3,eu;		#
	# im:    l_inc,3,e1,e2,e3,eu;	#





proc make_tuple(opr, n)
if errcnt = 0
then	var ands, ord, i, lab;

	ord := ord_choice(opr, n);
	ands := array(n, '');
	for i in ord do ands[i] := ndpop() od;

	  ndpush(try_eval(opr, ands))
	| (	lab := 'L' || string(imlab := imlab + 1);
	  	f_.put(lab, coltab, opr, tabsym);
	  	for i in ands do f_.put(i, sc) od;
	  	f_.put(newl);
	  	ndpush(lab)
	  )
fi;
	# Make-tuple writes labeled tuples to the current output file	#
	# assigned to the global 'f_'. Its possible values are 'f_im',	#
	# 'f_gl' or 'f_in'. The arguments of 'make_tuple' are an	#
	# operator and the number of operands. (For a listing of pos-	#
	# sible operators, see D.....). 'make_tuple' pops the right	#
	# number of operands from the operand stack and reorders them	#
	# if necessary. Then make_tuple calls try_eval, which tests	#
	# whether the expression is a simple constant expression which	#
	# can be evaluated by the compiler. If this succeeds, the	#
	# result is pushed back on the stack. Otherwise, make_tuple	#
	# writes the new tuple (operator + operands) with a	#
	# label attached to them to the current output file, and pushes #
	# that label on the operand stack.				#



proc try_eval(opr, ands)
(	var r, a0, a1;

	if case opr of
	        '+':	r := try_and(ands[0]) + try_and(ands[1]),
	        '-2':	r := try_and(ands[0]) - try_and(ands[1]),
		'-1':	r := - try_and(ands[0]),
	        '*':	r := try_and(ands[0]) * try_and(ands[1]),
	        '/':	a0 := try_and(ands[0]) & a1 := try_and(ands[1]) &
	            	if a1 = 0
		    	then	ermsg('division by 0', lnr); freturn
			else	r := a0/a1
			fi,
	        '%':	a0 := try_and(ands[0]) &
			a1:= try_and(ands[1]) &
            	       	if a1 = 0
			then	ermsg('division by 0', lnr);
				freturn
			elif type(a0) ~= type(a1) ~= 'integer'
			then	ermsg('% requires integer operands',lnr);
				freturn
			else r := a0 % a1
			fi,
	        default:
             	       freturn
	    esac fails
	then	freturn
	else	case type(r)
		of 'real':	return('r' || string(r)),
		   'integer':	return('n' || string(r))
		esac
	fi
);

proc try_and(and)
scan and
for	case move(1)
	of	'n':		return(integer(rtab(0))),
		'r':	 	return(real(rtab(0))),
		default:	freturn
	esac
rof;


proc key_out()
if errcnt = 0
then	var r := ndpop();

	scan r
	for	if   lit('r') then f_cs.put('real\t', rtab(0), newl)
		elif lit('n') then f_cs.put('int\t',  rtab(0), newl)
		elif lit('S') then f_cs.put('load\t', text,    newl)
		elif lit('z') then f_cs.put('nullstr', newl)
		elif lit('u') then f_cs.put('undef', newl)
		else ermsg('key in case not constant', lnr)
		fi
	rof
fi;

#************ Procedures for the treatment of operators ****************#




proc check_monop(symbol)
if montab[symbol] = undefined
then	if dytab[symbol] = undefined
	then	ermsg('"' || symbol || '" undefined', lnr)
	else	ermsg('dyadic operator "' || symbol
		      || '" used in monadic position', lnr)
	fi
fi;


proc check_dyop(symbol)
if dytab[symbol] = undefined
then	if montab[symbol] = undefined
	then	ermsg('"' || symbol || '" undefined', lnr)
	else	ermsg('monadic operator "' || symbol
		      || '" used in dyadic position', lnr)
	fi
fi;



proc opush(opr)
if errcnt = 0 then opstack.append(opr); fi;

proc opop()
if errcnt = 0 then return(opstack.delete) fi;
	# Pushing and popping the operator stack.			#

proc ndpush(and)
if errcnt = 0 then ndstack.append(and) fi;

proc ndpop()
if errcnt = 0 then return(ndstack.delete) fi;

	# Pushing and popping the operand stack				#

proc priofdef(nf)
	return(if nf = 1 then 13 else 9 fi);
	# The standard f-priorities (monadic: 13, dyadic: 9) for user	#
	# defined operators.						#

proc priogdef(nf)
	return(if nf = 1 then 14 else 9 fi);
	# The standard g-priorities for user defined operators.		#


proc treatop(newop)
if errcnt = 0
then(	var prg, oldop;

	prg := newop[O_PRIOG];
	while  opstack.last[O_PRIOF] >= prg
	do	oldop := opop();
		if oldop[O_STATUS] = 0
		then	make_tuple(oldop[O_NAME], oldop[O_ADIC])
		else	var a := oldop[O_ADIC];

			ndpush('o' || oldop[O_NAME]);
			ndpush(qn || string(a));
			make_tuple(o_opcall, a+2)
		fi
	od;
	opush(newop)
    )
fi;
	# The argument is an operator (or, more accurately, an entry	#
	# from 'montab' or 'dytab') to be pushed on the operator stack.	#
	# Before this is done, operators are popped from opstack and	#
	# handed to make_tuple until one is found with an f-priority	#
	# lower than the g-priority of the new operator. (See D......)	#
	# A left parenthesis has an f-priority lower than the g-priority#
	# of any operator and is hence never popped.			#
	# 'treatop' has to distinguish built-in from user defined	#
	# operators; the latter are operands of the operator 'o_opcall'.#
	# Before transferring such an operator to 'make_tuple', its	#
	# internal name and its number of arguments are pushed on the	#
	# operand stack.						#


proc emptystack()
if errcnt = 0
then(	var oldop, osp := opstack.size;

	while osp > 0
	do	oldop := opop(); osp := osp - 1;
		if oldop[O_NAME] = lpar
		then	 return
		elif oldop[O_STATUS] = 0
		then	make_tuple(oldop[O_NAME], oldop[O_ADIC])
		else	var a := oldop[O_ADIC];

			ndpush('o' || oldop[O_NAME]);
			ndpush(qn || string(a));
			make_tuple(o_opcall, a+2)
		fi
	od
    )
fi;
	# Resembles 'treatop', but pops operators until either the	#
	# stack is empty or a left parenthesis (which is also popped)	#
	# is found.							#




#******************* Symbol table routines *****************************#




proc symentry(name, lev, typ, val)
(	var oldentry;

	oldentry := symtab[name];
	if   oldentry = undefined
	  | oldentry[S_LEVEL] ~= lev
	  | oldentry[S_TYPE] = 'forward' &
		 if typ = 'C'
		 then	ermsg('illegal forward reference(s) to constant "' ||
				name || '" ; first in line ' ||
				oldentry[S_VALUE], lnr
			     )
		 fi
	    & oldentry := undefined
	then	symtab[name] := [typ, lev, oldentry, val];
		return(1)
	else	ermsg('"' || name || '" redeclared', lnr);
		return(0)
	fi
);
	# Enters 'name' in symtab with value 'entry'. If an entry with	#
	# the same level already exists which is not a forward declara-	#
	# tion, a 'redeclared' error is issued. See also 'level' and	#
	# 'symtab'. 							#

proc fieldentry(name, fdes)
(	var s := symtab[name],
	    f := fieldtab[name];

	if s ~= undefined
	then	if s[S_TYPE] = 'forward'
		then	symtab[name] := undefined
		else	while s[S_NEXT] ~= undefined
			do	if s[S_NEXT][S_TYPE] = 'forward'
				then	s[S_NEXT] := undefined
				else	s := s[S_NEXT]
				fi
			od;
			s := symtab[name]
		fi
	fi;
	if f ~= undefined & f[F_CLNAME] = clname
	then	if inhertab[name] ~= undefined
		then	redeffld(name, fdes);
			inhertab[name] := undefined;
		else	ermsg('"' || name || '" redeclared', lnr)
		fi;
		return(0)
	else	fdes[F_NEXT] := f;
		fieldtab[name] := fdes;
		return(1)
	fi
);
	# Enters 'name' into 'fieldtab' with value 'fdes'. If a forward	#
	# declaration for this name is found in symtab it is removed.	#
	# See 'make_decls' and D..... New entries are entered in front	#
	# of existing ones. This is used whenever it has to be checked	#
	# whether a name is defined as a field in the current class; if	#
	# it is, its entry is at the front: the test			#
	# 'fieldtab[name] ~= undefined & fieldtab[name][0] = clname'	#
	# suffices.							#
	# This procedure essentially uses the fact that arrays are not	#
	# copied when assigned to a variable.				#
	# See also 'addglobf'.						#

proc redeffld(name, fdes)
(	var old := fieldtab[name];

	if old[F_TYPE] = VAR
	then	if fdes[F_TYPE] ~= VAR
		then	ermsg('inherited variable redefined as procedure', lnr)
		else	fdes[F_INTERN] := old[F_INTERN];
			offset := offset-1
		fi
	else	if fdes[F_TYPE] ~= PROC
		then	ermsg('inherited procedure redefined as variable', lnr)
		fi
	fi;
	fdes[F_NEXT] := old[F_NEXT];
	fieldtab[name] := fdes
);
	# redeffld is called when a field inherited from a superclass is #
	# redefined in the subclass. The old entry is removed. Allowing  #
	# variables to be redefined as procedures and vice versa requires#
	# the following additions: if x was a var and becomes a proc, it #
	# must be removed from data_flds and added to proc_flds. All     #
	# offsets of data-fields > offset(x) must be decremented.     	 #
	# In the reverse case, x must be transferred from proc_flds to	 #
	# data_flds.							 #

proc addglobf(name)
(	var entry := fieldtab[name],
	    new   := ['~global', PROC, name, name, NIL, undefined];

	if entry = undefined
	then	entry := new
	else	while entry[F_NEXT] ~= undefined
		do entry := entry[F_NEXT] od;
		entry[F_NEXT] := new
	fi
);
	# 'addglobf' makes an additional entry with class name '~global'#
	# for user defined operators which are declared both globally	#
	# and within a class. The entry is added at the end of the list,#
	# this is required by the interpreter. As all other fieldentries#
	# are added at the front, it is guaranteed to remain the last.	#


proc locate_fld(fld, cl)
(	var e := fieldtab[fld];

	while e ~= undefined
	do if e[F_CLNAME] = cl then return(e) else e := e[F_NEXT] fi od;
	comermsg('in locate_fld: fld ' || fld || ', class: ' || cl)
);
	# locate_fld finds the fieldtable entry created for field 'fld' #
	# in class 'cl'.						#


proc remove(names)
	scan names
	for	var s;
		while s := break(sc) & lit(sc) & symtab[s] := symtab[s][S_NEXT]
		do od
	rof;
	# 'undefine' resets the symbol table entries for the names in	#
	# its argument to their previous values. The names declared at	#
	# each level are explicitly remembered and passed as an argu-	#
	# ment instead of simply resetting all entries on the current	#
	# level, as this would require constructing the set of keys and	#
	# scanning the complete symbol table on each block exit; both	#
	# are expensive operations.					#



proc checktype(ident)
(	var entry := symtab[ident],
	    scope, typ;

	if entry = undefined
	then	if fieldtab[ident] = undefined
		then	symentry(ident, 0, 'forward', lnr)
		fi;
		return('w' || ident)
	else	return( case typ := entry[S_TYPE][0] of
			'l':	typ || string(entry[S_VALUE]),
			'c': 'g' : 'a':
				typ || ident,
			'f':	'w' || ident,
			'C':	string(entry[S_VALUE])
			esac
		      )
	fi
);
	# identifies identifiers, returning the operand form required	#
	# by the im-file. (See D......). If the identifier is entered	#
	# neither in 'symtab' nor in 'fieldtab', it is put in 'symtab'	#
	# with type indication 'forward' followed by the current line	#
	# number. If the same identifier is encountered later on without#
	# intermediate declaration, its entry in symtab matches lit('f')#





#********** Procedures associated with the treatment of classes *********#




proc putopassoc(opname)
(	var mon := opname || '.1',
	    dy  := opname || '.2',
	    monentry := fieldtab[mon],
	    dyentry  := fieldtab[dy],
	    undef := 0;

	if monentry = undefined | monentry[F_CLNAME] ~= clname
	then	undef := undef+1
	else	fieldtab[mon][F_FETCH] := fieldtab[mon][F_INTERN]
	fi;
	if dyentry = undefined | dyentry[F_CLNAME] ~= clname
	then	undef := undef+1
	else	fieldtab[dy][F_FETCH] := fieldtab[dy][F_INTERN]
	fi;
	if undef = 2
	then	ermsg('field "' || opname || '" undefined', lnr)
	fi
);
	# Puts fetch associations for an operator field in 'fieldtab'.	#
	# When, say, a declaration 'fetch @' is encountered, an entry	#
	# in 'fetchtab' is made with key '@' and value '_s'. A monadic	#
	# (dyadic) operator '@' declared within that class is entered	#
	# in 'fieldtab' with key '@.1' ('@.2'). 'Putopassoc' checks	#
	# whether the fetch association is indeed '_s' (the only one	#
	# allowed) and whether at least one version of @ is defined 	#
	# within the class, and adds the fetch association(s).	 	#

proc putassocs(type)
(	var field, fstab, ind, assoc;

	if type = fetch_type
	then	fstab := fetchtab; ind := F_FETCH
	else	fstab := storetab; ind := F_STORE
	fi;
	for field in fstab.index
	do assoc := fstab[field];
	   if assoc ~= '_s'
	   then	if fieldtab[assoc] = undefined |
	           fieldtab[assoc][F_CLNAME] ~= clname
	        then	ermsg('fetch/store association "'
			      || assoc || '" undeclared', lnr)
		elif fieldtab[assoc][F_TYPE] ~= PROC
		then	ermsg('fetch/store association "'
			      || assoc || '" is not a procedure', lnr)
		fi
	   fi;
	   if montab[field] ~= undefined | dytab[field] ~= undefined
	   then if type = fetch_type & assoc = '_s'
		then putopassoc(field)
		else ermsg('illegal ' || type ||
			   ' association for "' || field || '"', lnr)
		fi
	   else	var entry;

		entry := fieldtab[field];
		if entry = undefined | entry[F_CLNAME] ~= clname
		then ermsg('field "' || field || '" undeclared', lnr)
		elif entry[F_TYPE] = PROC
		then if type = fetch_type & assoc = '_s'
		     then fieldtab[field][F_FETCH] := entry[F_INTERN]
		     else ermsg('illegal ' || type ||
				' association for "' || field || '"', lnr)
		     fi
		else	fieldtab[field][ind] :=
			  if assoc = '_s'
			  then SIMPLE else fieldtab[assoc][F_INTERN]
			  fi
		fi
	   fi
	od
);
	# Sets fetch or store associations for fields of the current	#
	# class, using the entries from 'fetchtab' or 'storetab'	#
	# (depending on the value of 'type').				#
	# 'putassocs' has to distinguish between operators, procedures	#
	# and data fields. For operators 'putopassoc' is called.	#
	# Procedures cannot have a store association. The only value	#
	# allowed for the fetch association in 'fetchtab' is '_s', but	#
	# the entry in 'fieldtab' will be the name of the procedure with#
	# the class suffix appended. Data fields can have both a fetch	#
	# and a store association; both can have value '~simple' or an	#
	# name of an associated procedure. 'putassocs' also check	#
	# whether all fields mentioned in 'fetch' and 'store' declara-	#
	# tions are indeed declared in the current class.		#
	# 'putopassoc' is called), procedures (which cannot have a store#
	# association and for which the only fetch association allowed	#


proc do_subclass(super)
(	var cl_super;

	if (cl_super := classtab[super]) = undefined
	then ermsg('"' || super || '" not (yet) defined as class', lnr)
	else var fldlist, fld, sub_entry, super_entry;

	     fldlist := cl_super[1];		# parameters #
	     if scan par_flds for lit(fldlist) rof fails
	     then ermsg('parameters of "' || clname ||
			'" should include those of "' || super || '"', lnr)
	     else fldlist := scan_string(fldlist);
		  while scan fldlist for fld := break(sc) & lit(sc) rof
		  do sub_entry := fieldtab[fld];
		     super_entry := locate_fld(fld, super);
		     sub_entry[F_FETCH] := super_entry[F_FETCH];
		     sub_entry[F_STORE] := super_entry[F_STORE];
		  od
	     fi;
	     fldlist := scan_string(cl_super[2]);	# data fields #
	     while scan fldlist for fld := break(sc) & lit(sc) rof
	     do super_entry := locate_fld(fld, super);
	        fieldentry(fld,
				[clname, VAR, offset := offset + 1,
				 super_entry[F_FETCH], super_entry[F_STORE],
				 undefined]
			  );
		data_flds := data_flds || fld || sc;
		symentry(fld, level, 'c', '');
		inhertab[fld] := 1;
	     od;
	     fldlist := scan_string(cl_super[3]);	# procedures #
	     while scan fldlist for fld := break(sc) & lit(sc) rof
	     do super_entry := locate_fld(fld, super);
	        fieldentry(fld,
				[clname, PROC, super_entry[F_INTERN],
				 super_entry[F_FETCH], NIL, undefined]
			  );
		proc_flds := proc_flds || fld || sc;
		symentry(fld, level, 'c', '');
		inhertab[fld] := 1;
	     od;
	     fldlist := scan_string(cl_super[4]);	# operators #
	     while scan fldlist for fld := break(sc) & lit(sc) rof
	     do super_entry := locate_fld(fld, super);
	        fieldentry(fld,
				[clname, PROC, super_entry[F_INTERN],
				 super_entry[F_FETCH], NIL, undefined]
	           	  );
	        op_flds := op_flds || fld || sc;
		inhertab[fld] := 1
	     od
	fi
);
	# All fieldtable entries of the superclass are copied. Parameters #
	# have been entered already; only the fetch and store associations#
	# are changed. They may not be redefined. For all other fields a  # 
	# new entry is created; and they are entered in inhertab to       #
	# denote that they may be redefined.				  #
	# Offsets: if A(a) with datafields x and y is the superclass of	  #
	# B(a,b,c) then after 'do_subclass' B has five datafields:	  #
	# 'a' (offset 0), 'b' (1), 'c' (2), 'x' (3) and 'y' (4).	  #



#****************** Miscellaneous procedures *****************************#



proc comermsg(m)
(	put(string(lnr).right(5, ' '), ': compiler error; ', m, newl);
	stop(-1)
);

proc ermsg(message, lnr)
(	if errors_on_tab[src_name] = undefined
	then	f_er.put(newl, 'errors in ', src_name, ':', newl);
		errors_on_tab[src_name] := 1
	fi;
	f_er.put(string(lnr).right(5, ' ') , ': ', message, newl);
	errcnt := errcnt + 1;
);

proc cant(name)
(	put('Cannot open ', name, '\n');
	stop(1);
);

proc nextglob() return('_' || string(glcnt := glcnt + 1));
	# returns a new global name invented by the parser. The syntax	#
	# is not that of a summer identifier or operator name, so it is #
	# guranteed to be unique. Used by 'caseclause' and by 'forloop'.#

proc nextclab() return('C' || string(clab := clab + 1));


proc lineinc()
(	ndpush('i' || string(lnr - lastlnr));
	lastlnr := lnr
);
	# line increment since last line instruction.			#


proc enlarge(arr,step,size)
(	var newarr := array(size + step, undefined),
	    i;

        for i in arr.index do newarr[i] := arr[i] od;
	return(newarr)
);


proc proc_op_init()
(	lastlnr := lnr;
	retcnt := undefined;
	imlab := 0;
	inproc := 1;
	level := level+1
);

proc proc_op_exit(intname, nf, fnms, stlnr)
(	if retcnt = undefined then retcnt := 0 fi;
	if errcnt = 0
	then	f_im.put(prochead,
			 retcnt, tabsym, intname, sc,
			 convlocs(), sc, nf, sc, loccnt-nf, sc,
			 stlnr, sc, lnr, tabsym, ndpop(), sc, newl
			)
	fi;
	inproc := 0;
	remove(fnms);
	level := level-1
);
	# These two procedures are called by procedure and operator	#
	# declarations.							#



proc convlocs()
	if loclist = ''
	then	return('nil')
	else	loclist := quote || loclist || quote;
		return(scan loclist for convstr(loclist.size ) rof)
	fi;
	# Constructs the string representation for the list of local	#
	# names (separated by comma's). The string label returned will	#
	# be part of a procedure heading.				#


proc make_decls()
(	var dcl, nm, bl := ' ', e;

	if ~(dcl := file(pname || '.dc','w'))
	then	ermsg('cannot open "' || pname || '.dc"', lnr);
		stop(1)
	fi;
	dcl.put('glcnt:\t', glcnt, newl);
	for nm in montab.index
	do	if (e := montab[nm][O_STATUS]) < 0
		then	ermsg('undeclared monadic operator "' || nm || '"', -e)
		fi
	od;
	for nm in dytab.index
	do	if (e := dytab[nm][O_STATUS]) < 0
		then	ermsg('undeclared dyadic operator "' || nm || '"', -e)
		fi
	od;
	for nm in symtab.index
	do	var x := symtab[nm];

		if x[S_TYPE] = 'forward'
		then	ermsg('"' || nm || '" undeclared', x[S_VALUE])
		elif errcnt = 0
		then	dcl.put(nm, coltab, x[S_TYPE], x[S_VALUE], newl)
		fi
	od;
	if errcnt ~= 0 then return fi;
	dcl.put('endsyms', newl, 'classes', newl);
	for nm in classtab.index
	do	dcl.put(nm, sc, classtab[nm][0], newl) od;
	dcl.put('endclasses', newl, 'fields', newl, '');
	for nm in fieldtab.index
	do	var x := fieldtab[nm];

		dcl.put('fld\t', nm, newl);
		while x ~= undefined
		do	dcl.put(x[F_CLNAME], sc, x[F_TYPE], sc,
				 x[F_INTERN], sc, x[F_FETCH], sc, x[F_STORE],
				 newl
			   );
			x := x[F_NEXT]
		od;
	od;
	for nm in stdops.index
	do	if fieldtab[nm] = undefined
		then	dcl.put('fld\t', nm, newl);
		fi
	od;
	dcl.put('endfields', newl);
	dcl.close 
);
	# This procedure is called after completion of the parse of	#
	# the source program. It has two tasks: contsructing the dc-file#
	# and detecting undeclared identifiers.				#
	# 'make-decl' performs (in that order) the following actions:	#
	# - It puts the number of globals invented by the parser on the	#
	#   dc-file.							#
	# - It scans 'montab' and 'dytab' to detect undefined operators,#
	#   i.e. operator names which occurred in 'monadic' and 'dyadic'#
	#   declarations without subsequent definition. They are	#
	#   recognized by a negative declaration status indicator, which#
	#   contains the source line number of the offensive declaration#
	# - It scans the symbol table, issuing error messages for any	#
	#   'forward' declarations that still remain, and writing	#
	#   identifier-type pairs to the dc-file.			#
	# - It scans the class table, writing class-size pairs to the	#
	#   dc-file.							#
	# - It scans the field table. Each entry in the list of entries	#
	#   for a certain field is put on a separate line.		#
# end of parser.ud #
	var
	 	keytab := table(20,undefined) init [
		'assert' : 0,
		'begin' : 1,
		'case' : 2,
		'class' : 3,
		'const' : 4,
		'default' : 5,
		'do' : 6,
		'dyadic' : 7,
		'elif' : 8,
		'else' : 9,
		'end' : 10,
		'esac' : 11,
		'fails' : 12,
		'fetch' : 13,
		'fi' : 14,
		'for' : 15,
		'freturn' : 16,
		'if' : 17,
		'in' : 18,
		'include' : 19,
		'monadic' : 20,
		'od' : 21,
		'of' : 22,
		'op' : 23,
		'proc' : 24,
		'program' : 25,
		'return' : 26,
		'rof' : 27,
		'scan' : 28,
		'self' : 29,
		'store' : 30,
		'subclass' : 31,
		'subject' : 32,
		'succeeds' : 33,
		'table' : 34,
		'then' : 35,
		'try' : 36,
		'undefined' : 37,
		'until' : 38,
		'var' : 39,
		'while' : 40,
		'yrt' : 41,
		'array' : 42
	],


	kartab := table(20,undefined) init [
		')' : 43,
		',' : 44,
		'.' : 45,
		':' : 46,
		';' : 47,
		'[' : 48,
		']' : 49,
		'init' : 50,
		'('  : 51
	],


	predef := table(10,undefined) init [
		'identifier' : 52,
		'integer_constant' : 53,
		'operator_symbol' : 54,
		'real_constant' : 55,
		'string_constant' : 56,
		'EOF' : 57
	],



	SETSIZE := 58,
	f_actuals_0_1 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_array_expression_0_1 := SET([51,48]),
	f_array_or_table_initialization_0_1_1_1_2_2_0_1 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_array_or_table_initialization_0_1_1_1 := SET([44,46,49]),
	f_array_or_table_initialization_0_1_1 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_array_or_table_initialization_0_1 := SET([51,48,49,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_block_0_0 := SET([4,39]),
	f_block_0_1_0_0 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_block_0_1 := SET([51,47,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_block := SET([51,47,48,42,0,2,4,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,39,40]),
	f_case_entry := SET([51,46,47,48,42,0,2,4,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,39,40]),
	f_case_expression_0_3_0_0_0 := SET([51,46,47,48,42,0,2,4,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,39,40]),
	f_case_expression_0_3_0_0_1 := SET([]),
	f_case_expression_0_3_0_0 := SET([51,46,47,48,42,0,2,4,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,39,40]),
	f_case_expression_0_3 := SET([51,44,46,47,48,42,0,2,4,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,39,40]),
	f_case_expression_0_4_1 := SET([]),
	f_class_declaration_0_7 := SET([4,23,24,39]),
	f_class_declaration_0_8_1 := SET([]),
	f_constant := SET([53,55,56,37]),
	f_empty := SET([]),
	f_expression := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_expression_list := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_fetch_associations_0_0_0_1_0_0_0_0 := SET([52,54]),
	f_fetch_associations_0_0_0_1_0_0_0_1_1 := SET([]),
	f_fetch_associations_0_0_0_1_0_0 := SET([52,54]),
	f_fetch_associations_0_0_0_1 := SET([52,54]),
	f_global_operator_declaration_0_3_0 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_global_operator_declaration_0_3_1 := SET([]),
	f_global_operator_declaration_0_3 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_global_procedure_declaration_0_3_0 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_global_procedure_declaration_0_3_1 := SET([]),
	f_global_procedure_declaration_0_3 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_if_body_0_3_2 := SET([]),
	f_if_body_0_3 := SET([8,9]),
	f_if_body := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_local_initialization_0_1_1 := SET([]),
	f_monadic_expression := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_operator_field_declaration_0_3_0 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_operator_field_declaration_0_3_1 := SET([]),
	f_operator_field_declaration_0_3 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_primary_0_1 := SET([45,48]),
	f_primary := SET([51,48,42,0,2,15,16,52,17,53,55,26,28,29,56,32,34,36,37,40]),
	f_procedure_field_declaration_0_3_0 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_procedure_field_declaration_0_3_1 := SET([]),
	f_procedure_field_declaration_0_3 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_program_declaration_0_3_0 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_program_declaration_0_3_1 := SET([]),
	f_program_declaration_0_3 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_return_expression_0_1_0_1_0 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_return_expression_0_1_0_1_1 := SET([]),
	f_return_expression_0_1_0_1 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_return_expression_0_1_1 := SET([]),
	f_return_expression := SET([16,26]),
	f_store_associations_0_0_0_1_0_0_0_0 := SET([52,54]),
	f_store_associations_0_0_0_1_0_0_0_1_1 := SET([]),
	f_store_associations_0_0_0_1_0_0 := SET([52,54]),
	f_store_associations_0_0_0_1 := SET([52,54]),
	f_summer_program := SET([3,4,7,19,20,23,24,25,39]),
	f_table_element := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_table_element_tail := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_table_expression_0_1 := SET([51,48]),
	f_table_initialization_0_1 := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_test_0_1 := SET([12,33]),
	f_test := SET([51,48,42,0,2,15,16,52,17,53,54,55,26,28,29,56,32,34,36,37,40]),
	f_try_expression_0_2_1 := SET([]),
	f_unit_0 := SET([53,55,56,37]),
	f_unit_10 := SET([16,26]),
	f_unit := SET([51,48,42,0,2,15,16,52,17,53,55,26,28,29,56,32,34,36,37,40]),
	s_0 := SET([0]),
	s_1 := SET([1]),
	s_2 := SET([2]),
	s_3 := SET([3]),
	s_4 := SET([4]),
	s_5 := SET([5]),
	s_6 := SET([6]),
	s_7 := SET([7]),
	s_8 := SET([8]),
	s_9 := SET([9]),
	s_10 := SET([10]),
	s_11 := SET([11]),
	s_12 := SET([12]),
	s_13 := SET([13]),
	s_14 := SET([14]),
	s_15 := SET([15]),
	s_16 := SET([16]),
	s_17 := SET([17]),
	s_18 := SET([18]),
	s_19 := SET([19]),
	s_20 := SET([20]),
	s_21 := SET([21]),
	s_22 := SET([22]),
	s_23 := SET([23]),
	s_24 := SET([24]),
	s_25 := SET([25]),
	s_26 := SET([26]),
	s_27 := SET([27]),
	s_28 := SET([28]),
	s_29 := SET([29]),
	s_30 := SET([30]),
	s_31 := SET([31]),
	s_32 := SET([32]),
	s_33 := SET([33]),
	s_34 := SET([34]),
	s_35 := SET([35]),
	s_36 := SET([36]),
	s_37 := SET([37]),
	s_38 := SET([38]),
	s_39 := SET([39]),
	s_40 := SET([40]),
	s_41 := SET([41]),
	s_42 := SET([42]),
	s_43 := SET([43]),
	s_44 := SET([44]),
	s_45 := SET([45]),
	s_46 := SET([46]),
	s_47 := SET([47]),
	s_48 := SET([48]),
	s_49 := SET([49]),
	s_50 := SET([50]),
	s_51 := SET([51]),
	s_52 := SET([52]),
	s_53 := SET([53]),
	s_54 := SET([54]),
	s_55 := SET([55]),
	s_56 := SET([56]),
	s_57 := SET([57]),
	EMPTY := SET([]),
	r_actuals_0_1 := s_43,
	r_actuals_0_0 := UN2(f_actuals_0_1,r_actuals_0_1),
	r_actuals_0_1_0_0 := r_actuals_0_1,
	r_array_expression_0_0 := f_array_expression_0_1,
	r_array_expression_0_1_0_0 := s_50,
	r_array_expression_0_1_0_1_0_0 := s_48,
	r_array_initialization_0_1 := s_49,
	r_array_initialization_0_0 := UN2(f_expression_list,r_array_initialization_0_1),
	r_array_or_table_initialization_0_0 := f_array_or_table_initialization_0_1,
	r_array_or_table_initialization_0_1_1_0 := f_array_or_table_initialization_0_1_1_1,
	r_array_or_table_initialization_0_1_1_1_1_1 := s_49,
	r_array_or_table_initialization_0_1_1_1_1_0 := UN2(f_expression_list,r_array_or_table_initialization_0_1_1_1_1_1),
	r_array_or_table_initialization_0_1_1_1_2_2 := s_49,
	r_array_or_table_initialization_0_1_1_1_2_1 := UN2(s_44,r_array_or_table_initialization_0_1_1_1_2_2),
	r_array_or_table_initialization_0_1_1_1_2_0 := UN2(f_table_element_tail,r_array_or_table_initialization_0_1_1_1_2_1),
	r_array_or_table_initialization_0_1_1_1_2_2_0_1 := UN2(r_array_or_table_initialization_0_1_1_1_2_2,f_array_or_table_initialization_0_1_1_1_2_2_0_1),
	r_array_or_table_initialization_0_1_1_1_2_2_0_0 := UN2(f_array_or_table_initialization_0_1_1_1_2_2_0_1,r_array_or_table_initialization_0_1_1_1_2_2_0_1),
	r_array_or_table_initialization_0_1_1_1_2_2_0_1_0_1 := r_array_or_table_initialization_0_1_1_1_2_2_0_1,
	r_array_or_table_initialization_0_1_1_1_2_2_0_1_0_0 := UN2(s_44,r_array_or_table_initialization_0_1_1_1_2_2_0_1_0_1),
	r_assert_expression_0_0 := f_expression,
	r_block_0_1 := f_block_0_1,
	r_block_0_0 := UN3(f_block_0_1,r_block_0_1,f_block_0_0),
	r_block_0_0_0_0 := r_block_0_0,
	r_block_0_0_1_0 := r_block_0_0,
	r_block_0_1_0_1 := r_block_0_1,
	r_block_0_1_0_0 := UN2(s_47,r_block_0_1_0_1),
	r_block_0_1_0_0_0_0 := r_block_0_1_0_0,
	r_case_entry_0_1 := s_46,
	r_case_entry_0_0 := UN2(s_46,r_case_entry_0_1),
	r_case_entry_0_1_0_1 := r_case_entry_0_1,
	r_case_entry_0_1_0_0 := UN2(f_block,r_case_entry_0_1_0_1),
	r_case_expression_0_4 := s_11,
	r_case_expression_0_3 := UN3(s_5,r_case_expression_0_4,f_case_expression_0_3),
	r_case_expression_0_2 := UN2(f_case_expression_0_3,r_case_expression_0_3),
	r_case_expression_0_1 := UN2(s_22,r_case_expression_0_2),
	r_case_expression_0_0 := UN2(f_expression,r_case_expression_0_1),
	r_case_expression_0_3_0_1 := r_case_expression_0_3,
	r_case_expression_0_3_0_0 := UN2(s_44,r_case_expression_0_3_0_1),
	r_case_expression_0_3_0_0_0_0 := r_case_expression_0_3_0_0,
	r_case_expression_0_3_0_0_1_0 := r_case_expression_0_3_0_0,
	r_case_expression_0_4_0_2 := r_case_expression_0_4,
	r_case_expression_0_4_0_1 := UN2(f_block,r_case_expression_0_4_0_2),
	r_case_expression_0_4_0_0 := UN2(s_46,r_case_expression_0_4_0_1),
	r_case_expression_0_4_1_0 := r_case_expression_0_4,
	r_class_declaration_0_10 := s_47,
	r_class_declaration_0_9 := UN2(s_52,r_class_declaration_0_10),
	r_class_declaration_0_8 := UN2(s_10,r_class_declaration_0_9),
	r_class_declaration_0_7 := UN3(s_50,r_class_declaration_0_8,f_class_declaration_0_7),
	r_class_declaration_0_6 := UN2(f_class_declaration_0_7,r_class_declaration_0_7),
	r_class_declaration_0_5 := UN2(s_30,r_class_declaration_0_6),
	r_class_declaration_0_4 := UN2(s_13,r_class_declaration_0_5),
	r_class_declaration_0_3 := UN2(s_31,r_class_declaration_0_4),
	r_class_declaration_0_2 := UN2(s_1,r_class_declaration_0_3),
	r_class_declaration_0_1 := UN2(s_51,r_class_declaration_0_2),
	r_class_declaration_0_0 := UN2(s_52,r_class_declaration_0_1),
	r_class_declaration_0_7_0_0 := r_class_declaration_0_7,
	r_class_declaration_0_7_1_0 := r_class_declaration_0_7,
	r_class_declaration_0_7_2_0 := r_class_declaration_0_7,
	r_class_declaration_0_7_3_0 := r_class_declaration_0_7,
	r_class_declaration_0_8_0_2 := r_class_declaration_0_8,
	r_class_declaration_0_8_0_1 := UN2(f_block,r_class_declaration_0_8_0_2),
	r_class_declaration_0_8_0_0 := UN2(s_46,r_class_declaration_0_8_0_1),
	r_class_declaration_0_8_1_0 := r_class_declaration_0_8,
	r_constant_declaration_0_1 := UN2(s_47,s_52),
	r_constant_declaration_0_0 := UN2(s_52,r_constant_declaration_0_1),
	r_constant_declaration_0_1_0_1 := r_constant_declaration_0_1,
	r_constant_declaration_0_1_0_0 := UN2(s_44,r_constant_declaration_0_1_0_1),
	r_constant_initialization_0_1 := f_expression,
	r_constant_initialization_0_0 := UN2(s_54,r_constant_initialization_0_1),
	r_data_field_declaration_0_1 := UN2(s_47,s_52),
	r_data_field_declaration_0_0 := UN2(s_52,r_data_field_declaration_0_1),
	r_data_field_declaration_0_1_0_1 := r_data_field_declaration_0_1,
	r_data_field_declaration_0_1_0_0 := UN2(s_44,r_data_field_declaration_0_1_0_1),
	r_dyadic_symbol_declaration_0_1 := UN2(s_47,s_54),
	r_dyadic_symbol_declaration_0_0 := UN2(s_54,r_dyadic_symbol_declaration_0_1),
	r_dyadic_symbol_declaration_0_1_0_1 := r_dyadic_symbol_declaration_0_1,
	r_dyadic_symbol_declaration_0_1_0_0 := UN2(s_44,r_dyadic_symbol_declaration_0_1_0_1),
	r_expression_0_1 := s_54,
	r_expression_0_0 := UN2(s_54,r_expression_0_1),
	r_expression_0_1_0_1 := r_expression_0_1,
	r_expression_0_1_0_0 := UN2(f_monadic_expression,r_expression_0_1_0_1),
	r_expression_list_0_0 := f_expression_list,
	r_expression_list_0_0_0_1 := r_expression_list_0_0,
	r_expression_list_0_0_0_0 := UN2(s_44,r_expression_list_0_0_0_1),
	r_fetch_associations_0_0_0_1 := UN2(s_47,f_fetch_associations_0_0_0_1),
	r_fetch_associations_0_0_0_0 := UN2(f_fetch_associations_0_0_0_1,r_fetch_associations_0_0_0_1),
	r_fetch_associations_0_0_0_1_0_1 := r_fetch_associations_0_0_0_1,
	r_fetch_associations_0_0_0_1_0_0 := UN2(s_44,r_fetch_associations_0_0_0_1_0_1),
	r_fetch_associations_0_0_0_1_0_0_0_1 := r_fetch_associations_0_0_0_1_0_0,
	r_fetch_associations_0_0_0_1_0_0_0_0 := UN2(s_46,r_fetch_associations_0_0_0_1_0_0_0_1),
	r_fetch_associations_0_0_0_1_0_0_0_0_0_0 := r_fetch_associations_0_0_0_1_0_0_0_0,
	r_fetch_associations_0_0_0_1_0_0_0_0_1_0 := r_fetch_associations_0_0_0_1_0_0_0_0,
	r_fetch_associations_0_0_0_1_0_0_0_1_0_1 := r_fetch_associations_0_0_0_1_0_0_0_1,
	r_fetch_associations_0_0_0_1_0_0_0_1_0_0 := UN2(s_52,r_fetch_associations_0_0_0_1_0_0_0_1_0_1),
	r_fetch_associations_0_0_0_1_0_0_0_1_1_0 := r_fetch_associations_0_0_0_1_0_0_0_1,
	r_field_initialization_0_0 := s_54,
	r_field_initialization_0_1_0_0 := f_expression,
	r_for_expression_0_5 := s_21,
	r_for_expression_0_4 := UN2(f_block,r_for_expression_0_5),
	r_for_expression_0_3 := UN2(s_6,r_for_expression_0_4),
	r_for_expression_0_2 := UN2(f_expression,r_for_expression_0_3),
	r_for_expression_0_1 := UN2(s_18,r_for_expression_0_2),
	r_for_expression_0_0 := UN2(s_52,r_for_expression_0_1),
	r_formals_of_class_0_1 := UN2(s_43,s_52),
	r_formals_of_class_0_0 := UN2(s_52,r_formals_of_class_0_1),
	r_formals_of_class_0_1_0_1 := r_formals_of_class_0_1,
	r_formals_of_class_0_1_0_0 := UN2(s_44,r_formals_of_class_0_1_0_1),
	r_formals_of_procedure_0_1 := UN2(s_43,s_52),
	r_formals_of_procedure_0_0 := UN2(s_52,r_formals_of_procedure_0_1),
	r_formals_of_procedure_0_1_0_1 := r_formals_of_procedure_0_1,
	r_formals_of_procedure_0_1_0_0 := UN2(s_44,r_formals_of_procedure_0_1_0_1),
	r_global_initialization_0_0 := s_54,
	r_global_initialization_0_1_0_0 := f_expression,
	r_global_operator_declaration_0_3 := s_47,
	r_global_operator_declaration_0_2 := UN2(f_global_operator_declaration_0_3,r_global_operator_declaration_0_3),
	r_global_operator_declaration_0_1 := UN2(s_51,r_global_operator_declaration_0_2),
	r_global_operator_declaration_0_0 := UN2(s_54,r_global_operator_declaration_0_1),
	r_global_operator_declaration_0_3_0_0 := r_global_operator_declaration_0_3,
	r_global_operator_declaration_0_3_1_0 := r_global_operator_declaration_0_3,
	r_global_procedure_declaration_0_3 := s_47,
	r_global_procedure_declaration_0_2 := UN2(f_global_procedure_declaration_0_3,r_global_procedure_declaration_0_3),
	r_global_procedure_declaration_0_1 := UN2(s_51,r_global_procedure_declaration_0_2),
	r_global_procedure_declaration_0_0 := UN2(s_52,r_global_procedure_declaration_0_1),
	r_global_procedure_declaration_0_3_0_0 := r_global_procedure_declaration_0_3,
	r_global_procedure_declaration_0_3_1_0 := r_global_procedure_declaration_0_3,
	r_global_variable_declaration_0_1 := UN2(s_47,s_52),
	r_global_variable_declaration_0_0 := UN2(s_52,r_global_variable_declaration_0_1),
	r_global_variable_declaration_0_1_0_1 := r_global_variable_declaration_0_1,
	r_global_variable_declaration_0_1_0_0 := UN2(s_44,r_global_variable_declaration_0_1_0_1),
	r_identifier_or_call_0_0 := s_51,
	r_if_body_0_2 := f_if_body_0_3,
	r_if_body_0_1 := UN2(f_block,r_if_body_0_2),
	r_if_body_0_0 := UN2(s_35,r_if_body_0_1),
	r_if_body_0_3_0_0 := f_if_body,
	r_if_body_0_3_1_0 := f_block,
	r_if_expression_0_1 := s_14,
	r_if_expression_0_0 := UN2(f_if_body,r_if_expression_0_1),
	r_include_file_0_1 := s_47,
	r_include_file_0_0 := UN2(s_56,r_include_file_0_1),
	r_local_initialization_0_0 := s_54,
	r_local_initialization_0_1_0_0 := f_expression,
	r_local_variable_declaration_0_1 := UN2(s_47,s_52),
	r_local_variable_declaration_0_0 := UN2(s_52,r_local_variable_declaration_0_1),
	r_local_variable_declaration_0_1_0_1 := r_local_variable_declaration_0_1,
	r_local_variable_declaration_0_1_0_0 := UN2(s_44,r_local_variable_declaration_0_1_0_1),
	r_monadic_expression_0_0 := UN2(f_primary,s_54),
	r_monadic_symbol_declaration_0_1 := UN2(s_47,s_54),
	r_monadic_symbol_declaration_0_0 := UN2(s_54,r_monadic_symbol_declaration_0_1),
	r_monadic_symbol_declaration_0_1_0_1 := r_monadic_symbol_declaration_0_1,
	r_monadic_symbol_declaration_0_1_0_0 := UN2(s_44,r_monadic_symbol_declaration_0_1_0_1),
	r_operator_field_declaration_0_3 := s_47,
	r_operator_field_declaration_0_2 := UN2(f_operator_field_declaration_0_3,r_operator_field_declaration_0_3),
	r_operator_field_declaration_0_1 := UN2(s_51,r_operator_field_declaration_0_2),
	r_operator_field_declaration_0_0 := UN2(s_54,r_operator_field_declaration_0_1),
	r_operator_field_declaration_0_3_0_0 := r_operator_field_declaration_0_3,
	r_operator_field_declaration_0_3_1_0 := r_operator_field_declaration_0_3,
	r_parenthesized_expression_0_1 := s_43,
	r_parenthesized_expression_0_0 := UN2(f_block,r_parenthesized_expression_0_1),
	r_primary_0_1 := f_primary_0_1,
	r_primary_0_0 := UN2(f_primary_0_1,r_primary_0_1),
	r_primary_0_1_0_0 := r_primary_0_1,
	r_primary_0_1_1_0 := r_primary_0_1,
	r_procedure_field_declaration_0_3 := s_47,
	r_procedure_field_declaration_0_2 := UN2(f_procedure_field_declaration_0_3,r_procedure_field_declaration_0_3),
	r_procedure_field_declaration_0_1 := UN2(s_51,r_procedure_field_declaration_0_2),
	r_procedure_field_declaration_0_0 := UN2(s_52,r_procedure_field_declaration_0_1),
	r_procedure_field_declaration_0_3_0_0 := r_procedure_field_declaration_0_3,
	r_procedure_field_declaration_0_3_1_0 := r_procedure_field_declaration_0_3,
	r_program_declaration_0_3 := s_47,
	r_program_declaration_0_2 := UN2(f_program_declaration_0_3,r_program_declaration_0_3),
	r_program_declaration_0_1 := UN2(s_51,r_program_declaration_0_2),
	r_program_declaration_0_0 := UN2(s_52,r_program_declaration_0_1),
	r_program_declaration_0_3_0_0 := r_program_declaration_0_3,
	r_program_declaration_0_3_1_0 := r_program_declaration_0_3,
	r_return_expression_0_0 := s_51,
	r_return_expression_0_1_0_1 := s_43,
	r_return_expression_0_1_0_0 := UN2(f_return_expression_0_1_0_1,r_return_expression_0_1_0_1),
	r_return_expression_0_1_0_1_0_0 := r_return_expression_0_1_0_1,
	r_return_expression_0_1_0_1_1_0 := r_return_expression_0_1_0_1,
	r_scan_expression_0_3 := s_27,
	r_scan_expression_0_2 := UN2(f_block,r_scan_expression_0_3),
	r_scan_expression_0_1 := UN2(s_15,r_scan_expression_0_2),
	r_scan_expression_0_0 := UN2(f_expression,r_scan_expression_0_1),
	r_select_0_1 := s_51,
	r_select_0_0 := UN2(s_52,r_select_0_1),
	r_size_definition_0_3 := s_43,
	r_size_definition_0_2 := UN2(f_expression,r_size_definition_0_3),
	r_size_definition_0_1 := UN2(s_44,r_size_definition_0_2),
	r_size_definition_0_0 := UN2(f_expression,r_size_definition_0_1),
	r_store_associations_0_0_0_1 := UN2(s_47,f_store_associations_0_0_0_1),
	r_store_associations_0_0_0_0 := UN2(f_store_associations_0_0_0_1,r_store_associations_0_0_0_1),
	r_store_associations_0_0_0_1_0_1 := r_store_associations_0_0_0_1,
	r_store_associations_0_0_0_1_0_0 := UN2(s_44,r_store_associations_0_0_0_1_0_1),
	r_store_associations_0_0_0_1_0_0_0_1 := r_store_associations_0_0_0_1_0_0,
	r_store_associations_0_0_0_1_0_0_0_0 := UN2(s_46,r_store_associations_0_0_0_1_0_0_0_1),
	r_store_associations_0_0_0_1_0_0_0_0_0_0 := r_store_associations_0_0_0_1_0_0_0_0,
	r_store_associations_0_0_0_1_0_0_0_0_1_0 := r_store_associations_0_0_0_1_0_0_0_0,
	r_store_associations_0_0_0_1_0_0_0_1_0_1 := r_store_associations_0_0_0_1_0_0_0_1,
	r_store_associations_0_0_0_1_0_0_0_1_0_0 := UN2(s_52,r_store_associations_0_0_0_1_0_0_0_1_0_1),
	r_store_associations_0_0_0_1_0_0_0_1_1_0 := r_store_associations_0_0_0_1_0_0_0_1,
	r_subclass_declaration_0_0_0_2 := s_47,
	r_subclass_declaration_0_0_0_1 := UN2(s_52,r_subclass_declaration_0_0_0_2),
	r_subclass_declaration_0_0_0_0 := UN2(s_22,r_subclass_declaration_0_0_0_1),
	r_subscript_0_1 := s_49,
	r_subscript_0_0 := UN2(f_expression,r_subscript_0_1),
	r_summer_program_0_0 := f_summer_program,
	r_summer_program_0_0_0_0 := r_summer_program_0_0,
	r_summer_program_0_0_1_0 := r_summer_program_0_0,
	r_summer_program_0_0_2_0 := r_summer_program_0_0,
	r_summer_program_0_0_3_0 := r_summer_program_0_0,
	r_summer_program_0_0_4_0 := r_summer_program_0_0,
	r_summer_program_0_0_5_0 := r_summer_program_0_0,
	r_summer_program_0_0_6_0 := r_summer_program_0_0,
	r_summer_program_0_0_7_0 := r_summer_program_0_0,
	r_summer_program_0_0_8_0 := r_summer_program_0_0,
	r_table_element_0_0 := f_table_element,
	r_table_element_0_0_0_1 := r_table_element_0_0,
	r_table_element_0_0_0_0 := UN2(s_46,r_table_element_0_0_0_1),
	r_table_element_tail_0_0 := f_table_element_tail,
	r_table_element_tail_0_0_0_1 := r_table_element_tail_0_0,
	r_table_element_tail_0_0_0_0 := UN2(s_46,r_table_element_tail_0_0_0_1),
	r_table_expression_0_0 := f_table_expression_0_1,
	r_table_expression_0_1_0_0 := s_50,
	r_table_expression_0_1_0_1_0_0 := s_48,
	r_table_initialization_0_1 := UN2(s_49,f_table_initialization_0_1),
	r_table_initialization_0_0 := UN2(f_table_initialization_0_1,r_table_initialization_0_1),
	r_table_initialization_0_1_0_1 := r_table_initialization_0_1,
	r_table_initialization_0_1_0_0 := UN2(s_44,r_table_initialization_0_1_0_1),
	r_test_0_0 := f_test_0_1,
	r_try_expression_0_2 := s_41,
	r_try_expression_0_1 := UN2(s_38,r_try_expression_0_2),
	r_try_expression_0_0 := UN2(f_expression_list,r_try_expression_0_1),
	r_try_expression_0_2_0_1 := r_try_expression_0_2,
	r_try_expression_0_2_0_0 := UN2(f_block,r_try_expression_0_2_0_1),
	r_try_expression_0_2_1_0 := r_try_expression_0_2,
	r_while_expression_0_3 := s_21,
	r_while_expression_0_2 := UN2(f_block,r_while_expression_0_3),
	r_while_expression_0_1 := UN2(s_6,r_while_expression_0_2),
	r_while_expression_0_0 := UN2(f_test,r_while_expression_0_1);

#*************************************************************************#
#*************************************************************************#
#**                                                                  	**#
#**                 	LEXICAL ANALYZER                              	**#
#**                                                                  	**#
#** This file contains procedures which together form a lexical	     	**#
#** analyzer for the SUMMER language. Together with parser.syn and	**#
#** parser.ud it forms the input for pgen, a parser generator written	**#
#** in SUMMER.								**#
#**                                                                  	**#
#** The following variables/procedures/constants are (pre)defined by	**#
#** the	parser generator:						**#
#**		line:		current line,				**#
#**		lnr:		current line number,			**#
#**		ermsg:		produces error messages,		**#
#**		errcnt:		number of errors in source,		**#
#**		sy:		current symbol,				**#
#**		t_sy:		current symbol type,			**#
#**		predef:		types of predefined LEXICAL classes,	**#
#**		keytab:		types of keywords,			**#
#**		kartab:		types of "literals" (e.g. ':', ':='),	**#
#**		lower:		lower case letters,			**#
#**		upper:		upper case letters,			**#
#**		digit:		digits,					**#
#**		ASCII:		ordered string of ASCII characters,	**#
#**				the first one is the space.		**#
#**									**#
#** The following variables and constants are defined in parser.ud:	**#
#**		montab:		contains monadic operators,		**#
#**		dytab:		contains dyadic operators,		**#
#**		sc:		= ',',					**#
#**		quote:		= '''',					**#
#**		newl:		= '\n'.					**#
#**									**#
#*************************************************************************#
#*************************************************************************#

const	alpha		:= 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
	alphanum	:= 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_',
	ops		:= '*+-/:<=>|&~!$%\\@?',
	empty_string	:= '',
	layout		:= ' \t',
	TRUE		:= 1,
	FALSE		:= 0;



var	f_src,
		# File containing the SUMMER source #
	f_st,
		# file containing symbolic representations of strings #
	slab := 0,
		# Determines the next stringlabel ('nextslab') #
	octab,
		# actal conversion table #
	laststringcon;
		# last <string-constant> read. Is undefined if the last	#
		# string-constant contained esacpe sequences. For the	#
		# benefit of <include_file>				#

var	t_str, t_int, t_real, t_op, t_ident, t_dot, t_lp, t_rp, t_lbr,
	t_rbr, t_comma, t_semi, t_colon, t_EOF;

proc init_types()
(	var i;

	t_str	:= predef['string_constant'];
	t_int	:= predef['integer_constant'];
	t_real	:= predef['real_constant'];
	t_op	:= predef['operator_symbol'];
	t_ident	:= predef['identifier'];
	t_dot	:= kartab['.'];
	t_lp	:= kartab['('];
	t_rp	:= kartab[')'];
	t_lbr	:= kartab['['];
	t_rbr	:= kartab[']'];
	t_comma	:= kartab[','];
	t_semi	:= kartab[';'];
	t_colon	:= kartab[':'];
	t_EOF	:= predef['EOF'];

	octab := table(96, undefined);
	for i in ASCII.index
	do	var c := ASCII[i];
		octab[c] := octal(i + 32)
	od;

	octab['\b'] := '010';
	octab['\t'] := '011';
);
	#***************************************************************#
	# This procedure initializes symbol types. It is called just	#
	# before the first call to nextsym; in that way it is certain	#
	# that predef and kartab are initialized at the moment these	#
	# types are initialized.					#
	#***************************************************************#

proc comment()
(	var cseen := TRUE, readln := TRUE;

        while TRUE
        do      if cseen = FALSE
		then	line.span(layout) | empty_string;
			if line.lit('#')
			then	cseen := TRUE; readln := FALSE;
			elif line.rpos(0)
			then	readln := TRUE;
			else	return
			fi;
		fi;
		if cseen = TRUE 
		then	if line.break('#') & line.move(1)
			then	cseen := FALSE;
				readln :=
				if line.rpos(0) then TRUE else FALSE fi;
			else	readln := TRUE
			fi
		fi;
		if readln=TRUE & ~(line:=scan_string(f_src.get ) & lnr:=lnr+1)
		then	line := scan_string('');
			if cseen = TRUE
			then	ermsg('non closed comment', lnr) fi;
			return
		fi;
	od;
);

proc octal(n)
(	var d0, d1, d2;

	d2 := string(n - (n:=n%8)*8);
	d1 := string(n - (n:=n%8)*8);
	d0 := string(n);
	return(if d0 ~= '0' then '0' else '' fi || d0 || d1 || d2)
);
	#***************************************************************#
	# 'octal' converts an integer between 32 and 127 to the string	#
	# representation of the octal equivalent (32 to '040'). It is	#
	# ensured that the octal representation starts with a zero.	#
	# This is a machine-dependent feature , since it relies on the	#
	# Unix assembler convention for octal numbers.			#
	# See also 'convstr'						#
	#***************************************************************#

proc nextslab() return('S' || string(slab := slab+1));


proc convstr(sz)
(	var curs, s;

	lit(quote);
	curs := cursor;
	if s := break('\t\b\\''') & lit(quote) & ~lit(quote)
	then	var oc, c, cnt;

		laststringcon := s;
		if (cnt := s.size) = 0
		then	return('z')
		else	var sl;
			if errcnt ~= 0 then return('') fi;
			sl := nextslab();
			f_st.put('dclstr\t', sl, sc, cnt);
			for c in s
			do	oc := octab[c];
				if oc = undefined
				then	oc := empty_string;
					ermsg('illegal character in string', lnr);
				fi;
				f_st.put(sc, oc);
			od;
			f_st.put(newl);
			return(sl);
		fi
	else	var cnt := 0,
		    res := array(sz,0),
		    c;

		move(curs - cursor);
		while ~rpos(0) & (~lit(quote) | lit(quote) & move(-1))
		do	res[cnt] :=
			if lit('\\')
			then	if   lit('\\')  then '0134'
				elif lit('t')   then '011'
				elif lit('n')   then '012'
				elif lit('b')   then '010'
				elif lit('r')   then '015'
				elif c := (lit('0') | lit('1')) ||
				          any('01234567') ||
				          any('01234567')
				then	c
				else (ermsg('illegal escape sequence in string',
					     lnr);
				      empty_string
				     )
				fi
			else(	  c := move(1) &
				  undefined ~= octab[c]
				| ermsg('illegal character in string', lnr) &
				  empty_string
			    )
			fi;
			cnt := cnt + 1;
			if cnt >= sz
			then	res := enlarge(res, 10, sz+10);
				sz := sz + 10;
			fi;
		od;
		if text[cursor-1] ~= quote
		then	ermsg('newline not allowed in string', lnr);
			rtab(0);
			laststringcon := '';
			return('');
		fi;
		if cnt = 0
		then	return('z')
		else	var i := 0, sl;
			laststringcon := undefined;
			if errcnt ~= 0 then return('') fi;
			sl := nextslab();
			f_st.put('dclstr\t', sl, sc, cnt, sc);
			for i in interval(0, cnt-2, 1)
			do	f_st.put(res[i], sc)	od;
			f_st.put(res[cnt-1], newl);
			return(sl)
		fi
	fi
);
	#***************************************************************#
	# 'convstr' produces the representation of a string on the .st	#
	# file, and returns the label invented for that string.		#
	# 'convstr' is called within the scope of a 'scan .... for ...' #
	# with the cursor positioned before the opening quote.	 	#
	# The length of the string is determined in advance and passed	#
	# as an argument. During conversion, the converted characters	#
	# are stored in an array; 'sz' allows this array to be declared #
	# with approximately the right size. (In theory, the length of	#
	# a string is only limited by the maximum length allowed for	#
	# a source line, which can be anything). The main loop converts #
	# one character to its AsCII equivalent. Special characters	#
	# start with a '\', followed by either 't', 'n', 'b' or 'r',	#
	# (tab, newline, backspace, carriage return), or by a three	#
	# digit octal number between 000 and 177, which denotes the cor-#
	# responding AsCII value. A '\' itself is represented as '\\'.	#
	# The string AsCII contains all AsCII characters from blank	#
	# (040) up to and including '~' (176) in the right order. The	#
	# AsCII value of a character in this range is computed by	#
	# determining its position in the string AsCII, adding 32 (octal#
	# 40), and calling 'octal'. The only two characters outside this#
	# range which can be represented directly are TAB and BS (),	#
	# hence the lines ('elif lit('\t')...' and 'elif lit('\b')...'.	#
	# If per chance there are any others, a compiler error is issued#
	# The condition governing the 'while' looks strange but is	#
	# correct: If '~lit(quote)' fails, then lit(quote) has succeeded#
	# and the cursor is positioned now past the first quote.	#
	# As a quote itself is represented by '' within a string, the	#
	# alternative is peeking  ahead for a second quote (the cursor	#
	# is reset in order to get that quote converted).		#
	# 'convstr' is called by 'str' (with the current source line as	#
	# scan string) and by 'convlocs' with the list of local names as#
	# scan string).							#
	#***************************************************************#

proc get_str()
(	t_sy := t_str;
	scan line
	for	move(-1);	# recover initial quote #
		sy := convstr(10);
	rof
);
	#***************************************************************#
	# get_str delegates the reading of a string constant to		#
	# which generates the internal representation for string cons.	#
	#***************************************************************#


proc get_number()
assert  scan line
	for   var tail;
	      if tail := span(digit)
	      then sy := if sy = '0' then tail else sy || tail fi
	      fi &
	      t_sy := t_int &
	      if sy := sy || lit('.') || (span(digit) | '')
	      then t_sy := t_real
	      fi &
	      if sy := sy || lit('e') ||
				    (lit('+') | lit('-') | '') || span(digit)
	      then t_sy := t_real
	      fi
	rof;

	#***************************************************************#
	#    Get_number parses a number which start with a digit	#
	#    (and not with a dot). After parsing a sequence of digits,	#
	#    type t_int is assigned. If that sequence is followed by	#
	#    either a dot (possibly followed by another string of 	#
	#    digits), or e [+|-|nothing] followed by a string of digits,#
	#    or both, the type is t_real.				#
	#***************************************************************#

proc get_real_or_dot()
scan line
for   if sy := sy || span(digit) ||
		     (  lit('e') || (lit('+') | lit('-') | '') || span(digit)
		      | ''
		     )
      then t_sy := t_real
      else t_sy := t_dot
      fi
rof;
	#***************************************************************#
	# 3. To parse a single dot, or a real denotation which starts	#
	#    with a dot, and then must be followed by at least one	#
	#    digit. '.e3' is not a legal real denotation because of the	#
	#    difficulties it would cause 'nextsym' to distinguish	#
	#    between a field selection and a real.			#
	#***************************************************************#


proc get_opname()
scan line
for	sy := sy || span(alphanum) | 'OK';
	t_sy := t_op;
	if montab[sy] ~= undefined | dytab[sy] ~= undefined
	then return
	elif scan sy for lit('_') & any(alpha) & rtab(1) & lit('_') rof fails
	then	ermsg('illegal operator name "' || sy || '"', lnr)
	fi
rof;

proc nextsym()
while TRUE
do line.span(layout) | empty_string;
   if sy := line.any(alpha) || (line.span(alphanum) | empty_string)
   then
	t_sy := (undefined ~= keytab[sy] | t_ident);
	return;
   elif sy := line.move(1)
   then 
	case sy
	of	'0':		# skip leading zeros #
				line.span('0') | empty_string;
				get_number();
				return,
		'1': '2': '3': '4': '5': '6': '7': '8': '9':
				get_number();
				return,
		'.':
				get_real_or_dot();
				return,
		'''':
				get_str();
				return,
		'_':		get_opname();
				return,
		'*': '+': '-': '/': ':': '<': '=': '>': '?':
		'|': '&': '~': '!': '$': '%': '\\': '@':
				sy := sy || line.span(ops) | 'OK';
				if sy = ':'
				then	t_sy := t_colon
				else	t_sy := t_op
				fi;
				return,
		'(':
				t_sy := t_lp;
				return,
		')':
				t_sy := t_rp;
				return,
		'[':
				t_sy := t_lbr;
				return,
		']':
				t_sy := t_rbr;
				return,
		',':
				t_sy := t_comma;
				return,
		';':
				t_sy := t_semi;
				return,
		'#':
				comment(),
		default:
				ermsg('illegal character "' || sy || '"', lnr)
	esac
   elif line := scan_string(get(f_src))
   then lnr := lnr + 1
   elif src_stack.size > 0
   then var os := src_name;

	f_src.close;
	[f_src, src_name, line, lnr, lastlnr] := src_stack.delete;
	if errors_on_tab[os] ~= undefined
	then	errors_on_tab[src_name] := undefined;
			# a new "errors on ..." must be produced	#
			# if an error occurs.				#
	fi;
   else sy := 'EOF';
	t_sy := t_EOF;
	return
   fi
od;
	#***************************************************************#
	# comment must be updated					#
	# 'nextsym' determines the next lexical symbol (in 'sy') and	#
	# its type (in 't_sy'). First, tabs and spaces are skipped.	#
	# If then nothing is left on the current line, the proecdure	#
	# reads new lines until it finds one with a meaningful symbol.	#
	# There are altogether 15 possibilities:			#
	# 1. Identifiers and keywords, which get a separate treatment	#
	#    to speed up their recognition. Their type is either	#
	#    extracted from keytab, or t_int.				#
	# 2. Integers, and reals for so far they start with a digit.	#
	# 3. A single dot, which could also be the start of a real.	#
	# 4. A string.							#
	# 5. An operator name starting with an underline.		#
	# 6. An operator consisting of a sequence of operator symbols.	#
	#    An explicit test for a single colon is included here.	#
	# 7. A left parenthesis.					#
	# 8. A right parenthesis.					#
	# 9. A left bracket.						#
	#10. A right bracket.						#
	#11. A comma.							#
	#12. A semi_colon.						#
	#13. The start of a comment. After the comment has been parsed,	#
	#    a next pass through the loop is executed, to retrieve	#
	#    a meaningful symbol.					#
	#14. If the current line contains a non_layout character which	#
	#    is none of the above, it is illegal. An error message is	#
	#    issued an a new pass through the loop executed.		#
	#15. If the current line is empty and no new line can be read	#
	#    from the source file, we are at end-of-file.		#
	#***************************************************************#



proc  p_actuals(dont_skip)
(
  var n ;
  # line: 786#
  n := 0;
  if t_sy ~= 51 then testsym(s_51,dont_skip,'<actuals>') fi;
  if t_sy = 51
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_actuals_0_0[t_sy]=0 then testsymee(dont_skip,r_actuals_0_0,EMPTY,'') fi;
    if f_actuals_0_1[t_sy] = 1
    then
      n := p_expression_list(dont_skip.disj(r_actuals_0_1_0_0));
    fi;
    if t_sy = 43
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('")"',lnr);
    fi;
  fi;
  # line: 788#
  return(n);
);


proc  p_array_expression(dont_skip)
(
  var n ;
  # line: 1045#
  n := 0;
  if t_sy ~= 42 then testsym(s_42,dont_skip,'<array_expression>') fi;
  if t_sy = 42
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_array_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_array_expression_0_0,EMPTY,'') fi;
    if f_array_expression_0_1[t_sy]=0 then testsym(f_array_expression_0_1,dont_skip,'"(" or "["') fi;
    if t_sy = 51
    then
      p_size_definition(dont_skip.disj(r_array_expression_0_1_0_0));
      if t_sy = 50
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_array_expression_0_1_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_array_expression_0_1_0_1_0_0,EMPTY,'') fi;
        n := p_array_initialization(dont_skip);
      fi;
    elif t_sy = 48
    then
      # line: 1047#
      ndpush('n0'); ndpush('u');
      n := p_array_initialization(dont_skip);
    fi;
  fi;
  # line: 1049#
  ndpush(qn || string(n)); make_tuple(o_arinit, n+3);
);


proc  p_array_initialization(dont_skip)
(
  var n ;
  if t_sy ~= 48 then testsym(s_48,dont_skip,'<array_initialization>') fi;
  if t_sy = 48
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_array_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_array_initialization_0_0,EMPTY,'') fi;
    n := p_expression_list(dont_skip.disj(r_array_initialization_0_1));
    if t_sy = 49
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"]"',lnr);
    fi;
  fi;
  # line: 1059#
  return(n);
);


proc  p_array_or_table_initialization(dont_skip)
(
  var n,nk ;
  # line: 1118#
  var sumk := 0;
  n := 0;
  ndpush('n0'); ndpush('u');
  if t_sy ~= 48 then testsym(s_48,dont_skip,'<array_or_table_initialization>') fi;
  if t_sy = 48
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_array_or_table_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_array_or_table_initialization_0_0,EMPTY,'') fi;
    if f_array_or_table_initialization_0_1[t_sy]=0 then testsym(f_array_or_table_initialization_0_1,dont_skip,'"(","[","]","array" or "assert" etc.') fi;
    if t_sy = 49
    then
      # line: 1127#
      ndpush(qn || string(n));
      make_tuple(o_arinit, n+3);
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    elif f_array_or_table_initialization_0_1_1[t_sy] = 1
    then
      p_expression(dont_skip.disj(r_array_or_table_initialization_0_1_1_0));
      if f_array_or_table_initialization_0_1_1_1[t_sy]=0 then testsym(f_array_or_table_initialization_0_1_1_1,dont_skip,'",",":" or "]"') fi;
      if t_sy = 49
      then
        # line: 1123#
        n := 1;
        # line: 1127#
        ndpush(qn || string(n));
        make_tuple(o_arinit, n+3);
        nextsym;
        if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
      elif t_sy = 44
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_array_or_table_initialization_0_1_1_1_1_0[t_sy]=0 then testsymee(dont_skip,r_array_or_table_initialization_0_1_1_1_1_0,EMPTY,'') fi;
        n := p_expression_list(dont_skip.disj(r_array_or_table_initialization_0_1_1_1_1_1));
        # line: 1125#
        n := n+1;
        if t_sy = 49
        then
          # line: 1127#
          ndpush(qn || string(n));
          make_tuple(o_arinit, n+3);
          nextsym;
          if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
        else error('"]"',lnr);
        fi;
      elif t_sy = 46
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_array_or_table_initialization_0_1_1_1_2_0[t_sy]=0 then testsymee(dont_skip,r_array_or_table_initialization_0_1_1_1_2_0,EMPTY,'') fi;
        nk := p_table_element_tail(dont_skip.disj(r_array_or_table_initialization_0_1_1_1_2_1));
        # line: 1130#
        sumk := sumk + nk;
        n := n+1;
        if t_sy = 44
        then
          nextsym;
          if dont_skip[t_sy]=0 & r_array_or_table_initialization_0_1_1_1_2_2_0_0[t_sy]=0 then testsymee(dont_skip,r_array_or_table_initialization_0_1_1_1_2_2_0_0,EMPTY,'') fi;
          while f_array_or_table_initialization_0_1_1_1_2_2_0_1[t_sy] = 1
          do
            nk := p_table_element(dont_skip.disj(r_array_or_table_initialization_0_1_1_1_2_2_0_1_0_0));
            # line: 1130#
            sumk := sumk + nk;
            n := n+1;
            if t_sy = 44
            then
              nextsym;
              if f_table_element[t_sy]=0 then testsymdd(f_table_element,dont_skip,r_array_or_table_initialization_0_1_1_1_2_2_0_1_0_1,'<table_element>') fi;
            elif f_table_element[t_sy] = 1
            then error('Separating ","',lnr);
            fi;
          od;
        fi;
        if t_sy = 49
        then
          # line: 1133#
          ndpush(qn || string(n));
          ndpush(qn || string(sumk));
          make_tuple(o_tabinit, n+4);
          nextsym;
          if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
        else error('"]"',lnr);
        fi;
      fi;
    fi;
  fi;
);


proc  p_assert_expression(dont_skip)
(
  if t_sy ~= 0 then testsym(s_0,dont_skip,'<assert_expression>') fi;
  if t_sy = 0
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_assert_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_assert_expression_0_0,EMPTY,'') fi;
    p_expression(dont_skip);
  fi;
  # line: 1033#
  make_tuple(o_assert, 1);
);


proc  p_block(dont_skip)
(
  var c,v ;
  # line: 1156#
  var vnms := '',
  cnms := '',
  n := 0;
  level := level+1;
  if f_block[t_sy]=0 & dont_skip[t_sy]=0 then testsymee(f_block,dont_skip,EMPTY, '') fi;
      while f_block_0_0[t_sy] = 1
    do
      if t_sy = 39
      then
        v := p_local_variable_declaration(dont_skip.disj(r_block_0_0_0_0));
        # line: 1162#
        n := n + v[0];
        vnms  := vnms || v[1];
      elif t_sy = 4
      then
        c := p_constant_declaration(dont_skip.disj(r_block_0_0_1_0));
        # line: 1165#
        cnms := cnms || c;
      fi;
    od;
    while f_block_0_1[t_sy] = 1
    do
      if f_block_0_1_0_0[t_sy] = 1
      then
        p_expression(dont_skip.disj(r_block_0_1_0_0_0_0));
        # line: 1167#
        n := n+1;
      fi;
      if t_sy = 47
      then
        nextsym;
        if f_block_0_1_0_0[t_sy]=0 & dont_skip[t_sy]=0 & r_block_0_1_0_1[t_sy] = 0 then testsymeee(f_block_0_1_0_0,dont_skip,r_block_0_1_0_0,EMPTY, '') fi;
      elif f_block_0_1_0_0[t_sy] = 1
      then error('Separating ";"',lnr);
      fi;
    od;
  # line: 1169#
  if n = 0
  then	ndpush('u')
  elif n ~= 1
  then	ndpush(qn || string(n));
  make_tuple(o_semi, n + 1)
  fi;
  if vnms ~= empty_string then remove(vnms) fi;
  if cnms ~= empty_string then remove(cnms) fi;
  level := level - 1
);


proc  p_case_entry(dont_skip)
(
  # line: 916#
  var clab, n := 0;
  if errcnt = 0
  then	clab := nextclab();
  f_cs.put('load\t', clab, newl)
  fi;
  if f_case_entry[t_sy]=0 then testsym(f_case_entry,dont_skip,'<case_entry>') fi;
  if f_case_entry[t_sy] = 1
  then
    p_block(dont_skip.disj(r_case_entry_0_0));
    if t_sy ~= 46 then testsymdd(s_46,dont_skip,r_case_entry_0_1,'":"') fi;
    while s_46[t_sy] = 1
    do
      if t_sy = 46
      then
        # line: 923#
        key_out();
        n := n+1;
        nextsym;
        if dont_skip[t_sy]=0 & r_case_entry_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_case_entry_0_1_0_0,EMPTY,'') fi;
        p_block(dont_skip.disj(r_case_entry_0_1_0_1));
      fi;
    od;
  fi;
  # line: 926#
  if errcnt = 0
  then	f_cs.put('tabelem\t', n, newl)
  fi;
  ndpush(clab);
  #***************************************************************#
  # In order to enforce the LL(1) property, the constant key in	#
  # a case is parsed as a block. The procedure key_out afterwards	#
  # checks, whether this block was indeed a simple constant: if	#
  # not, an error message is issued.				#
  # The LL(1) restrictions also require that <case_entry>s cannot #
  # produce empty, hence the repetition.				#
  #***************************************************************#
);


proc  p_case_expression(dont_skip)
(
  # line: 889#
  var clab, deflab, gnm, n := 0;
  lineinc();
  if t_sy ~= 2 then testsym(s_2,dont_skip,'<case_expression>') fi;
  if t_sy = 2
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_case_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_case_expression_0_0,EMPTY,'') fi;
    p_expression(dont_skip.disj(r_case_expression_0_1));
    # line: 893#
    if errcnt = 0
    then	deflab := nextclab();
    f_cs.put('load\t', deflab, newl,
    'int\t30\n', 'tabinit\n');
    gnm := nextglob();
    ndpush('g' || gnm)
    fi;
    if t_sy = 22
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_case_expression_0_2[t_sy]=0 then testsymee(dont_skip,r_case_expression_0_2,EMPTY,'') fi;
    else error('"of"',lnr);
    fi;
    while f_case_expression_0_3[t_sy] = 1
    do
      if f_case_expression_0_3_0_0_0[t_sy] = 1
      then
        p_case_entry(dont_skip.disj(r_case_expression_0_3_0_0_0_0));
        # line: 901#
        n := n+1;
      else
        p_empty(dont_skip.disj(r_case_expression_0_3_0_0_1_0));
      fi;
      if t_sy = 44
      then
        nextsym;
        if f_case_expression_0_3_0_0[t_sy]=0 & dont_skip[t_sy]=0 & r_case_expression_0_3_0_1[t_sy] = 0 then testsymeee(f_case_expression_0_3_0_0,dont_skip,r_case_expression_0_3_0_0,EMPTY, '') fi;
      elif f_case_expression_0_3_0_0[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 5
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_case_expression_0_4_0_0[t_sy]=0 then testsymee(dont_skip,r_case_expression_0_4_0_0,EMPTY,'') fi;
      if t_sy = 46
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_case_expression_0_4_0_1[t_sy]=0 then testsymee(dont_skip,r_case_expression_0_4_0_1,EMPTY,'') fi;
      else error('":"',lnr);
      fi;
      p_block(dont_skip.disj(r_case_expression_0_4_0_2));
    else
      p_empty(dont_skip.disj(r_case_expression_0_4_1_0));
      # line: 903#
      ndpush('');	# no default expression #
    fi;
    if t_sy = 11
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"esac"',lnr);
    fi;
  fi;
  # line: 905#
  ndpush(deflab);
  if errcnt = 0
  then	f_cs.put('asglob\t', gnm, newl, 'void', newl);
  ndpush(qn || string(n));
  make_tuple(o_case, 2*(n+1)+4)
  fi;
);


proc  p_class_declaration(dont_skip)
(
  var c,n_nms,super ;
  # line: 280#
  var nf := 0,
  stlnr,
  cnms := '';
  offset := -1; cllab := 0;
  classcnt := classcnt + 1;
  clsuffix := '.' || string(classcnt);
  if errcnt = 0
  then	if ~(f_init := file(pname || '.in','w'))
  then	ermsg('cannot open "' || pname || '.in"', lnr)
  fi
  fi;
  if t_sy ~= 3 then testsym(s_3,dont_skip,'<class_declaration>') fi;
  if t_sy = 3
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_class_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_0,EMPTY,'') fi;
    if t_sy = 52
    then
      # line: 293#
      clname := sy;
      level := level+1;
      nextsym;
      if dont_skip[t_sy]=0 & r_class_declaration_0_1[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_1,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    n_nms := p_formals_of_class(dont_skip.disj(r_class_declaration_0_2));
    # line: 296#
    nf := n_nms[0] + 1;
    par_flds := n_nms[1];
    symentry(clname, level-1, 'ap', nf);
    # level has been incremented before to parse parameters #
    if errcnt = 0
    then f_im.put(classbegin, clname, sc, classcnt, newl)
    fi;
    if t_sy = 1
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_class_declaration_0_3[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_3,EMPTY,'') fi;
    else error('"begin"',lnr);
    fi;
    super := p_subclass_declaration(dont_skip.disj(r_class_declaration_0_4));
    p_fetch_associations(dont_skip.disj(r_class_declaration_0_5));
    p_store_associations(dont_skip.disj(r_class_declaration_0_6));
    while f_class_declaration_0_7[t_sy] = 1
    do
      if t_sy = 24
      then
        p_procedure_field_declaration(dont_skip.disj(r_class_declaration_0_7_0_0));
      elif t_sy = 23
      then
        p_operator_field_declaration(dont_skip.disj(r_class_declaration_0_7_1_0));
      elif t_sy = 39
      then
        p_data_field_declaration(dont_skip.disj(r_class_declaration_0_7_2_0));
      elif t_sy = 4
      then
        c := p_constant_declaration(dont_skip.disj(r_class_declaration_0_7_3_0));
        # line: 304#
        cnms := cnms || c;
      fi;
    od;
    # line: 306#
    stlnr := lnr;
    loccnt := nf;
    loclist := par_flds;
    imlab := cllab;
    inproc := 1;
    if super ~= undefined
    then	var nfs := symtab[super][S_VALUE],
    i := 0;
    ndpush('g' || super);
    for i in interval(0, nfs-1, 1)
    do	ndpush('l' || string(i)) od;
    ndpush(qn || string(nfs));
    make_tuple(o_call, nfs+2)
    fi;
    #*******************************************************#
    # If the current class is a subclass, a call to the	#
    # init-procedure of the superclass is generated.	#
    # If the superclass had n-1 declared parameter, then	#
    # the actual parameters of this call are exactly the	#
    # first n parameters of the current class (including	#
    # the parameter which equals the "self" object.		#
    # This accounts for the pushing on the stack of the	#
    # locals.						#
    #*******************************************************#
    if t_sy = 50
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_class_declaration_0_8_0_0[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_8_0_0,EMPTY,'') fi;
      if t_sy = 46
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_class_declaration_0_8_0_1[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_8_0_1,EMPTY,'') fi;
      else error('":"',lnr);
      fi;
      p_block(dont_skip.disj(r_class_declaration_0_8_0_2));
      # line: 332#
      if super ~= undefined
      then	ndpush('n2');
      make_tuple(o_semi, 3)
      fi;
    else
      p_empty(dont_skip.disj(r_class_declaration_0_8_1_0));
      # line: 337#
      if super = undefined then ndpush('u') fi;
    fi;
    if t_sy = 10
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_class_declaration_0_9[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_9,EMPTY,'') fi;
    else error('"end"',lnr);
    fi;
    if t_sy = 52
    then
      # line: 339#
      if sy ~= clname
      then	ermsg('"end" not followed by class name "' ||
      clname ||'"', lnr)
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_class_declaration_0_10[t_sy]=0 then testsymee(dont_skip,r_class_declaration_0_10,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 344#
  putassocs(fetch_type); putassocs(store_type);
  fetchtab := table(5, undefined);
  storetab := table(5, undefined);
  assoctab := table(5, undefined);
  if errcnt = 0
  then	f_im.put(classhead,
  1, tabsym, clname, sc, convlocs(), sc, nf, sc,
  loccnt-nf, sc, stlnr, sc, lnr, tabsym, ndpop(),
  sc, newl
  );
  f_init.close ;
  f_init := file(pname || '.in','r');
  while f_im.put(f_init.get , newl) do od;
  f_init.close ;
  f_im.put('CLASSEND', newl)
  fi;
  classtab[clname] :=
  [offset+1, par_flds, data_flds, proc_flds, op_flds];
  remove(par_flds);
  remove(data_flds);
  remove(proc_flds);
  remove(cnms);
  level := level-1;
  par_flds := data_flds := proc_flds := op_flds := clname := '';
  inhertab := table(10, undefined);
);


proc  p_constant(dont_skip)
(
  if f_constant[t_sy]=0 then testsym(f_constant,dont_skip,'<constant>') fi;
  if t_sy = 56
  then
    # line: 762#
    ndpush(sy);
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  elif t_sy = 53
  then
    # line: 763#
    ndpush('n' || sy);
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  elif t_sy = 55
  then
    # line: 764#
    ndpush('r' || sy);
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  elif t_sy = 37
  then
    # line: 765#
    ndpush('u');
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  fi;
);


proc  p_constant_declaration(dont_skip)
(
  var ci ;
  # line: 121#
  var nms := '';
  if t_sy ~= 4 then testsym(s_4,dont_skip,'<constant_declaration>') fi;
  if t_sy = 4
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_constant_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_constant_declaration_0_0,EMPTY,'') fi;
    if t_sy ~= 52 then testsymdd(s_52,dont_skip,r_constant_declaration_0_1,'"identifier"') fi;
    while s_52[t_sy] = 1
    do
      ci := p_constant_initialization(dont_skip.disj(r_constant_declaration_0_1_0_0));
      # line: 123#
      if ci[0] = 1 then nms := nms || ci[1] || sc fi;
      #*******************************************************#
      # ci[0] = 1 if the current identifier was not declared	#
      # before on the same level. ci[1] contains the current	#
      # identifier.						#
      #*******************************************************#
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 52 then testsymdd(s_52,dont_skip,r_constant_declaration_0_1_0_1,'<constant_initialization>') fi;
      elif s_52[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 131#
  return(nms);
);


proc  p_constant_initialization(dont_skip)
(
  # line: 138#
  var name := '',
  new := 0;
  if t_sy ~= 52 then testsym(s_52,dont_skip,'<constant_initialization>') fi;
  if t_sy = 52
  then
    # line: 141#
    name := sy;
    nextsym;
    if dont_skip[t_sy]=0 & r_constant_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_constant_initialization_0_0,EMPTY,'') fi;
    if t_sy = 54
    then
      # line: 143#
      if sy ~= ':='
      then	ermsg('":=" expected instead of "' || sy || '"', lnr)
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_constant_initialization_0_1[t_sy]=0 then testsymee(dont_skip,r_constant_initialization_0_1,EMPTY,'') fi;
    else error('"operator_symbol"',lnr);
    fi;
    p_expression(dont_skip);
  fi;
  # line: 147#
  (var r;
  if errcnt = 0
  then	r := ndpop();
  case r[0]
  of	'n': 'r': 'S': 'z': 'u': ,
  # Everything OK: there is a constant #
  # on top of the stack.		#
  default:
  ermsg('constant expression required', lnr);
  r := 'u'
  esac
  else	r := 'u'
  fi;
  if name ~= ''
  then	new := symentry(name, level, 'C', r);
  fi;
  return([new, name])
  );
);


proc  p_data_field_declaration(dont_skip)
(
  # line: 554#
  f_ := f_init;
  imlab := cllab;
  #*******************************************************#
  # All code of initialisations is written to the		#
  # (temporary) .in file; it is copied to the .im file	#
  # at the end of the class declaration, to go with the	#
  # init-procedure. The labels in all the field initiali-	#
  # zations must be unique; cllab remembers the label	#
  # most recently used.					#
  #*******************************************************#
  if t_sy ~= 39 then testsym(s_39,dont_skip,'<data_field_declaration>') fi;
  if t_sy = 39
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_data_field_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_data_field_declaration_0_0,EMPTY,'') fi;
    if t_sy ~= 52 then testsymdd(s_52,dont_skip,r_data_field_declaration_0_1,'"identifier"') fi;
    while s_52[t_sy] = 1
    do
      p_field_initialization(dont_skip.disj(r_data_field_declaration_0_1_0_0));
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 52 then testsymdd(s_52,dont_skip,r_data_field_declaration_0_1_0_1,'<field_initialization>') fi;
      elif s_52[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 566#
  f_ := f_im;
  cllab := imlab;
);


proc  p_dyadic_symbol_declaration(dont_skip)
(
  if t_sy ~= 7 then testsym(s_7,dont_skip,'<dyadic_symbol_declaration>') fi;
  if t_sy = 7
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_dyadic_symbol_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_dyadic_symbol_declaration_0_0,EMPTY,'') fi;
    if t_sy ~= 54 then testsymdd(s_54,dont_skip,r_dyadic_symbol_declaration_0_1,'"operator_symbol"') fi;
    while s_54[t_sy] = 1
    do
      # line: 610#
      dytab[sy] :=
      array[sy || '.2', 2, -lnr, priofdef(2), priogdef(2)];
      nextsym;
      if dont_skip[t_sy]=0 & r_dyadic_symbol_declaration_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_dyadic_symbol_declaration_0_1_0_0,EMPTY,'') fi;
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 54 then testsymdd(s_54,dont_skip,r_dyadic_symbol_declaration_0_1_0_1,'"operator_symbol"') fi;
      elif s_54[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
);


proc  p_empty(dont_skip)
(
  );


proc  p_expression(dont_skip)
(
  # line: 671#
  opush(dytab[o_lpar]);
  if f_expression[t_sy]=0 then testsym(f_expression,dont_skip,'<expression>') fi;
  if f_expression[t_sy] = 1
  then
    p_monadic_expression(dont_skip.disj(r_expression_0_0));
    while s_54[t_sy] = 1
    do
      if t_sy = 54
      then
        # line: 673#
        check_dyop(sy);
        treatop(dytab[sy]);
        nextsym;
        if dont_skip[t_sy]=0 & r_expression_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_expression_0_1_0_0,EMPTY,'') fi;
        p_monadic_expression(dont_skip.disj(r_expression_0_1_0_1));
      fi;
    od;
  fi;
  # line: 676#
  emptystack();
);


proc  p_expression_list(dont_skip)
(
  # line: 794#
  var n := 0;
  if f_expression_list[t_sy]=0 then testsym(f_expression_list,dont_skip,'<expression_list>') fi;
  if f_expression_list[t_sy] = 1
  then
    while f_expression_list[t_sy] = 1
    do
      p_expression(dont_skip.disj(r_expression_list_0_0_0_0));
      # line: 795#
      n := n+1;
      if t_sy = 44
      then
        nextsym;
        if f_expression[t_sy]=0 then testsymdd(f_expression,dont_skip,r_expression_list_0_0_0_1,'<expression>') fi;
      elif f_expression[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
  fi;
  # line: 796#
  return(n);
  #***************************************************************#
  # Expression_list parses at least one expression;		#
  # empty alternatives are always included explicitly		#
  # in the calling rule.						#
  #***************************************************************#
);


proc  p_fetch_associations(dont_skip)
(
  # line: 406#
  var field;
  if t_sy ~= 13 & dont_skip[t_sy]=0 then testsymee(s_13,dont_skip,EMPTY, '') fi;
      if t_sy = 13
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_fetch_associations_0_0_0_0[t_sy]=0 then testsymee(dont_skip,r_fetch_associations_0_0_0_0,EMPTY,'') fi;
      if f_fetch_associations_0_0_0_1[t_sy]=0 then testsymdd(f_fetch_associations_0_0_0_1,dont_skip,r_fetch_associations_0_0_0_1,'"identifier" or "operator_symbol"') fi;
      while f_fetch_associations_0_0_0_1[t_sy] = 1
      do
        if f_fetch_associations_0_0_0_1_0_0[t_sy] = 1
        then
          if t_sy = 52
          then
            # line: 408#
            field := sy;
            nextsym;
            if dont_skip[t_sy]=0 & r_fetch_associations_0_0_0_1_0_0_0_0_0_0[t_sy]=0 then testsymee(dont_skip,r_fetch_associations_0_0_0_1_0_0_0_0_0_0,EMPTY,'') fi;
          elif t_sy = 54
          then
            # line: 408#
            field := sy;
            nextsym;
            if dont_skip[t_sy]=0 & r_fetch_associations_0_0_0_1_0_0_0_0_1_0[t_sy]=0 then testsymee(dont_skip,r_fetch_associations_0_0_0_1_0_0_0_0_1_0,EMPTY,'') fi;
          fi;
          if t_sy = 46
          then
            nextsym;
            if dont_skip[t_sy]=0 & r_fetch_associations_0_0_0_1_0_0_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_fetch_associations_0_0_0_1_0_0_0_1_0_0,EMPTY,'') fi;
            if t_sy = 52
            then
              # line: 410#
              fetchtab[field] := sy;
              assoctab[sy] := fetch_type;
              nextsym;
              if dont_skip[t_sy]=0 & r_fetch_associations_0_0_0_1_0_0_0_1_0_1[t_sy]=0 then testsymee(dont_skip,r_fetch_associations_0_0_0_1_0_0_0_1_0_1,EMPTY,'') fi;
            else error('"identifier"',lnr);
            fi;
          else
            p_empty(dont_skip.disj(r_fetch_associations_0_0_0_1_0_0_0_1_1_0));
            # line: 413#
            if field ~= undefined
            then	fetchtab[field] := '_s'
            fi;
          fi;
        fi;
        if t_sy = 44
        then
          nextsym;
          if f_fetch_associations_0_0_0_1_0_0[t_sy]=0 then testsymdd(f_fetch_associations_0_0_0_1_0_0,dont_skip,r_fetch_associations_0_0_0_1_0_1,'"identifier" or "operator_symbol"') fi;
        elif f_fetch_associations_0_0_0_1_0_0[t_sy] = 1
        then error('Separating ","',lnr);
        fi;
      od;
      if t_sy = 47
      then
        nextsym;
        if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
      else error('";"',lnr);
      fi;
    fi;
);


proc  p_field_initialization(dont_skip)
(
  # line: 575#
  var name := '',
  typ := '',
  stlnr := lnr;
  if t_sy ~= 52 then testsym(s_52,dont_skip,'<field_initialization>') fi;
  if t_sy = 52
  then
    # line: 579#
    name := sy;
    offset := offset+1;
    if fieldentry(name, [clname, VAR, offset, NIL, NIL, undefined])
    = 1
    then	symentry(name, level, 'c', '');
    data_flds := data_flds || sy || sc
    fi;
    typ := 'c' || sy;
    nextsym;
    if dont_skip[t_sy]=0 & r_field_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_field_initialization_0_0,EMPTY,'') fi;
    if t_sy = 54
    then
      # line: 588#
      if sy ~= ':='
      then	ermsg('":=" expected instead of "' || sy || '"', lnr)
      fi;
      ndpush(typ);
      nextsym;
      if dont_skip[t_sy]=0 & r_field_initialization_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_field_initialization_0_1_0_0,EMPTY,'') fi;
      p_expression(dont_skip);
      # line: 593#
      make_tuple(o_assign, 2);
      if errcnt = 0
      then	f_init.put('I:\t', stlnr, sc, ndpop(), sc,
      lnr, sc, newl)
      fi;
    fi;
  fi;
);


proc  p_for_expression(dont_skip)
(
  # line: 955#
  var typ, var1, var2;
  inloop := inloop + 1;
  lineinc();
  if t_sy ~= 15 then testsym(s_15,dont_skip,'<for_expression>') fi;
  if t_sy = 15
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_for_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_for_expression_0_0,EMPTY,'') fi;
    if t_sy = 52
    then
      # line: 960#
      typ := checktype(sy);
      if ~scan typ
      for lit('l') | lit('g') | lit('c') | lit('w') rof
      then	ermsg('illegal control variable in for loop', lnr)
      fi;
      if errcnt = 0
      then	if inproc = 1
      then	var1 := 'l' || string(loccnt);
      var2 := 'l' || string(loccnt + 1);
      loccnt := loccnt + 2;
      loclist := loclist || ',,'
      # to keep the relationship between local #
      # number and position in loclist valid   #
      # for the sake of the tracer. 	    #
      else	var1 := 'g' || nextglob();
      var2 := 'g' || nextglob()
      fi;
      ndpush(var1)
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_for_expression_0_1[t_sy]=0 then testsymee(dont_skip,r_for_expression_0_1,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    if t_sy = 18
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_for_expression_0_2[t_sy]=0 then testsymee(dont_skip,r_for_expression_0_2,EMPTY,'') fi;
    else error('"in"',lnr);
    fi;
    p_expression(dont_skip.disj(r_for_expression_0_3));
    # line: 980#
    ndpush(var2);
    ndpush(typ);
    if t_sy = 6
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_for_expression_0_4[t_sy]=0 then testsymee(dont_skip,r_for_expression_0_4,EMPTY,'') fi;
    else error('"do"',lnr);
    fi;
    p_block(dont_skip.disj(r_for_expression_0_5));
    if t_sy = 21
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"od"',lnr);
    fi;
  fi;
  # line: 983#
  make_tuple(o_for, 6);
  inloop := inloop - 1;
  #***************************************************************#
  # 'for x in c do e od' is translated as if it reads		#
  #	var1 := undefined;					#
  #	var2 := c;						#
  #	while [x,var1] := var2.next(var1) do e od;		#
  # On the im-file the operands are put out in the order		#
  # 	line increment, var1, c, var2, x, e			#
  #***************************************************************#
);


proc  p_formals_of_class(dont_skip)
(
  # line: 374#
  var n := 0, nms := '';
  if t_sy ~= 51 then testsym(s_51,dont_skip,'<formals_of_class>') fi;
  if t_sy = 51
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_formals_of_class_0_0[t_sy]=0 then testsymee(dont_skip,r_formals_of_class_0_0,EMPTY,'') fi;
    while s_52[t_sy] = 1
    do
      # line: 376#
      n := n+1;
      offset := offset + 1;
      if fieldentry(sy, [clname, VAR, offset, NIL, NIL, undefined])
      = 1
      then	symentry(sy, level, 'c', '');
      nms := nms || sy || sc
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_formals_of_class_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_formals_of_class_0_1_0_0,EMPTY,'') fi;
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 52 then testsymdd(s_52,dont_skip,r_formals_of_class_0_1_0_1,'"identifier"') fi;
      elif s_52[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 43
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('")"',lnr);
    fi;
  fi;
  # line: 384#
  return([n, nms]);
);


proc  p_formals_of_procedure(dont_skip)
(
  # line: 202#
  var n := 0, nms := '';
  if t_sy ~= 51 then testsym(s_51,dont_skip,'<formals_of_procedure>') fi;
  if t_sy = 51
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_formals_of_procedure_0_0[t_sy]=0 then testsymee(dont_skip,r_formals_of_procedure_0_0,EMPTY,'') fi;
    while s_52[t_sy] = 1
    do
      # line: 204#
      n := n+1;
      if symentry(sy, level, 'l', loccnt) = 1
      then	nms := nms || sy || sc
      fi;
      loccnt := loccnt + 1;
      nextsym;
      if dont_skip[t_sy]=0 & r_formals_of_procedure_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_formals_of_procedure_0_1_0_0,EMPTY,'') fi;
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 52 then testsymdd(s_52,dont_skip,r_formals_of_procedure_0_1_0_1,'"identifier"') fi;
      elif s_52[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 43
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('")"',lnr);
    fi;
  fi;
  # line: 210#
  return([n, nms]);
);


proc  p_global_initialization(dont_skip)
(
  # line: 94#
  var name := '',
  typ := '',
  stlnr := lnr;
  if t_sy ~= 52 then testsym(s_52,dont_skip,'<global_initialization>') fi;
  if t_sy = 52
  then
    # line: 98#
    name := sy;
    symentry(name, level, 'g', '');
    typ := 'g' || name;
    nextsym;
    if dont_skip[t_sy]=0 & r_global_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_global_initialization_0_0,EMPTY,'') fi;
    if t_sy = 54
    then
      # line: 102#
      if sy ~= ':='
      then	ermsg('":=" expected instead of "' || sy || '"', lnr)
      fi;
      ndpush(typ);
      nextsym;
      if dont_skip[t_sy]=0 & r_global_initialization_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_global_initialization_0_1_0_0,EMPTY,'') fi;
      p_expression(dont_skip);
      # line: 107#
      make_tuple(o_assign, 2);
      if errcnt = 0
      then	f_gl.put('I:\t', stlnr, sc, ndpop(), sc, lnr, sc, newl)
      fi;
    fi;
  fi;
  # line: 112#
  if errcnt = 0
  then	f_im.put(globhead, name, newl)
  fi;
);


proc  p_global_operator_declaration(dont_skip)
(
  var n_nms ;
  # line: 218#
  var name := '',
  stlnr := lnr,
  nf := 0,
  fnms := '',
  intname;
  n_nms := [0,0];
  loccnt := 0;
  proc_op_init();
  if t_sy ~= 23 then testsym(s_23,dont_skip,'<global_operator_declaration>') fi;
  if t_sy = 23
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_global_operator_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_global_operator_declaration_0_0,EMPTY,'') fi;
    if t_sy = 54
    then
      # line: 228#
      name := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_global_operator_declaration_0_1[t_sy]=0 then testsymee(dont_skip,r_global_operator_declaration_0_1,EMPTY,'') fi;
    else error('"operator_symbol"',lnr);
    fi;
    n_nms := p_formals_of_procedure(dont_skip.disj(r_global_operator_declaration_0_2));
    # line: 230#
    nf := n_nms[0];
    if ~ (1 <= nf <= 2)
    then	ermsg('operator should have one or two parameters', lnr)
    fi;
    fnms := loclist := n_nms[1];
    if name ~= ''
    then	var entry, stat, tab;
    intname := name || '.' || string(nf);
    tab := if nf = 1 then montab else dytab fi;
    entry := tab[name]; stat := 1;
    if   entry = undefined
    | entry[O_STATUS] < 0
    | entry[O_STATUS] = 3 & addglobf(intname) & stat := 2
    then tab[name] :=
    [intname, nf, stat, priofdef(nf), priogdef(nf)]
    else ermsg('global operator "' || name || '" redeclared', lnr)
    fi
    fi;
    #*******************************************************#
    # This creates a correct entry for the global operator	#
    # in montab or dytab. There are three (correct)		#
    # possibilities: The operator is completely new (entry	#
    # is undefined), it was declared in a MONADIC or DYADIC	#
    # statement (status < 0), or it was previously declared	#
    # within a class.					#
    #*******************************************************#
    if f_global_operator_declaration_0_3_0[t_sy] = 1
    then
      p_expression(dont_skip.disj(r_global_operator_declaration_0_3_0_0));
    else
      p_empty(dont_skip.disj(r_global_operator_declaration_0_3_1_0));
      # line: 259#
      ndpush('u')
    fi;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 261#
  proc_op_exit(intname, nf, fnms, stlnr);
);


proc  p_global_procedure_declaration(dont_skip)
(
  var n_nms ;
  # line: 173#
  var name := '',
  nf := 0,
  fnms := '',
  stlnr := lnr;
  loccnt := 0;
  proc_op_init();	
  if t_sy ~= 24 then testsym(s_24,dont_skip,'<global_procedure_declaration>') fi;
  if t_sy = 24
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_global_procedure_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_global_procedure_declaration_0_0,EMPTY,'') fi;
    if t_sy = 52
    then
      # line: 181#
      name := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_global_procedure_declaration_0_1[t_sy]=0 then testsymee(dont_skip,r_global_procedure_declaration_0_1,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    n_nms := p_formals_of_procedure(dont_skip.disj(r_global_procedure_declaration_0_2));
    # line: 183#
    nf := n_nms[0];
    loclist := fnms := n_nms[1];
    if name ~= ''
    then	symentry(name, level-1, 'gp', nf)
    fi;
    if f_global_procedure_declaration_0_3_0[t_sy] = 1
    then
      p_expression(dont_skip.disj(r_global_procedure_declaration_0_3_0_0));
    else
      p_empty(dont_skip.disj(r_global_procedure_declaration_0_3_1_0));
      # line: 189#
      ndpush('u');
    fi;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 191#
  proc_op_exit(name, nf, fnms, stlnr);
  #***************************************************************#
  # A 'code'-body (for procedures written in C and linked after	#
  # compilation) is no longer allowed!				#
  #***************************************************************#
);


proc  p_global_variable_declaration(dont_skip)
(
  # line: 75#
  f_ := f_gl;
  imlab := gllab;
  #*******************************************************#
  # All code for initializations of globals is written	#
  # to the .gl file. Labels occurring on that file must	#
  # be unique; "gllab" remembers the number of the last	#
  # label used.						#
  #*******************************************************#
  if t_sy ~= 39 then testsym(s_39,dont_skip,'<global_variable_declaration>') fi;
  if t_sy = 39
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_global_variable_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_global_variable_declaration_0_0,EMPTY,'') fi;
    if t_sy ~= 52 then testsymdd(s_52,dont_skip,r_global_variable_declaration_0_1,'"identifier"') fi;
    while s_52[t_sy] = 1
    do
      p_global_initialization(dont_skip.disj(r_global_variable_declaration_0_1_0_0));
      # line: 85#
      # INSERT REAL CODE HERE #
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 52 then testsymdd(s_52,dont_skip,r_global_variable_declaration_0_1_0_1,'<global_initialization>') fi;
      elif s_52[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 86#
  f_ := f_im;
  gllab := imlab;
);


proc  p_identifier_or_call(dont_skip)
(
  var n ;
  # line: 771#
  var typ;
  if t_sy ~= 52 then testsym(s_52,dont_skip,'<identifier_or_call>') fi;
  if t_sy = 52
  then
    # line: 773#
    typ := checktype(sy);
    ndpush(typ);
    nextsym;
    if dont_skip[t_sy]=0 & r_identifier_or_call_0_0[t_sy]=0 then testsymee(dont_skip,r_identifier_or_call_0_0,EMPTY,'') fi;
    if t_sy = 51
    then
      n := p_actuals(dont_skip);
      # line: 776#
      if scan typ for any('lnrSu') rof
      then	ermsg('illegal call', lnr)
      fi;
      ndpush(qn || string(n));
      make_tuple(o_call, n+2);
    fi;
  fi;
);


proc  p_if_body(dont_skip)
(
  # line: 870#
  lineinc();
  if f_if_body[t_sy]=0 then testsym(f_if_body,dont_skip,'<if_body>') fi;
  if f_if_body[t_sy] = 1
  then
    p_test(dont_skip.disj(r_if_body_0_0));
    if t_sy = 35
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_if_body_0_1[t_sy]=0 then testsymee(dont_skip,r_if_body_0_1,EMPTY,'') fi;
    else error('"then"',lnr);
    fi;
    p_block(dont_skip.disj(r_if_body_0_2));
    if t_sy = 8
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_if_body_0_3_0_0[t_sy]=0 then testsymee(dont_skip,r_if_body_0_3_0_0,EMPTY,'') fi;
      p_if_body(dont_skip);
      # line: 872#
      make_tuple(o_ifelse, 4);
    elif t_sy = 9
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_if_body_0_3_1_0[t_sy]=0 then testsymee(dont_skip,r_if_body_0_3_1_0,EMPTY,'') fi;
      p_block(dont_skip);
      # line: 872#
      make_tuple(o_ifelse, 4);
    else
      p_empty(dont_skip);
      # line: 874#
      make_tuple(o_ifthen, 3);
    fi;
  fi;
);


proc  p_if_expression(dont_skip)
(
  if t_sy ~= 17 then testsym(s_17,dont_skip,'<if_expression>') fi;
  if t_sy = 17
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_if_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_if_expression_0_0,EMPTY,'') fi;
    p_if_body(dont_skip.disj(r_if_expression_0_1));
    if t_sy = 14
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"fi"',lnr);
    fi;
  fi;
);


proc  p_include_file(dont_skip)
(
  if t_sy ~= 19 then testsym(s_19,dont_skip,'<include_file>') fi;
  if t_sy = 19
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_include_file_0_0[t_sy]=0 then testsymee(dont_skip,r_include_file_0_0,EMPTY,'') fi;
    if t_sy = 56
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_include_file_0_1[t_sy]=0 then testsymee(dont_skip,r_include_file_0_1,EMPTY,'') fi;
    else error('"string_constant"',lnr);
    fi;
    if t_sy = 47
    then
      # line: 653#
      if laststringcon = undefined
      then	ermsg('malformed include string', lnr);
      else	var s := laststringcon, f;
      if f := file(s, 'r') fails
      then ermsg('cannot open "' || s || '"', lnr)
      else	src_stack.append([f_src, src_name, line, lnr, lastlnr]);
      f_src := f;
      src_name := s;
      line := scan_string(f_src.get());
      lnr := 1;
      lastlnr := 1;
      fi
      fi;
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
);


proc  p_local_initialization(dont_skip)
(
  # line: 1206#
  var name := '',
  new := 0, typ, g := 0;
  if t_sy ~= 52 then testsym(s_52,dont_skip,'<local_initialization>') fi;
  if t_sy = 52
  then
    # line: 1209#
    name := sy;
    typ := 'l' || string(loccnt);
    new := symentry(sy, level, 'l', loccnt);
    loccnt := loccnt + 1;
    nextsym;
    if dont_skip[t_sy]=0 & r_local_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_local_initialization_0_0,EMPTY,'') fi;
    if t_sy = 54
    then
      # line: 1214#
      if sy ~= ':='
      then	ermsg('":=" expected instead of "' || sy || '"', lnr)
      fi;
      ndpush(typ);
      nextsym;
      if dont_skip[t_sy]=0 & r_local_initialization_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_local_initialization_0_1_0_0,EMPTY,'') fi;
      p_expression(dont_skip);
      # line: 1219#
      make_tuple(o_assign, 2);
      g := 1;
    else
      p_empty(dont_skip);
      # line: 1223#
      if inloop > 0
      then	ndpush(typ);
      ndpush('u');
      make_tuple(o_assign, 2);
      g := 1;
      fi;
    fi;
  fi;
  # line: 1230#
  return([new, name, g]);
  #***************************************************************#
  # All declarations of local variables are translated as assign-	#
  # ments, either of the initialisation expression, or of the	#
  # value 'undefined'. The latter is done to assure that variables#
  # local to a loop body are re-initialised on each new entry of	#
  # the body.							#
  #***************************************************************#
);


proc  p_local_variable_declaration(dont_skip)
(
  var li ;
  # line: 1184#
  var n := 0,
  nms := '';
  if inproc = 0
  then	ermsg('local variable declarations outside procedure',
  lnr)
  fi;
  if t_sy ~= 39 then testsym(s_39,dont_skip,'<local_variable_declaration>') fi;
  if t_sy = 39
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_local_variable_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_local_variable_declaration_0_0,EMPTY,'') fi;
    if t_sy ~= 52 then testsymdd(s_52,dont_skip,r_local_variable_declaration_0_1,'"identifier"') fi;
    while s_52[t_sy] = 1
    do
      li := p_local_initialization(dont_skip.disj(r_local_variable_declaration_0_1_0_0));
      # line: 1192#
      if li[0] = 1 then nms := nms || li[1] || sc fi;
      n := n + li[2];
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 52 then testsymdd(s_52,dont_skip,r_local_variable_declaration_0_1_0_1,'<local_initialization>') fi;
      elif s_52[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 1196#
  loclist := loclist || nms;
  return([n, nms]);
);


proc  p_monadic_expression(dont_skip)
(
  if f_monadic_expression[t_sy]=0 then testsym(f_monadic_expression,dont_skip,'<monadic_expression>') fi;
  if f_monadic_expression[t_sy] = 1
  then
    while t_sy = 54
    do
      # line: 682#
      check_monop(sy);
      treatop(montab[sy]);
      nextsym;
      if dont_skip[t_sy]=0 & r_monadic_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_monadic_expression_0_0,EMPTY,'') fi;
    od;
    p_primary(dont_skip);
  fi;
);


proc  p_monadic_symbol_declaration(dont_skip)
(
  if t_sy ~= 20 then testsym(s_20,dont_skip,'<monadic_symbol_declaration>') fi;
  if t_sy = 20
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_monadic_symbol_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_monadic_symbol_declaration_0_0,EMPTY,'') fi;
    if t_sy ~= 54 then testsymdd(s_54,dont_skip,r_monadic_symbol_declaration_0_1,'"operator_symbol"') fi;
    while s_54[t_sy] = 1
    do
      # line: 603#
      montab[sy] :=
      array[sy || '.1', 1, -lnr, priofdef(1), priogdef(1)];
      nextsym;
      if dont_skip[t_sy]=0 & r_monadic_symbol_declaration_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_monadic_symbol_declaration_0_1_0_0,EMPTY,'') fi;
      if t_sy = 44
      then
        nextsym;
        if t_sy ~= 54 then testsymdd(s_54,dont_skip,r_monadic_symbol_declaration_0_1_0_1,'"operator_symbol"') fi;
      elif s_54[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
);


proc  p_operator_field_declaration(dont_skip)
(
  var n_nms ;
  # line: 500#
  var name := '',
  stlnr := lnr,
  nf := 0,
  fnms := '',
  intname;
  nf := [0,0]; 
  loccnt := 1;
  proc_op_init();
  if t_sy ~= 23 then testsym(s_23,dont_skip,'<operator_field_declaration>') fi;
  if t_sy = 23
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_operator_field_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_operator_field_declaration_0_0,EMPTY,'') fi;
    if t_sy = 54
    then
      # line: 510#
      name := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_operator_field_declaration_0_1[t_sy]=0 then testsymee(dont_skip,r_operator_field_declaration_0_1,EMPTY,'') fi;
    else error('"operator_symbol"',lnr);
    fi;
    n_nms := p_formals_of_procedure(dont_skip.disj(r_operator_field_declaration_0_2));
    # line: 512#
    nf := n_nms[0] + 1;
    if nf > 2
    then	ermsg('operator has too many parameters', lnr)
    fi;
    fnms := loclist := n_nms[1];
    if name ~= ''
    then	var nm := name || '.' || string(nf), entry, tab;
    intname := nm || clsuffix;
    loclist := sc || loclist;
    if fieldentry(nm,
    [clname, PROC, intname, NIL, NIL, undefined]) = 1
    then	op_flds := op_flds || nm || sc
    fi;
    tab := if nf = 1 then montab else dytab fi;
    entry := tab[name];
    if entry = undefined | entry[O_STATUS] < 0
    then    tab[name] := [nm,nf,3,priofdef(nf),priogdef(nf)]
    elif entry[O_STATUS] = 1
    then    addglobf(nm); entry[O_STATUS] := 2
    fi
    fi;
    #*******************************************************#
    # A fieldentry and an entry in an operator table are	#
    # created. There are three legal possibilities: The	#
    # operator was never declared before; the operator was	#
    # declared in a MONADIC or DYADIC statement; the	#
    # operator was declared before as a global operator;	#
    # the operator was declared in a different class.	#
    # In the last case nothing needs to be done. Fieldentry	#
    # checks for redeclaration.				#
    #*******************************************************#
    if f_operator_field_declaration_0_3_0[t_sy] = 1
    then
      p_expression(dont_skip.disj(r_operator_field_declaration_0_3_0_0));
    else
      p_empty(dont_skip.disj(r_operator_field_declaration_0_3_1_0));
      # line: 546#
      ndpush('u')
    fi;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 548#
  proc_op_exit(intname, nf, fnms, stlnr);
);


proc  p_parenthesized_expression(dont_skip)
(
  if t_sy ~= 51 then testsym(s_51,dont_skip,'<parenthesized_expression>') fi;
  if t_sy = 51
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_parenthesized_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_parenthesized_expression_0_0,EMPTY,'') fi;
    p_block(dont_skip.disj(r_parenthesized_expression_0_1));
    if t_sy = 43
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('")"',lnr);
    fi;
  fi;
);


proc  p_primary(dont_skip)
(
  var a ;
  if f_primary[t_sy]=0 then testsym(f_primary,dont_skip,'<primary>') fi;
  if f_primary[t_sy] = 1
  then
    a := p_unit(dont_skip.disj(r_primary_0_0));
    while f_primary_0_1[t_sy] = 1
    do
      if t_sy = 48
      then
        # line: 689#
        if a[0] = 0
        then	ermsg('illegal subscription', lnr);
        a := a11;
        fi;
        p_subscript(dont_skip.disj(r_primary_0_1_0_0));
      elif t_sy = 45
      then
        # line: 694#
        if a[1] = 0
        then	ermsg('illegal field selection', lnr);
        a := a11;
        fi;
        p_select(dont_skip.disj(r_primary_0_1_1_0));
      fi;
    od;
  fi;
);


proc  p_procedure_field_declaration(dont_skip)
(
  var n_nms ;
  # line: 443#
  var name := '',
  intname := '',
  nf := 0,
  fnms := '',
  stlnr := lnr;
  loccnt := 1;
  proc_op_init();	
  if t_sy ~= 24 then testsym(s_24,dont_skip,'<procedure_field_declaration>') fi;
  if t_sy = 24
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_procedure_field_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_procedure_field_declaration_0_0,EMPTY,'') fi;
    if t_sy = 52
    then
      # line: 452#
      name := sy;
      nextsym;
      if dont_skip[t_sy]=0 & r_procedure_field_declaration_0_1[t_sy]=0 then testsymee(dont_skip,r_procedure_field_declaration_0_1,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    n_nms := p_formals_of_procedure(dont_skip.disj(r_procedure_field_declaration_0_2));
    # line: 454#
    nf := n_nms[0] + 1;
    # procedures and operators declared within	#
    # a class have an additional (invisible)	#
    # paarmeter: the class-object.			#
    loclist := fnms := n_nms[1];
    if name ~= ''
    then	loclist := sc || loclist;
    # for the sake of the tracer #
    intname := name || clsuffix;
    if assoctab[name] = store_type
    then if nf ~= 2
    then ermsg('store assoc "' || name ||
    '" should have one parameter', lnr)
    fi
    elif assoctab[name] = fetch_type
    then if nf ~= 1
    then ermsg('fetch assoc "' || name ||
    '" cannot have parameters', lnr)
    fi
    fi;
    if fieldentry(name,
    [clname, PROC, intname, NIL, NIL, undefined]
    ) = 1
    then	proc_flds := proc_flds || name || sc;
    symentry(name, level-1, 'c', '')
    # level has been incremented already to #
    # parse parameters.			#
    fi
    fi;
    if f_procedure_field_declaration_0_3_0[t_sy] = 1
    then
      p_expression(dont_skip.disj(r_procedure_field_declaration_0_3_0_0));
    else
      p_empty(dont_skip.disj(r_procedure_field_declaration_0_3_1_0));
      # line: 484#
      ndpush('u');
    fi;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('";"',lnr);
    fi;
  fi;
  # line: 486#
  proc_op_exit(intname, nf, fnms, stlnr);
  if assoctab[name] ~= undefined
  then	if retcnt ~= 1
  then	ermsg('fetch or store association "' ||
  name || '" does not return value', lnr)
  fi
  fi;
);


proc  p_program_declaration(dont_skip)
(
  var n_nms ;
  # line: 619#
  var name := '',
  nf := 0,
  stlnr,
  fnms := '';
  lastlnr := stlnr := lnr;
  loccnt := 0; loclist := empty_string; imlab := gllab;
  inproc := 1; level := level+1;
  if t_sy ~= 25 then testsym(s_25,dont_skip,'<program_declaration>') fi;
  if t_sy = 25
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_program_declaration_0_0[t_sy]=0 then testsymee(dont_skip,r_program_declaration_0_0,EMPTY,'') fi;
    if t_sy = 52
    then
      # line: 628#
      name := sy;
      if symtab[name] ~= undefined
      then	ermsg('"' || name || '" redeclared',lnr)
      fi;
      nextsym;
      if dont_skip[t_sy]=0 & r_program_declaration_0_1[t_sy]=0 then testsymee(dont_skip,r_program_declaration_0_1,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    n_nms := p_formals_of_procedure(dont_skip.disj(r_program_declaration_0_2));
    # line: 633#
    nf := n_nms[0];
    loclist := fnms := n_nms[1];
    if nf > 1
    then	ermsg('program can have at most one parameter', lnr)
    fi;
    if f_program_declaration_0_3_0[t_sy] = 1
    then
      p_expression(dont_skip.disj(r_program_declaration_0_3_0_0));
    else
      p_empty(dont_skip.disj(r_program_declaration_0_3_1_0));
      # line: 639#
      ndpush('u')
    fi;
    if t_sy = 47
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    fi;
  fi;
  # line: 641#
  inproc := 0;
  if errcnt = 0
  then	f_im.put(proghead, name, sc, convlocs(), sc, nf, sc, 
  loccnt-nf, sc, stlnr, sc, lnr, tabsym,
  ndpop(), sc, newl
  )
  fi;
  remove(fnms); level := level-1; gllab := imlab;
);


proc  p_return_expression(dont_skip)
(
  # line: 824#
  var n := 0;
  if f_return_expression[t_sy]=0 then testsym(f_return_expression,dont_skip,'<return_expression>') fi;
  if t_sy = 26
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_return_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_return_expression_0_0,EMPTY,'') fi;
    if t_sy = 51
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_return_expression_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_return_expression_0_1_0_0,EMPTY,'') fi;
      if f_return_expression_0_1_0_1_0[t_sy] = 1
      then
        p_expression(dont_skip.disj(r_return_expression_0_1_0_1_0_0));
        # line: 826#
        n := 1;
      else
        p_empty(dont_skip.disj(r_return_expression_0_1_0_1_1_0));
        # line: 828#
        ndpush('u');
      fi;
      if t_sy = 43
      then
        nextsym;
        if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
      else error('")"',lnr);
      fi;
    else
      p_empty(dont_skip);
      # line: 828#
      ndpush('u');
    fi;
    # line: 830#
    make_tuple(o_ret, 1);
    if retcnt = undefined
    then	retcnt := n
    elif retcnt ~= n
    then	ermsg('incompatible number of return values', lnr)
    fi;
  elif t_sy = 16
  then
    # line: 837#
    ndpush('f');
    #***************************************************************#
    # There is a slight deviation here from the syntax accepted	#
    # by the "formal" imlementation: this rule accepts "return"	#
    # as well as "return()", while the formal syntax only accepts	#
    # "return".							#
    #***************************************************************#
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  fi;
);


proc  p_scan_expression(dont_skip)
(
  if t_sy ~= 28 then testsym(s_28,dont_skip,'<scan_expression>') fi;
  if t_sy = 28
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_scan_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_scan_expression_0_0,EMPTY,'') fi;
    p_expression(dont_skip.disj(r_scan_expression_0_1));
    if t_sy = 15
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_scan_expression_0_2[t_sy]=0 then testsymee(dont_skip,r_scan_expression_0_2,EMPTY,'') fi;
    else error('"for"',lnr);
    fi;
    p_block(dont_skip.disj(r_scan_expression_0_3));
    if t_sy = 27
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"rof"',lnr);
    fi;
  fi;
  # line: 999#
  make_tuple(o_scanfor, 2);
);


proc  p_select(dont_skip)
(
  var n ;
  # line: 708#
  n := 0;
  if t_sy ~= 45 then testsym(s_45,dont_skip,'<select>') fi;
  if t_sy = 45
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_select_0_0[t_sy]=0 then testsymee(dont_skip,r_select_0_0,EMPTY,'') fi;
    if t_sy = 52
    then
      # line: 710#
      ndpush('w' || sy);
      nextsym;
      if dont_skip[t_sy]=0 & r_select_0_1[t_sy]=0 then testsymee(dont_skip,r_select_0_1,EMPTY,'') fi;
    else error('"identifier"',lnr);
    fi;
    if t_sy = 51
    then
      n := p_actuals(dont_skip);
    fi;
  fi;
  # line: 712#
  ndpush(qn || string(n+1));
  make_tuple(o_field, n+3);
);


proc  p_self(dont_skip)
(
  if t_sy ~= 29 then testsym(s_29,dont_skip,'<self>') fi;
  if t_sy = 29
  then
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  fi;
  # line: 808#
  ndpush('m');
  if clname = '' then ermsg('"self" used outside class', lnr) fi;
);


proc  p_size_definition(dont_skip)
(
  if t_sy ~= 51 then testsym(s_51,dont_skip,'<size_definition>') fi;
  if t_sy = 51
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_size_definition_0_0[t_sy]=0 then testsymee(dont_skip,r_size_definition_0_0,EMPTY,'') fi;
    p_expression(dont_skip.disj(r_size_definition_0_1));
    if t_sy = 44
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_size_definition_0_2[t_sy]=0 then testsymee(dont_skip,r_size_definition_0_2,EMPTY,'') fi;
    else error('","',lnr);
    fi;
    p_expression(dont_skip.disj(r_size_definition_0_3));
    if t_sy = 43
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('")"',lnr);
    fi;
  fi;
);


proc  p_store_associations(dont_skip)
(
  # line: 426#
  var field;
  if t_sy ~= 30 & dont_skip[t_sy]=0 then testsymee(s_30,dont_skip,EMPTY, '') fi;
      if t_sy = 30
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_store_associations_0_0_0_0[t_sy]=0 then testsymee(dont_skip,r_store_associations_0_0_0_0,EMPTY,'') fi;
      if f_store_associations_0_0_0_1[t_sy]=0 then testsymdd(f_store_associations_0_0_0_1,dont_skip,r_store_associations_0_0_0_1,'"identifier" or "operator_symbol"') fi;
      while f_store_associations_0_0_0_1[t_sy] = 1
      do
        if f_store_associations_0_0_0_1_0_0[t_sy] = 1
        then
          if t_sy = 52
          then
            # line: 428#
            field := sy;
            nextsym;
            if dont_skip[t_sy]=0 & r_store_associations_0_0_0_1_0_0_0_0_0_0[t_sy]=0 then testsymee(dont_skip,r_store_associations_0_0_0_1_0_0_0_0_0_0,EMPTY,'') fi;
          elif t_sy = 54
          then
            # line: 428#
            field := sy;
            nextsym;
            if dont_skip[t_sy]=0 & r_store_associations_0_0_0_1_0_0_0_0_1_0[t_sy]=0 then testsymee(dont_skip,r_store_associations_0_0_0_1_0_0_0_0_1_0,EMPTY,'') fi;
          fi;
          if t_sy = 46
          then
            nextsym;
            if dont_skip[t_sy]=0 & r_store_associations_0_0_0_1_0_0_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_store_associations_0_0_0_1_0_0_0_1_0_0,EMPTY,'') fi;
            if t_sy = 52
            then
              # line: 430#
              storetab[field] := sy;
              assoctab[sy] := store_type;
              nextsym;
              if dont_skip[t_sy]=0 & r_store_associations_0_0_0_1_0_0_0_1_0_1[t_sy]=0 then testsymee(dont_skip,r_store_associations_0_0_0_1_0_0_0_1_0_1,EMPTY,'') fi;
            else error('"identifier"',lnr);
            fi;
          else
            p_empty(dont_skip.disj(r_store_associations_0_0_0_1_0_0_0_1_1_0));
            # line: 433#
            if field ~= undefined
            then	storetab[field] := '_s'
            fi;
          fi;
        fi;
        if t_sy = 44
        then
          nextsym;
          if f_store_associations_0_0_0_1_0_0[t_sy]=0 then testsymdd(f_store_associations_0_0_0_1_0_0,dont_skip,r_store_associations_0_0_0_1_0_1,'"identifier" or "operator_symbol"') fi;
        elif f_store_associations_0_0_0_1_0_0[t_sy] = 1
        then error('Separating ","',lnr);
        fi;
      od;
      if t_sy = 47
      then
        nextsym;
        if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
      else error('";"',lnr);
      fi;
    fi;
);


proc  p_subclass_declaration(dont_skip)
(
  # line: 390#
  var super;
  if t_sy ~= 31 & dont_skip[t_sy]=0 then testsymee(s_31,dont_skip,EMPTY, '') fi;
      if t_sy = 31
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_subclass_declaration_0_0_0_0[t_sy]=0 then testsymee(dont_skip,r_subclass_declaration_0_0_0_0,EMPTY,'') fi;
      if t_sy = 22
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_subclass_declaration_0_0_0_1[t_sy]=0 then testsymee(dont_skip,r_subclass_declaration_0_0_0_1,EMPTY,'') fi;
      else error('"of"',lnr);
      fi;
      if t_sy = 52
      then
        # line: 392#
        super := sy;
        do_subclass(super);
        nextsym;
        if dont_skip[t_sy]=0 & r_subclass_declaration_0_0_0_2[t_sy]=0 then testsymee(dont_skip,r_subclass_declaration_0_0_0_2,EMPTY,'') fi;
      else error('"identifier"',lnr);
      fi;
      if t_sy = 47
      then
        nextsym;
        if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
      else error('";"',lnr);
      fi;
    fi;
  # line: 395#
  return(super);
);


proc  p_subject(dont_skip)
(
  if t_sy ~= 32 then testsym(s_32,dont_skip,'<subject>') fi;
  if t_sy = 32
  then
    nextsym;
    if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
  fi;
  # line: 815#
  ndpush('b');
);


proc  p_subscript(dont_skip)
(
  if t_sy ~= 48 then testsym(s_48,dont_skip,'<subscript>') fi;
  if t_sy = 48
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_subscript_0_0[t_sy]=0 then testsymee(dont_skip,r_subscript_0_0,EMPTY,'') fi;
    p_expression(dont_skip.disj(r_subscript_0_1));
    if t_sy = 49
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"]"',lnr);
    fi;
  fi;
  # line: 703#
  make_tuple(o_arind, 2);
);
program  p_summer_program(args)
(
  var dont_skip := s_57;
  var nms ;
  # line: 20#
  var cnms := '', prog := 0;
  pname := args[0];
  src_name := pname || '.sm';
  if f_src := file(src_name, 'r') fails
  then	cant(src_name);
  fi;
  if f_im := file(pname || '.im','w') fails
  then	cant(pname || '.im');
  fi;
  if f_gl := file(pname || '.gl','w') fails
  then	cant(pname || '.gl');
  fi;
  if f_st := file(pname || '.st','w') fails
  then	cant(pname || '.st');
  fi;
  if f_cs := file(pname || '.cs','w') fails
  then	cant(pname || '.cs');
  fi;
  if f_er := file(pname || '.er', 'w') fails
  then	cant(pname || '.er');
  fi;
  line := scan_string(f_src.get );
  lnr := 1;
  f_ := f_im;
  init_types();
  keytab['init'] := kartab['init'];
  #*******************************************************#
  # 'init' is a keyword, but the syntax of parsgen	#
  # does not allow writing it as INIT. Nevertheless, it	#
  # should be in keytab, in order to retrieve its type	#
  # correctly.						#
  #*******************************************************#
  nextsym;
  if f_summer_program[t_sy]=0 & dont_skip[t_sy]=0 then testsymee(f_summer_program,dont_skip,EMPTY, '') fi;
      while f_summer_program[t_sy] = 1
    do
      if t_sy = 39
      then
        p_global_variable_declaration(dont_skip.disj(r_summer_program_0_0_0_0));
      elif t_sy = 4
      then
        nms := p_constant_declaration(dont_skip.disj(r_summer_program_0_0_1_0));
        # line: 55#
        cnms := cnms || nms;
      elif t_sy = 24
      then
        p_global_procedure_declaration(dont_skip.disj(r_summer_program_0_0_2_0));
      elif t_sy = 23
      then
        p_global_operator_declaration(dont_skip.disj(r_summer_program_0_0_3_0));
      elif t_sy = 3
      then
        p_class_declaration(dont_skip.disj(r_summer_program_0_0_4_0));
      elif t_sy = 20
      then
        p_monadic_symbol_declaration(dont_skip.disj(r_summer_program_0_0_5_0));
      elif t_sy = 7
      then
        p_dyadic_symbol_declaration(dont_skip.disj(r_summer_program_0_0_6_0));
      elif t_sy = 25
      then
        p_program_declaration(dont_skip.disj(r_summer_program_0_0_7_0));
        # line: 57#
        if prog = 0
        then	prog := 1
        else	ermsg('multiple program declaration', lnr)
        fi;
      elif t_sy = 19
      then
        p_include_file(dont_skip.disj(r_summer_program_0_0_8_0));
      fi;
    od;
  # line: 62#
  if prog = 0
  then	ermsg('program declaration missing', lnr)
  fi;
  f_src.close ; f_cs.close ; f_gl.close ; f_st.close ;
  remove(cnms);
  make_decls();
  if errcnt = 0 then stop(0) else stop(1) fi;
  if errcnt > 0
  then stop(1)
  fi;
);


proc  p_table_element(dont_skip)
(
  # line: 1093#
  var m := 0;
  if f_table_element[t_sy]=0 then testsym(f_table_element,dont_skip,'<table_element>') fi;
  if f_table_element[t_sy] = 1
  then
    while f_table_element[t_sy] = 1
    do
      p_expression(dont_skip.disj(r_table_element_0_0_0_0));
      # line: 1095#
      m := m+1;
      if t_sy = 46
      then
        nextsym;
        if f_expression[t_sy]=0 then testsymdd(f_expression,dont_skip,r_table_element_0_0_0_1,'<expression>') fi;
      elif f_expression[t_sy] = 1
      then error('Separating ":"',lnr);
      fi;
    od;
  fi;
  # line: 1097#
  if m <= 1
  then	ermsg('key(s) missing in table', lnr)
  fi;
  ndpush(qn || string(m-1));
  make_tuple(o_key, m+1);
  return(m-1);
);


proc  p_table_element_tail(dont_skip)
(
  # line: 1141#
  var m := 1;	# the expression parsed already! #
  if f_table_element_tail[t_sy]=0 then testsym(f_table_element_tail,dont_skip,'<table_element_tail>') fi;
  if f_table_element_tail[t_sy] = 1
  then
    while f_table_element_tail[t_sy] = 1
    do
      p_expression(dont_skip.disj(r_table_element_tail_0_0_0_0));
      # line: 1143#
      m := m+1;
      if t_sy = 46
      then
        nextsym;
        if f_expression[t_sy]=0 then testsymdd(f_expression,dont_skip,r_table_element_tail_0_0_0_1,'<expression>') fi;
      elif f_expression[t_sy] = 1
      then error('Separating ":"',lnr);
      fi;
    od;
  fi;
  # line: 1145#
  ndpush(qn || string(m-1));
  make_tuple(o_key, m+1);
  return(m-1);
);


proc  p_table_expression(dont_skip)
(
  var nsum ;
  # line: 1068#
  nsum := [0,0];	# number of table_elements; number of keys #
  if t_sy ~= 34 then testsym(s_34,dont_skip,'<table_expression>') fi;
  if t_sy = 34
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_table_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_table_expression_0_0,EMPTY,'') fi;
    if f_table_expression_0_1[t_sy]=0 then testsym(f_table_expression_0_1,dont_skip,'"(" or "["') fi;
    if t_sy = 51
    then
      p_size_definition(dont_skip.disj(r_table_expression_0_1_0_0));
      if t_sy = 50
      then
        nextsym;
        if dont_skip[t_sy]=0 & r_table_expression_0_1_0_1_0_0[t_sy]=0 then testsymee(dont_skip,r_table_expression_0_1_0_1_0_0,EMPTY,'') fi;
        nsum := p_table_initialization(dont_skip);
        # line: 1072#
        # INSERT REAL CODE HERE #
      fi;
    elif t_sy = 48
    then
      # line: 1070#
      ndpush('n0'); ndpush('u');
      nsum := p_table_initialization(dont_skip);
      # line: 1072#
      # INSERT REAL CODE HERE #
    fi;
  fi;
  # line: 1073#
  ndpush(qn || string(nsum[0]));	# number of table_elements #
  ndpush(qn || string(nsum[1]));	# number of keys #
  make_tuple(o_tabinit, nsum[0]+4);
);


proc  p_table_initialization(dont_skip)
(
  var nk ;
  # line: 1081#
  var n := 0,
  sumk := 0;
  if t_sy ~= 48 then testsym(s_48,dont_skip,'<table_initialization>') fi;
  if t_sy = 48
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_table_initialization_0_0[t_sy]=0 then testsymee(dont_skip,r_table_initialization_0_0,EMPTY,'') fi;
    while f_table_initialization_0_1[t_sy] = 1
    do
      nk := p_table_element(dont_skip.disj(r_table_initialization_0_1_0_0));
      # line: 1084#
      n := n+1;
      sumk := sumk + nk;
      if t_sy = 44
      then
        nextsym;
        if f_table_element[t_sy]=0 then testsymdd(f_table_element,dont_skip,r_table_initialization_0_1_0_1,'<table_element>') fi;
      elif f_table_element[t_sy] = 1
      then error('Separating ","',lnr);
      fi;
    od;
    if t_sy = 49
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"]"',lnr);
    fi;
  fi;
  # line: 1087#
  return([n, sumk]);
);


proc  p_test(dont_skip)
(
  if f_test[t_sy]=0 then testsym(f_test,dont_skip,'<test>') fi;
  if f_test[t_sy] = 1
  then
    p_expression(dont_skip.disj(r_test_0_0));
    if t_sy = 12
    then
      # line: 880#
      make_tuple('~', 1);
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    elif t_sy = 33
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    fi;
  fi;
);


proc  p_try_expression(dont_skip)
(
  var n ;
  # line: 1007#
  lineinc();
  if t_sy ~= 36 then testsym(s_36,dont_skip,'<try_expression>') fi;
  if t_sy = 36
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_try_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_try_expression_0_0,EMPTY,'') fi;
    n := p_expression_list(dont_skip.disj(r_try_expression_0_1));
    # line: 1009#
    ndpush(qn || string(n));
    if t_sy = 38
    then
      # line: 1011#
      inloop := inloop + 1;
      nextsym;
      if dont_skip[t_sy]=0 & r_try_expression_0_2_0_0[t_sy]=0 then testsymee(dont_skip,r_try_expression_0_2_0_0,EMPTY,'') fi;
      p_block(dont_skip.disj(r_try_expression_0_2_0_1));
      # line: 1013#
      make_tuple(o_tru, n+3);
      inloop := inloop - 1;
    else
      p_empty(dont_skip.disj(r_try_expression_0_2_1_0));
      # line: 1016#
      ndpush(empty_string);
      make_tuple(o_try, n+3);
      #***************************************************************#
      # The code generated for the two forms of the try-statement	#
      # (with or without until) is nearly identical. The value	#
      # delivered is in the first case the value delivered by the	#
      # expression following 'until', and in the second case the value#
      # delivered by the succeeding expression in the list following	#
      # 'try'. This is signalled to the code-generator by the two	#
      # different operator forms.					#
      #***************************************************************#
    fi;
    if t_sy = 41
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"yrt"',lnr);
    fi;
  fi;
);


proc  p_unit(dont_skip)
(
  # line: 735#
  var a;
  if f_unit[t_sy]=0 then testsym(f_unit,dont_skip,'<unit>') fi;
  if f_unit_0[t_sy] = 1
  then
    p_constant(dont_skip);
    # line: 738#
    a := a01;
  elif t_sy = 52
  then
    p_identifier_or_call(dont_skip);
    # line: 739#
    a := a11;
  elif t_sy = 51
  then
    p_parenthesized_expression(dont_skip);
    # line: 739#
    a := a11;
  elif t_sy = 17
  then
    p_if_expression(dont_skip);
    # line: 739#
    a := a11;
  elif t_sy = 15
  then
    p_for_expression(dont_skip);
    # line: 737#
    a := a00;
  elif t_sy = 42
  then
    p_array_expression(dont_skip);
    # line: 739#
    a := a11;
  elif t_sy = 34
  then
    p_table_expression(dont_skip);
    # line: 739#
    a := a11;
  elif t_sy = 48
  then
    p_array_or_table_initialization(dont_skip);
    # line: 739#
    a := a11;
  elif t_sy = 2
  then
    p_case_expression(dont_skip);
    # line: 739#
    a := a11;
  elif t_sy = 40
  then
    p_while_expression(dont_skip);
    # line: 737#
    a := a00;
  elif f_unit_10[t_sy] = 1
  then
    p_return_expression(dont_skip);
    # line: 737#
    a := a00;
  elif t_sy = 28
  then
    p_scan_expression(dont_skip);
    # line: 739#
    a := a11;
  elif t_sy = 36
  then
    p_try_expression(dont_skip);
    # line: 739#
    a := a11;
  elif t_sy = 0
  then
    p_assert_expression(dont_skip);
    # line: 739#
    a := a11;
  elif t_sy = 29
  then
    p_self(dont_skip);
    # line: 739#
    a := a11;
  elif t_sy = 32
  then
    p_subject(dont_skip);
    # line: 739#
    a := a11;
  fi;
  # line: 741#
  return(a);
  #***************************************************************#
  # The formal syntax allows a subscript and a field selection	#
  # following each unit. In some cases, it is however easy to	#
  # detect that subscription and/or selection are illegal: e.g.	#
  # after a while-do expression, which does not yield a value,	#
  # both subscription and selection are illegal; a constant can	#
  # not be subscripted. Therefore, unit returns an array which	#
  # denotes  whether subscription (0) and field selection (1)	#
  # are allowed.							#
  #***************************************************************#
);


proc  p_while_expression(dont_skip)
(
  # line: 944#
  inloop := inloop + 1;
  lineinc();
  if t_sy ~= 40 then testsym(s_40,dont_skip,'<while_expression>') fi;
  if t_sy = 40
  then
    nextsym;
    if dont_skip[t_sy]=0 & r_while_expression_0_0[t_sy]=0 then testsymee(dont_skip,r_while_expression_0_0,EMPTY,'') fi;
    p_test(dont_skip.disj(r_while_expression_0_1));
    if t_sy = 6
    then
      nextsym;
      if dont_skip[t_sy]=0 & r_while_expression_0_2[t_sy]=0 then testsymee(dont_skip,r_while_expression_0_2,EMPTY,'') fi;
    else error('"do"',lnr);
    fi;
    p_block(dont_skip.disj(r_while_expression_0_3));
    if t_sy = 21
    then
      nextsym;
      if dont_skip[t_sy]=0 then testsym(dont_skip,EMPTY,'') fi;
    else error('"od"',lnr);
    fi;
  fi;
  # line: 947#
  make_tuple(o_whiledo, 3);
  inloop := inloop - 1;
);
