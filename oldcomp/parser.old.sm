const	sc		:= ',',
	lpar		:= '(',
	quote		:= '''',
	colon		:= ':',
	qn		:= 'n',
	newl		:= '\n',
	tabsym		:= '\t',
	NIL		:= '~nil',
	SIMPLE		:= '~simple',
	PROC		:= '~proc',
	VAR		:= '~var',
	coltab		:= ':\t',
	prochead	:= 'P:\t',
	classhead	:= 'C:\t',
	classbegin	:= 'CLASS:\t',
	globhead	:= 'G:\t',
	proghead	:= 'M:\t',

	o_assign	:= ':=',
	o_lpar		:= '(',
	o_whiledo	:= 'wd',
	o_ifthen	:= 'ift',
	o_ifelse	:= 'ife',
	o_scanfor	:= '?',
	o_for		:= 'fr',
	o_case		:= 'cs',
	o_arind		:= 'ind',
	o_field		:= 'fld',
	o_try		:= 'try',
	o_tru		:= 'tru',
	o_assert	:= 'as',
	o_semi		:= ';',
	o_call		:= 'cl',
	o_opcall	:= 'clo',
	o_arinit	:= 'ar',
	o_key		:= 'key',
	o_tabinit	:= 'tb',
	o_ret		:= 'rt',


	SETSIZE		:= 62,


	t_while		:= 0,
	t_return	:= 1,
	t_array		:= 2,
	t_table		:= 3,
	t_if		:= 4,
	t_try		:= 5,
	t_scan		:= 6,
	t_for		:= 7,
	t_case		:= 8,
	t_assert	:= 9,
	t_lp		:= 10,

	t_int		:= 11,
	t_real		:= 12,
	t_str		:= 13,
	t_undef		:= 14,
	t_freturn	:= 15,
	t_self		:= 16,
	t_subject	:= 17,
	t_ident		:= 18,
	t_monop		:= 19,
	t_dyop		:= 20,
	t_opseq		:= 21,
	t_bothop	:= 22,

	t_then		:= 23,
	t_else		:= 24,
	t_elif		:= 25,
	t_fi		:= 26,
	t_until		:= 27,
	t_yrt		:= 28,
	t_do		:= 29,
	t_od		:= 30,
	t_rof		:= 31,
	t_in		:= 32,
	t_of		:= 33,
	t_default	:= 34,
	t_esac		:= 35,
	t_fails		:= 36,
	t_succeeds	:= 37,
	t_proc		:= 38,
	t_op		:= 39,
	t_monadic	:= 40,
	t_dyadic	:= 41,
	t_class		:= 42,
	t_program	:= 43,
	t_var		:= 44,
	t_const		:= 45,
	t_include	:= 46,
	t_code		:= 47,
	t_begin		:= 48,
	t_end		:= 49,
	t_init		:= 50,
	t_subclass	:= 51,
	t_fetch		:= 52,
	t_store		:= 53,

	t_rp		:= 54,
	t_lbr		:= 55,
	t_rbr		:= 56,
	t_comma		:= 57,
	t_semi		:= 58,
	t_colon		:= 59,
	t_dot		:= 60,
	t_EOF		:= 61,

	upper		:= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
	lower		:= 'abcdefghijklmnopqrstuvwxyz',
	digit		:= '0123456789',
	alpha		:= 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
	alphanum	:= 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_',
	ASCII		:= ' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~',
	ops		:= '*+-/:<=>|&~!$%\\@?',
	empty		:= '',

	S_TYPE		:= 0,
	S_LEVEL		:= 1,
	S_NEXT		:= 2,

	F_CLNAME	:= 0,
	F_TYPE		:= 1,
	F_INTERN	:= 2,
	F_FETCH		:= 3,
	F_STORE		:= 4,
	F_NEXT		:= 5,

	O_NAME		:= 0,
	O_ADIC		:= 1,
	O_STATUS	:= 2,
	O_PRIOF		:= 3,
	O_PRIOG		:= 4;






#*************************** GENERAL GLOBAL VARIABLES *********************#


var	emptyset := bits(SETSIZE, 0),
		# The empty set #

	f_src,
		# File containing the summer source #
	f_er,
		# File containing error messages. They are not directed #
		# to standard output because backtracking on the file 	#
		# may be needed (because of procedure ar_or_tab).	#
		# 'errors = 0' is used to check whether the source	#
		# has been error free so far.				#
	f_st,
		# File containing symbolic strings			#
	f_im,
		# File containing the parsetrees of procedures,		#
		# operators and classes.				#
	f_gl,
		# File containing the parsetree for initialisations of	#
		# globals.						#
	f_init,
		# Scratch file used by 'classdecl' to assemble code	#
		# for initialisation of fields in classes.		#
	f_cs,
		# File containing the case tables.			#
	f_,
		# The current output file for tuples. It is initialized #
		# to f_im. Procedure 'var' sets it to either f_gl (for  #
		# initialisation of globals) or f_in (for initialisation#
		# of fields), and resets it to f_im before returning.	#
		# 'make_tuple' and 'var' itself write to _f.		#




	errors := 0,
		# remains 0 until an error occurs.			#
	errors_on_tab := table(5, undefined),
		# administrates on which files errors have occurred, in #
		# order to produce headings 'errors on ...' only when	#
		# necessary (see procedure errors).			#
	opstack := array(25, undefined),
	opstp := -1,
	osize := 25,
		# The operator stack, operator stackpointer (pointing	#
		# to the top of the stack), and initial stacksize.	#
		# The stack is pushed by procedure 'opush', popped by	#
		# 'opop'. Elements on opstack are entries from montab	#
		# and dytab.						#

	ndstack := array(25, undefined),
	ndstp := -1,
	ndsize := 25,
		# The operand stack, operand stack pointer (pointing	#
		# at the top of the stack), and initial stacksize.	#
		# Pushed by 'ndpush', popped by 'ndpop'. Entries on the	#
		# stack are operands.        				#
	src_stack := array(25, undefined),
	src_stp := -1,
		# Source file stack and source file stackpointer.	#
		# Pushed by 'include_file' with current source file,	#
		# current linenumber, and current line. Popped by 	#
		# 'nextsym' on encounter of EOF.			#
	symtab	  := table (100, undefined) init
	[	'string':	'real':		'integer':
		'scan_string':			   ['ab2', 0, undefined],
		'file':		'bits':		   ['ab3', 0, undefined],
		'interval':			   ['ab4', 0, undefined],
		'stop':		'copy':		'type':
						   ['gb1', 0, undefined],
		'put':		'get':		   ['gb?', 0, undefined],
		'stand_in':	'stand_out':	'stand_er':
						   ['g', 0, undefined]
	],
		# Symbol table. Keys are all variables defined at the	#
		# current source program point. Entries contain type,	#
		# level and pointer to namesake.			#

	fieldtab := table(50, undefined) init
	[  'any':    ['scan_string', PROC, 'any'  ,  'any',    NIL, undefined],
	   'break':  ['scan_string', PROC, 'break',  'break',  NIL, undefined],
	   'center': ['string',      PROC, 'center', 'center', NIL, undefined],
	   'close':  ['file',	     PROC, 'close',  'close',  NIL, undefined],
	   'compl':  ['bits',        PROC, 'compl',  'compl',  NIL, undefined],
	   'conj':   ['bits',        PROC, 'conj',   'conj',   NIL, undefined],
	   'disj':   ['bits',        PROC, 'disj',   'disj',   NIL, undefined],
	   'find':   ['scan_string', PROC, 'find',   'find',   NIL, undefined],
	   'get':    ['file',        PROC, 'get',    'get',    NIL, undefined],
	   'index':  ['array',       PROC, 'index',  'index',  NIL,
		      ['table',       PROC, 'index',  'index',  NIL,
		       ['string',      PROC, 'index',  'index',  NIL,
			['bits',	PROC, 'index',  'index',  NIL,
			 undefined
		     ]]]],
	   'left':   ['string',      PROC, 'left',   'left',   NIL, undefined],
	   'lit':    ['scan_string', PROC, 'lit',    'lit',    NIL, undefined],
	   'move':   ['scan_string', PROC, 'move',   'move',   NIL, undefined],
	   'next':   ['string',      PROC, 'next',   'next',   NIL,
		      ['array',       PROC, 'next',   'next',   NIL,
		       ['table',       PROC, 'next',   'next',   NIL,
		        ['bits',        PROC, 'next',   'next',   NIL,
                         undefined
                     ]]]],
	   'pos':    ['scan_string', PROC, 'pos',    'pos',    NIL, undefined],
	   'put':    ['file',        PROC, 'put',    'put',    NIL, undefined],
	   'repl':   ['string',      PROC, 'repl',   'repl',   NIL, undefined],
	   'replace':['string',      PROC, 'replace','replace',NIL, undefined],
	   'retrieve':['array',      PROC, 'retrieve',  'retrieve',  NIL,
		      ['table',       PROC, 'retrieve',  'retrieve',  NIL,
		       ['string',      PROC, 'retrieve',  'retrieve',  NIL,
			['bits',	PROC, 'retrieve',  'retrieve',  NIL,
			 undefined
		     ]]]],
	   'reverse':['string',      PROC, 'reverse','reverse',NIL, undefined],
	   'right':  ['string',      PROC, 'right',  'right',  NIL, undefined],
	   'rpos':   ['scan_string', PROC, 'rpos',   'rpos',   NIL, undefined],
	   'rtab':   ['scan_string', PROC, 'rtab',   'rtab',   NIL, undefined],
	   'size':   ['array',       PROC, 'size',   'size',   NIL,
		      ['bits',        PROC, 'size',   'size',   NIL,
		       ['string',      PROC, 'size',   'size',   NIL,
                        ['table',       PROC, 'size',   'size',   NIL,
		         undefined
		     ]]]],
	   'sort':   ['array',       PROC, 'sort',   'sort',   NIL, undefined],
	   'span':   ['scan_string', PROC, 'span',   'span',   NIL, undefined],
	   'substr': ['string',      PROC, 'substr', 'substr', NIL, undefined],
	   'tab':    ['scan_string', PROC, 'tab',    'tab',    NIL, undefined],
	   'update':['array',        PROC, 'update',  'update',  NIL,
		      ['table',       PROC, 'update',  'update',  NIL,
			['bits',	PROC, 'update',  'update',  NIL,
			 undefined
		     ]]],
	   'bal':    ['scan_string', PROC, 'bal',    'bal',    NIL, undefined],
	   'text':   ['scan_string', VAR,   0,        SIMPLE,  NIL, undefined],
	   'cursor': ['scan_string', VAR,   1,        SIMPLE,  NIL, undefined]
	],
	   	# Fieldtable. Keys are all field names defined up to the#
		# current program point. Entries consist of classname,	#
		# PROC or VAR, the internal name (for procedures) or the#
		# offset (for data-fields), the fetch association, the  #
                # store association, and a successor.			#
		# For operator fields, the key is the internal operator	#
		# name (without class suffix): for a monadic (dyadic)	#
		# operator @, '@.1' ('@.2').				#

        classtab := table(10, undefined),
		# Class table. Keys are classnames, entries are arrays	#
		# of five elements. The first one contains the number of#
		# datafields declared within the class (used by		#
		# 'make_decls'), the other four contain the fieldnames, #
		# separated according to their type: the seond element	#
		# contains the parameters, the third the remaining data-#
		# fields, the fourth the procedures, anf the fifth the	#
		# operators. These elements are used by 'do_subclass'	#
		# when a subclass is defined.				#

	inhertab := table(10, undefined),
		# During the parse of a subclass, inhertab contains	#
		# entries for fields which are inherited from the super-#
		# class and may still be redefined.			#

        fetchtab := table(5, undefined),
	storetab := table(5, undefined),
		# Keys are fieldnames occurring in respectively the	#
		# 'fetch' and the 'store' declaration of the current	#
		# class. Values are the associations ('_s' for simple,	#
		# or a name).						#

	assoctab := table(5, undefined),
		# keys are procedure names declared as associations,	#
		# values are t_fetch or t_store. Used to check whether	#
		# number of arguments and return values are correct.	#

	loclist := '',
		# Names of locals of the current procedure. Used to	#
		# produce string representing symbolic names (convlocs).#

	par_flds := '',
	data_flds := '',
	proc_flds := '',
	op_flds := '',
		# parameters, data fields and procedure and operator	#
		# fields of current class.				#
		# Names of fields of current class. Used by 'undefine'	#
		# to remove them from symtab on class exit.		#

	level := 0,
		# Current depth of name-nesting. Incremented on proce-	#
		# dure entry, on class entry and on block entry. Decre-	#
		# Used by 'symentry' to check for illegal redefinitions.#
	loccnt := 0,
		# Determines the offset of the next local variable to	#
		# be declared. For global procedures and operators, the	#
		# offset is initially 0; for classes and their associa-	#
		# ted procedures it is 1, as 0 is reserved for the class#
		# object passes as additional argument.			#
		# Because the tracer needs a unique mapping from local	#
		# numbers to associated names, the offset is not reset	#
		# on block exit. This does however cause an inefficient	#
		# use of space in the interpreter.			#

	classcnt := 0,
		# To determine class sequence number. Incremented on 	#
		# entry of a new class.					#

	clsuffix := '',
		# The current class suffix: '.' || classcnt. Used to	#
		# determine internal names of procedures and operators	#
		# defined within a class. (See proceduress 'procedure',#
		# 'operator', 'putopassoc' and 'putassocs'.		#
	retcnt,
		# The current number of return values in a procedure.	#
		# Is set to undefined on procedure entry, and reset to	#
		# 0 or 1 by 'mkrets'.					#

	slab := 0,
		# Determines the next string label. ('nextslab').	#
	clab := 0,
		# Determines the next case label. ('nextclab').		#
	glcnt := 0,
		# Determines the next global name invented by the	#
		# parser (see 'nextglob').				#
	imlab,
		# Determines the next label denoting a complex operand.	#
		# Reset to 0 on procedure entry, incremented for each	#
		# new complex operand by 'make_tuple'.			#
	cllab,
		# Guarantees continuity in the numbering of labels	#
		# denoting complex operands in initialisations of data	#
		# fields in a class. 'cllab' is set to 0 on class entry.#
		# It provides a strating value for 'imlab' when parsing	#
		# data field declarations (procedure 'vars') and is set	#
		# to the then current value of 'imlab' at the end of	#
		# such declarations. It also provides the starting value#
		# 'imlab' for parsing the class init statement.		#
	gllab := 0,
		# Plays a similar role for globals; provides the	#
		# starting value for 'imlab' when parsing global initia-#
		# lisations, and when parsing the main program body.	#
	offset,
		# The current class offset. Set to 0 on class entry,	#
		# incremented for each new data field.			#
	src_name,
		# The name of the current source file.			#
	pname,
		# Name of the summer source, without the .sm extension.	#
		# Used by 'error', 'make_decls', 'classdecl' and the	#
		# main program to construct the names of intermediate	#
		# files.						#
	clname,
		# The name of the current class. Used to make field-	#
		# entries ('procedure', 'vars', 'operator', 'params')	#
		# and to check whether a field is not redefined within	#
		# the same class ('fieldentry').			#
	intab := 0,
		# Flag to signal 'inside table initialisation'. Used by	#
		# 'parseop' according to the following rule: If an	#
		# unparsable dyadic operator is found of which the first#
		# symbol is a colon, and intab = 1, then the current	#
		# symbol becomes ':'. This just allows a statement like	#
		# 'x := table['a':-1, 'b':-2]'.				#
	inproc := 0,
		# Flag which signals whether the current program point	#
		# lies within a procedure, an operator, a class init	#
		# statement or the main program. Used by 'locvars' to	#
		# detect illegal local declarations (allowed only when	#
		# inproc = 1), and by 'forloop' to recognize whether it	#
		# must invent global or local variables.		#
	inparams := 0,
		# Flag to signal that the current program point is	#
		# within a formal parameter list. Used by 'illkeyword',	#
		# see there for an explanation.				#
	mess := '',
		# Mess remembers (part of) what has been skipped	#
		# on the last error condition. It enables 'expr'	#
		# to adequately deal with a rather frequently occurring	#
		# error: two adjacent expressions without separator.	#
		# Adjacency is tested by 'mess = empty', which means	#
		# that nothing has been skipped before return to expr.	#
		# Without this fix, untimely returns from expr to the	#
		# calling procedure happened quite frequently, caused	#
		# by the fact that symbols which can start an expression#
		# are frequent members of the dont_skip sets.		#
		# A typical example:					#
		# 'if not p() then..' instead of 'if ~ p() then...'.	#
		# 'mess' is also used by 'params' to decide whether a , #
		# is missing between two formal parameters.		#
	invars := 0,
		# Flag signalling whether the current program point lies#
		# within a variable declaration. Used to cancel the fix	#
		# explained above, which would preclude the detection	#
		# of missing comma's between declarations.		#

	inconst := 0;
		# Flag signalling whether the current program point lies#
		# within a constant declaration. Used as invars, but	#
		# also to delay parsetree output on the .im-file. The	#
		# expression parsed is supposedly constant, and will be	#
		# evaluated by c_eval and pushed back on the stack.	#


#*************************************************************************#
#*************************************************************************#
#**									**#
#**									**#
#**			SET HANDLING PROCEDURES				**#
#**									**#
#*************************************************************************#
#*************************************************************************#


proc SET(ar)
(	var set := bits(SETSIZE, 0), elem;

	for elem in ar
	do	set[elem] := 1 od;
	return(set)
);
	# Constructs a subset of all symbol types from an array of	#
	# integers: the bits to be set to 1.				#

proc UN(s1, s2)
	if type(s1) = 'integer'
	then	var set := copy(s2);
	
		set[s1] := 1;
		return(set)
	else	return(s1.disj(s2) )
	fi;
	# When s1 is an integer, the result is s2 with the s1-th bit	#
	# set to 1; otherwise the set union of s1 and s2.		#


	
proc MEM(elem,set)
	if set[elem] = 1
	then	return
	else	freturn
	fi;

#*************************************************************************#
#*************************************************************************#
#**									**#
#**			LEXICAL ANALYZER				**#
#**									**#
#*************************************************************************#
#*************************************************************************#


var	sy,
		# the current symbol.					#
	t_sy,
		# the current symbol type.				#
	lnr,
		# the current source line number.			#
	lastlnr := 1,
		# The source line number on which the most recent line	#
		# increment was generated. (Such an instruction enables	#
		# the interpreter and the tracer to compute source line	#
		# numbers from the ic-code). 'lastlnr' is set to lnr by #
		# 'lineinc' and each time an absolute linenumber is	#
		# generated in the code.				#
	line,
		# The current line (scan-string).			#



#*************************** TABLES *****************************************#

	keytab	:= table (40, t_ident) init
		[	'if':		t_if,
			'then':		t_then,
			'elif':		t_elif,
			'else':		t_else,
			'fi':		t_fi,
			'try':		t_try,
			'until':	t_until,
			'yrt':		t_yrt,
			'while':	t_while,
			'do':		t_do,
			'od':		t_od,
			'scan':		t_scan,
			'for':		t_for,
			'rof':		t_rof,
			'in':		t_in,
			'case':		t_case,
			'of':		t_of,
			'default':	t_default,
			'esac':		t_esac,
			'subject':	t_subject,
			'proc':		t_proc,
			'op':		t_op,
			'class':	t_class,
			'self':		t_self,
			'program':	t_program,
			'var':		t_var,
			'const':	t_const,
			'monadic':	t_monadic,
			'dyadic':	t_dyadic,
			'code':		t_code,
			'table':	t_table,
			'array':	t_array,
			'begin':	t_begin,
			'end':		t_end,
			'subclass':	t_subclass,
			'fetch':	t_fetch,
			'store':	t_store,
			'fails':	t_fails,
			'succeeds':	t_succeeds,
			'assert':	t_assert,
			'init':		t_init,
			'return':	t_return,
			'freturn':	t_freturn,
			'undefined':	t_undef,
			'include':	t_include
		],
		# keytab maps symbols with the syntax of an identifier	#
		# to a symbol type.					#






	montab := table (20, undefined) init
		[	'-' :		['-1', 1,0,13,14],
			'~' :		['~',  1,0,13,14]
                ],


        dytab := table(20, undefined) init
                [       ':=':           [':=', 2, 0,  7, 8],
                        '+' :           [ '+', 2, 0, 11,11],
                        '-' :           ['-2', 2, 0, 11,11],
                        '*' :           [ '*', 2, 0, 12,12],
                        '/' :           [ '/', 2, 0, 12,12],
                        '%' :           [ '%', 2, 0, 12,12],
                        '||':           ['||', 2, 0, 13,13],
                        '&' :           [ '&', 2, 0,  6, 6],
                        '|' :           [ '|', 2, 0,  4, 5],
                        '<' :           [ '<', 2, 0, 10,10],
                        '<=':           ['<=', 2, 0, 10,10],
                        '>' :           [ '>', 2, 0, 10,10],
                        '>=':           ['>=', 2, 0, 10,10],
                        '=' :           [ '=', 2, 0, 10,10],
                        '~=':           ['~=', 2, 0, 10,10],
                        '(' :           [ '(', 2, 0,  1, 2]
		],
		# 'montab' and 'dytab' map operator names to a 5-tuple,	#
		# consisting of the following items:			#
		# - An internal name (without class suffix). For user	#
		#   defined operators, this is their external name	#
		#   followed by a dot followed by 1 or 2 according to	#
		#   their adicity.					#
		# - A 1 for monadic and a 2 for dyadic operators.	#
		#   Entries from montab and dytab are stacked on the	#
		#   operator stack, and unstacked (by 'treatop' and	#
		#   'emptystack') without knowing from which table they #
		#   originally came. Hence the necessity to include the #
		#   adicity.						#
		# - A declaration status indicator:			#
		#   - 0 for build in, global operators.			#
		#   - 1 for user defined, global operators as yet 	#
		#     without a namesake within a class.		#
		#   - 2 for user defined, global operators with a name-	#
		#     sake within a class. User defined operators which #
		#     occur both globally and within a class, get an    #
                #     additional entry in 'fieldtab'. The 1 and 2 serve #
		#     to see whether this entry has been made already.	#
		#     (see also 'operator' and 'addglobf').		#
		#   - 3 for operators defined as yet only within a class#
		#     Built-in class operators don't occur as yet, but  #
		#     should get the same treatment as user defined	#
		#     ones, i.e. when a global namesake is defined, an  #
		#     additional entry must be amde in the fieldtable.  #
		#   - -lnr for operator names occurring in 'monadic' and#
		#     'dyadic' declarations, but not yet defined. lnr	#
		#     is the source line number on which the declaration#
		#     occurred, rememberd here in order to be able to	#
		#     issue an error message at the correct line when	#
		#     the operator remains undefined.			#
		#   - The f-priority.					#
		#   - The g-priority.					#
		#   See D ... for the meaning of the last two entries.	#
		#   All user defined operators get the same priority.   #

	optab   := table(20, t_opseq) init
		[	'-':				t_bothop,
		       '~':				t_monop,
			':':				t_colon,
			':=':	'+':	'*':	'/':
			'%':	'||':	'&':	'|':
			'<':    '<=':	'>':	'>=':
			'=': 	'~=':			t_dyop
		];
		# optab maps operator names to symbol type: t_monop	#
		# for monadic operators, t_dyop for dyadic ones, 	#
		# t_bothop for operators wich have a monadic as well as	#
		# a dyadic version, and (default) t_opseq for operators #
		# which cannot be identified and have to be unraveled	#
		# by 'parseop', like ':=-').				#



proc comment()
        while 'TRUE'
        do      if scan line for break('#') & lit('#') rof
		then	return
		elif line := scan_string(f_src.get ) & lnr := lnr+1 fails
		then	line := scan_string('');
			error('non closed comment', lnr); return
		fi
	od;

proc nextslab()	return('S' || string(slab := slab + 1));

proc octal(n)
(	var res := array(3,0);

	res[2] := string(n - (n:=n%8)*8);
	res[1] := string(n - (n:=n%8)*8);
	res[0] := string(n);
	return(res[0] || res[1] || res[2])
);
	# 'octal' converts an integer between 32 and 127 to the string	#
	# representation of the octal equivalent (32 to '040'). See	#
	# 'convstr'.							#

proc convstr(sz)
(	var cnt := 0,
	    res := array(sz,0),
	    c;


	lit(quote);
	while (~lit(quote) | lit(quote) & move(-1))
	do	res[cnt] :=
			if lit('\\')
			then	if   lit('\\')  then '134'
				elif lit('t')   then '011'
				elif lit('n')   then '012'
				elif lit('b')   then '010'
				elif lit('r')   then '015'
				elif c := (lit('0') | lit('1')) ||
				          any('01234567') ||
				          any('01234567')
				then	c
				else (error('illegal escape sequence in string',
					     lnr);
				      empty
				     )
				fi
			elif lit('\t') then '011'
			elif lit('\b') then '010'
			else(	  c := move(1) &
				  octal(scan ASCII for break(c) rof.size + 32)
				| error('illegal character in string', lnr) &
				  empty
			    )
			fi;
		cnt := cnt + 1
	od;
	if cnt = 0
	then	return('z')
	else	var i := 0,
		    sl := nextslab();
		f_st.put('dclstr\t', sl, sc, cnt, sc);
		for i in interval(0, cnt-2, 1)
		do	f_st.put(res[i], sc)	od;
		f_st.put(res[cnt-1], newl);
		return(sl)
	fi
);
	# 'convstr' produces the representation of a string on the .st	#
	# file, and returns the label invented for that string. (See	#
	# D ......).							#
	# 'convstr' is called within the scope of a 'scan .... for ...' #
	# with the cursor positioned before the opening quote.	 	#
	# The length of the string is determined in advance and passed	#
	# as an argument. During conversion, the converted characters	#
	# are stored in an array; 'sz' allows this array to be declared #
	# with approximately the right size. (In theory, the length of	#
	# a string is only limited by the maximum length allowed for	#
	# a source line, which can be anything). The main loop converts #
	# one character to its AsCII equivalent. Special characters	#
	# start with a '\', followed by either 't', 'n', 'b' or 'r',	#
	# (tab, newline, backspace, carriage return), or by a three	#
	# digit octal number between 000 and 177, which denotes the cor-#
	# responding AsCII value. A '\' itself is represented as '\\'.	#
	# The string AsCII contains all AsCII characters from blank	#
	# (040) up to and including '~' (176) in the right order. The	#
	# AsCII value of a character in this range is computed by	#
	# determining its position in the string AsCII, adding 32 (octal#
	# 40), and calling 'octal'. The only two characters outside this#
	# range which can be represented directly are TAB and BS (),	#
	# hence the lines ('elif lit('\t')...' and 'elif lit('\b')...'.	#
	# If per chance there are any others, a compiler error is issued#
	# The condition governing the 'while' looks strange but is	#
	# correct: If '~lit(quote)' fails, then lit(quote) has succeeded#
	# and the cursor is positioned now past the first quote.	#
	# As a quote itself is represented by '' within a string, the	#
	# alternative is peeking  ahead for a second quote (the cursor	#
	# is reset in order to get that quote converted).		#
	# 'convstr' is called by 'str' (with the current source line as	#
	# scan string), by 'convlocs' with the list of local names as	#
	# scan string), and by c_eval to convert a resultant string	#
	# constant to a string label.					#

proc get_str()
(	t_sy := t_str;
	scan line
	for	var s := cursor-1;

		while break(quote) & lit(quote || quote) do od;
		if ~lit(quote)
		then	error('newline not allowed in string', lnr);
			rtab(0)
		fi;
		if errors = 0
		then	s := cursor-s; move(-s); sy := convstr(s)
		else	sy := ''
		fi
	rof
);
	# get_str first							#
	# moves the cursor to the end of the string (or the end of the	#
	# line, which means an error) and then, if no errors have yet	#
	# occurred, back to the beginning after which 'convstr' is	#
	# called and its result passed on. 				#


proc get_number()
assert  scan line
	for   [sy, t_sy] := [sy || (span(digit) | empty), t_int] &
	      if sy := sy || lit('.') || (span(digit) | '')
	      then t_sy := t_real
	      fi &
	      if sy := sy || lit('e') ||
				    (lit('+') | lit('-') | '') || span(digit)
	      then t_sy := t_real
	      fi
	rof;


proc get_real_or_dot()
scan line
for   if sy := sy || span(digit) ||
		     (  lit('e') || (lit('+') | lit('-') | '') || span(digit)
		      | ''
		     )
      then t_sy := t_real
      else t_sy := t_dot
      fi
rof;

proc get_opname()
scan line
for	sy := sy || span(alphanum) | 'OK';
	if (t_sy := optab[sy]) ~= t_opseq
	then	return
	elif scan sy for lit('_') & any(alpha) & rtab(1) & lit('_') rof fails
	then	error('illegal operator name ' || sy, lnr)
	fi
rof;


proc nextsym()
while 'TRUE'
do line.span(' \t') | empty;
   if sy := line.any(alpha) || (line.span(alphanum) | '')
   then t_sy := keytab[sy];
	return
   elif sy := line.move(1)
   then case sy
	of	'0': '1': '2': '3': '4': '5': '6': '7': '8': '9':
							get_number();
							return,
		'.':
							get_real_or_dot();
							return,
		'''':
							get_str();
							return,
		'_':					get_opname();
							return,
		'*': '+': '-': '/': ':': '<': '=': '>': '?':
		'|': '&': '~': '!': '$': '%': '\\': '@':
							  sy := sy ||
							        line.span(ops)
							| 'OK';
							t_sy := optab[sy];
							return,
		'(':
							t_sy := t_lp;
							return,
		')':
							t_sy := t_rp;
							return,
		'[':
							t_sy := t_lbr;
							return,
		']':
							t_sy := t_rbr;
							return,
		',':
							t_sy := t_comma;
							return,
		';':
							t_sy := t_semi;
							return,
		'#':
							comment(),
		default:
			error('illegal character ' || sy, lnr)
	esac
   elif line := scan_string(get(f_src))
   then lnr := lnr + 1
   elif src_stp ~= -1
   then var os := src_name;

	f_src.close;
	[f_src, src_name, line, lnr] := src_stack[src_stp];
	src_stp := src_stp - 1;
	if errors_on_tab[os] ~= undefined
	then	errors_on_tab[src_name] := undefined
			# a new heading "errors on ..." must be produced #
			# if an error occurs.				 #
	fi;
   else sy := 'EOF';
	t_sy := t_EOF;
	return
   fi
od;
	# This comment needs to be updated.				#
	# 'nextsym' determines the next lexical symbol (in 'sy') and	#
	# its type (in 't_sy'). Lay out is skipped first.There are	#
	# seven alternatives:						#
	# 1. Identifiers and keywords. The symbol type is extracted from#
	#    'keytab'.							#
	# 2. Integers, and reals for so far they start with a digit	#
	#    (and not with a dot). After parsing a sequence of digits,	#
	#    type t_int is assigned. If that sequence is followed by	#
	#    either a dot (possibly followed by another string of 	#
	#    digits), or e [+|-|nothing] followed by a string of digits,#
	#    or both, the type is t_real.				#
	# 3. A single dot (type: t_dot), or a real denotation, starting #
	#    with a dot, which then must be followed by at least one	#
	#    digit. '.e3' is not a legal real denotation because of the	#
	#    difficulties it would cause 'nextsym' to distinguish	#
	#    between a field selection and a real at this point.	#
	# 4. A string. (See 'str' and 'convstr').			#
	# 5. An operator name, which is either a sequence of operator	#
	#    symbols or an identifier between underline's. Presence of	#
	#    the last underline is not tested here. The type is 	#
	#    extracted from 'optab'. 'nextsym' does not call 'parseop'	#
	#    to unravel sequences like ':=-', because to do so		#
	#    adequately, the type of operator expected must be known.	#
	# 6. A delimiter; the type is extracted from 'delimtab'.	#
	#    The delimiter ':' is entered with type t_colon in 'optab'.	#
	# 7. End-of-file, recognized by the fact that the cursor is	#
	#    positioned at the end of line.				#
	# If none of these alternatives succeeds, the next character is	#
	# an illegal one and is skipped, in which case 'nextsym' calls	#
	# itself to determine the next legal symbol.			#

proc illkeyword(expected, dont_skip)
(	var ident := 0;

	if   type(expected) = 'integer'
	then	if expected = t_ident then ident := 1 fi
	elif inparams = 1
	then	ident := 1
	else	if MEM(t_ident, expected)
		then	if symtab[sy] ~= undefined then ident := 1 fi
		fi
	fi;
	if ident = 1
	then	error('keyword ' || sy || ' in illegal context', lnr);
		t_sy := t_ident;
		return
	else	freturn
	fi
);
	# illkeyword decides whether a keyword occurring in the 	#
	# position of an identifier should be considered as such.	#
	# The most common mistake seems to be, to both declare and use  #
	# a keyword as an identifier. Hence the following rules:	#
	# - if a keyword occurs in a position where an identifier is the#
	#   only allowed symbol (i.e. in all declarations), then issue  #
	#   an error message 'keyword in illegal context'. No more	#
	#   symbols are skipped and the keyword will be entered in the	#
	#   symbol table.						#
	#   For parameters the same rule holds, tested by inparams.	#
	# - In all other cases, see whether the keyword is a declared	#
	#   variable. If so, again issue the message 'keyword in illegal#
	#   context', if not, return to the normal error recovery	#
	#   procedure.							#


proc testsym(expected, dont_skip, message)
(	assert MEM(t_EOF, UN(expected, dont_skip));
	mess := '';
	if
	   if type(expected) = 'integer'
	   then t_sy = expected
	   else MEM(t_sy, expected)
	   fi
	then	return
	elif keytab[sy] ~= t_ident & illkeyword(expected, dont_skip)
	then	return
	else(	var both := UN(expected, dont_skip),
		    nskipped := 0,
		    erlnr := lnr;
	
		while ~MEM(t_sy, both)
		do if nskipped < 6
		   then if nskipped < 5 then mess := mess || sy || ' '
					else mess := mess || sy || '... '
		        fi;
		        nskipped := nskipped + 1;
		   fi;
		   nextsym()
		od;
		if nskipped ~= 0
		then	mess := mess || 'skipped'
		fi;
		if erlnr ~= lnr
		then	mess := mess || '\n       scan resumed at ' || sy
		                || ' in line ' || string(lnr)
		fi;
		if MEM(t_sy, dont_skip) & message ~= empty
		then	message := message || '; ' || mess
		else	message := mess
		fi;
		if message ~= empty
		then	error(message, erlnr)
		fi
	    )
	fi;
);
	# 'testsym' is the central error recovery routine. It returns	#
	# immediately if the current symbol is a member of the set	#
	# 'expected'. Otherwise it constructs the union of 'expected'	#
	# and 'dont_skip', and finds the first symbol (possibly the	#
	# current) lying within that set. The third argument is a	#
	# message, printed only when the symbol found lies within the	#
	# 'dont_skip' set. In the other case, only the skipped symbols	#
	# are printed. (The message generally has the form '.. missing')#
	# 'message' is often empty. If in that case the current symbol	#
	# lies within the 'dont_skip' set, no message at all is 	#
	# generated, though an error has occurred. The call to testsym	#
	# will then however always be followed by a statement like	#
	# 'if t_sy ~= .. then error('... missing').			#




#*************************************************************************#
#*************************************************************************#
#**									**#
#**				ACTIONS					**#
#**									**#
#*************************************************************************#
#*************************************************************************#

proc comerror(m)
(	if src_stp ~= -1
	then	put(src_name, ' ')
	fi;
	put(string(lnr).right(5, ' '), ': compiler error; ', m, newl);
	stop(-1)
);

proc error(message, lnr)
(	if errors_on_tab[src_name] = undefined
	then	f_er.put(newl, 'errrors in ', src_name, ':', newl);
		errors_on_tab[src_name] := 1
	fi;
	f_er.put(string(lnr).right(5, ' ') , ': ', message, newl);
	errors := 1
);

proc nextglob() return('_' || string(glcnt := glcnt + 1));
	# returns a new global name invented by the parser. The syntax	#
	# is not that of a summer identifier or operator name, so it is #
	# guranteed to be unique. Used by 'caseclause' and by 'forloop'.#

proc enlarge(arr,step,size)
(	var newarr := array(size + step, undefined),
	    i;

        for i in arr.index do newarr[i] := arr[i] od;
	return(newarr)
);

#**************** Procedures for the treatment of operands **************#


proc ndpush(nd)
if errors = 0
then	if (ndstp := ndstp+1) >= ndsize
	then	ndstack := enlarge(ndstack,25,ndsize);
		ndsize:=ndsize + 25
	fi;
	ndstack[ndstp]:=nd
fi;

proc ndpop()
if errors = 0
then(	var nd;

	if ndstp < 0
	then	comerror('pop tried from empty operand stack')
	else	nd := ndstack[ndstp];
		ndstack[ndstp] := undefined;
		ndstp := ndstp - 1;
		return(nd)
	fi
    )
fi;
	# Pushing and popping the operand stack.			#



#********* Procedures to produce tuples on the intermediate file *******#



proc ord_def(n)
(	var o := array(n,0),
	    i;

	for i in o.index do o[i] := n-i-1 od;
	return(o)
);

proc ord_ass(n)		return([0,1]);

proc ord_semi(n)
(	var o := array(n,0),
	    i;

	for i in interval(1, n-1, 1)
	do o[i] := n-i od;
	return(o)
);	# o[0] = 0 #

proc ord_opcall(n)
	if n = 4
	then	return([1,0,3,2])
	elif n = 3
	then	return([1,0,2])
	else	comerror('in ord_opcall')
	fi;

proc ord_call(n)
(	var o := array(n,0) init [1],
	    i;

	for i in interval(1, n-2, 1)
	do	o[i] := n-i od;
	return(o)
);	# o[n-1] = 0 #

proc ord_fields(n)
(	var o := array(n,0) init [1],
	    i;

	for i in interval(1, n-3, 1)
	do o[i] := n-i od;
	o[n-1] := 2;
	return(o)
);	# o[n-2] = 0 #

proc ord_arinit(n)
(	var o := array(n,0),
	    i;

	for i in interval(1, n-3, 1)
	do o[i] := n-i-2 od;
	o[n-2] := n-2;
	o[n-1] := n-1;
	return(o)
);	# o[0] = 0 #

proc ord_key(n)
(	var o := array(n,0) init [0,1],
	    i;

	for i in interval(2,n-1,1)
	do o[i] := n-i+1 od;
	return(o)
);

proc ord_tabinit(n)
(	var o := array(n,0) init [0, 3],
	    i;
	for i in interval(2, n-3, 1)
	do o[i] := n-i+1 od;
	o[n-2] := 1;
	o[n-1] := 2;
	return(o)
);

proc ord_case(n)
(	var o := array(n, 0) init [3],
	    i;

	for i in interval(1, n-4, 1)
	do o[i] := n-i od;
	o[n-3] := 2;
	o[n-2] := 1;
	o[n-1] := 0;
	return(o)
);

proc ord_try(n)
(	var o := array(n, 0) init [n-1, 1],
	    i;

	for i in interval(2, n-2, 1)
	do o[i] := n-i od;
	return(o)
);	# o[n-1] = 0 #

proc ord_choice(opr, n)
return( case opr of
		o_assign:	ord_ass(n),
		o_semi:		ord_semi(n),
		o_call:		ord_call(n),
		o_opcall:	ord_opcall(n),
		o_field:	ord_fields(n),
		o_arinit:	ord_arinit(n),
		o_key:		ord_key(n),
		o_tabinit:	ord_tabinit(n),
		o_case:		ord_case(n),
		o_try:
		o_tru:		ord_try(n),
		default:	ord_def(n)
	esac
       );

	# The order in which the operands are pushed on the operand stack #
	# is not always the one in which they are needed by the code	  #
	# generator. The procedures starting with ord_ return an array	  #
	# in which the i-th index denotes the operand position in the	  #
	# final tuple, of the operand which is the i-th to be popped from #
	# the operand stack.						  #
	# For example, the operands of the operator call '10 @ 11' are	  #
	# popped from the stack in the order 'n2', 'o@.2', 'n11', 'n10',  #
	# but should appear on the im-file in the order 'o@.2', 'n2',	  #
	# 'n10', 'n11'. So for this case, 'ord_opcall' returns [1,0,2,3]. #
	# The argument of the ord_ procedures is the number of operands.  #
	# The default case is returned by 'ord_def', which if called with#
	# a number n as argument, returns the integers from n-1 to 0 in	  #
	# that order.							  #



proc make_tuple(opr, n)
if errors = 0
then	var ands, ord, i, lab;

	ord := ord_choice(opr, n);
	ands := array(n, ''); i:=0;
	for i in ands.index 
	do ands[ord[i]] := ndpop() od;
	if inconst = 1
	then	ndpush([opr, ands])
	else	lab := 'L' || string(imlab := imlab + 1);
		f_.put(lab || coltab || opr || tabsym);
		i:=0;
		for i in ands
		do f_.put(i, sc) od;
		f_.put(newl);
		ndpush(lab)
    	fi
fi;
	# Make-tuple writes labeled tuples to the current output file	#
	# assigned to the global 'f_'. Its possible values are 'f_im',	#
	# 'f_gl' or 'f_in'. The arguments of 'make_tuple' are an	#
	# operator and the number of operands. (For a listing of pos-	#
	# sible operators, see D.....). 'make_tuple' pops the right	#
	# number of operands from the operand stack, reorders them if	#
	# necessary, writes the new tuple (operator + operands) with a	#
	# label attached to them to the current output file, and pushes #
	# that label on the operand stack.				#



proc check(val, t_)
(	var ty := type(val);

	if   t_ = t_int & ty ~= 'integer'
	   | t_ = t_real & ty ~= 'integer' & ty ~= 'real'
	then	error('type error in constant declaration', lnr);
		freturn
	else	return(val)
	fi
);



proc c_eval(c)
if type(c) = 'array'
then	var opr := c[0],
	    ands := c[1],
	    i, r;

	for i in interval(0, ands.size -1, 1)
	do	if ands[i] := c_eval(ands[i]) fails
		then	freturn
		fi
	od;
	if case opr of
		'+':  r := check(ands[0], t_real) + check(ands[1], t_real),
		'-2': r := check(ands[0], t_real) - check(ands[1], t_real),
		'*':  r := check(ands[0], t_real) * check(ands[1], t_real),
		'/':  r := check(ands[1], t_real) &
		      if r = 0 then error('division by 0', lnr); freturn fi &
		      r := check(ands[0], t_real) / r,
		'%':  r := check(ands[1], t_int) &
		      if r = 0 then error('division by 0', lnr); freturn fi &
		      r := check(ands[0], t_int) % r,
		'-1': r := -check(ands[0], t_real),
		default:
		      (error('illegal expr in constant declaration', lnr);
 		      freturn; 0)
	  esac fails
	then	freturn
	else	return(r)
	fi
else	scan c
	for	if lit('n')
		then	return(integer(rtab(0)))
		elif lit('r')
		then	return(real(rtab(0)))
		elif lit('S') | lit('u') | lit('z')
		then	return(text)
		else error('right hand side not constant', lnr); freturn
		fi
	rof
fi;
	# c_eval evaluates a constant expression passed as an argument. #





#************ Procedures for the treatment of operators ****************#


proc parseop(t_exp, set)
(       var n := 0,
	    entry,
            opsy := sy;

        if t_exp = t_colon
        then    if scan sy for lit(':') rof
		then	line.move(- (sy.size - 1));
                        [sy, t_sy] := [':', t_colon];
                        return
		else	error(sy || ' skipped', lnr);
			nextsym(); testsym(set, emptyset, '');
			if t_sy = t_opseq
			then	parseop(t_colon, set)
			fi;
			return
                fi
	else	if scan sy for any(ops) rof
		then	while opsy ~= empty
	                do      entry := optab[opsy];
	                        if entry = t_exp | entry = t_bothop
				then	line.move(-n);
	                                [sy, t_sy] := [opsy, t_exp];
	                                return
	                        else    n := n+1;
	                                opsy := scan opsy for rtab(1) rof
	                        fi
	                od;
	                if intab = 1 & scan sy for lit(':') rof
	                then    line.move(-(sy.size - 1));
	                        [sy, t_sy] := [':', t_colon];
	                        return
	                fi
		fi
        fi;
	error('undeclared ' ||
	      if t_exp = t_monop then 'monadic' else 'dyadic' fi ||
	      ' operator ' || sy, lnr
	     );
	t_sy := t_exp
);
	# 'parseop' unravels sequences of operator symbols which don't	#
	# form a legal operator. Its arguments are the type of symbol	#
	# expected in the current context (t_monop, t_dyop or t_colon)	#
	# and a 'dont_skip' set which is relevant only if a colon is	#
	# expected. If in that case the current symbol does not start	#
	# with a colon, it is skipped and the next symbol is read, which#
	# should be contained in 'set'.					#
	# If a monadic or dyadic operator is expected, then parseop	#
	# looks for thew largest substring which is defined as an 	#
	# operator of the rquired type. This decision is never undone.	#
	# Suppose dyadic operators '@' and '@@' and a monadic operator	#
	# '@!' are defined. Then 'x @@! y' could be parsed as 'x @ @! y'#
	# but this parse is not found, as on the first call '@@' is	#
	# found. Writing blanks is obligatory in these cases.		#
	# The test whether sy is a sequence of operator symbols		#
	# precludes splitting the undefined operator '_a_b_' into	#
	# '_a_' and 'b_' if '_a_' happens to be defined.		#
	# If no parse for an operator can be found, and 'intab' equals 1#
	# then 'parseop' checks whether the sequence starts with an	#
	# colon. See comment on 'intab'.				#
        # of set.                                                       #


proc opush(opr)
if errors = 0
then	if (opstp := opstp + 1) >= osize
	then	opstack := enlarge(opstack, 25, osize);
		osize:=osize + 25
	fi;
	opstack[opstp] := opr
fi;

proc opop()
if errors = 0
then(	var opr;

	if opstp < 0
	then	comerror('pop tried from empty operator stack')
	else	opr := opstack[opstp];
		opstack[opstp] := undefined;
		opstp := opstp-1;
		return(opr)
	fi
    )
fi;
	# Pushing and popping the operator stack.			#


proc priofdef(nf)
	return(if nf = 1 then 13 else 9 fi);
	# The standard f-priorities (monadic: 13, dyadic: 9) for user	#
	# defined operators.						#

proc priogdef(nf)
	return(if nf = 1 then 14 else 9 fi);
	# The standard g-priorities for user defined operators.		#


proc treatop(newop)
if errors = 0
then(	var prg, oldop;

	prg := newop[O_PRIOG];
	while  opstack[opstp][O_PRIOF] >= prg
	do	oldop := opop();
		if oldop[O_STATUS] = 0
		then	make_tuple(oldop[O_NAME], oldop[O_ADIC])
		else	var a := oldop[O_ADIC];

			ndpush('o' || oldop[O_NAME]);
			ndpush(qn || string(a));
			make_tuple(o_opcall, a+2)
		fi
	od;
	opush(newop)
    )
fi;
	# The argument is an operator (or, more accurately, an entry	#
	# from 'montab' or 'dytab') to be pushed on the operator stack.	#
	# Before this is done, operators are popped from opstack and	#
	# handed to make_tuple until one is found with an f-priority	#
	# lower than the g-priority of the new operator. (See D......)	#
	# A left parenthesis has an f-priority lower than the g-priority#
	# of any operator and is hence never popped.			#
	# 'treatop' has to distinguish built-in from user defined	#
	# operators; the latter are operands of the operator 'o_opcall'.#
	# Before transferring such an operator to 'make_tuple', its	#
	# internal name and its number of arguments are pushed on the	#
	# operand stack.						#


proc emptystack()
if errors = 0
then(	var oldop;

	while opstp >= 0
	do	oldop := opop();
		if oldop[O_NAME] = lpar
		then	 return
		elif oldop[O_STATUS] = 0
		then	make_tuple(oldop[O_NAME], oldop[O_ADIC])
		else	var a := oldop[O_ADIC];

			ndpush('o' || oldop[O_NAME]);
			ndpush(qn || string(a));
			make_tuple(o_opcall, a+2)
		fi
	od
    )
fi;
	# Resembles 'treatop', but pops operators until either the	#
	# stack is empty or a left parenthesis (which is also popped)	#
	# is found.							#


proc resetstacks()
(	if ndsize > 25
	then	ndstack := array(25, undefined); ndsize := 25
	fi;
	if osize > 25
	then	opstack := array(25, undefined); osize := 25
	fi
);


#******************* Symbol table routines *****************************#




proc symentry(name, lev, entry)
(	var oldentry;

	oldentry := symtab[name];
	if   oldentry = undefined
	  | oldentry[S_LEVEL] ~= lev
	  | scan oldentry[S_TYPE]
	    for	 lit('forward') &
		 if scan entry for lit('C') rof
		 then	error('illegal forward reference(s) to constant ' ||
				name || '; first in line ' || rtab(0), lnr
			     )
		 fi
	    rof & oldentry := undefined
	then	symtab[name] := [entry, lev, oldentry];
		return(1)
	else	error(name || ' redeclared', lnr);
		return(0)
	fi
);
	# Enters 'name' in symtab with value 'entry'. If an entry with	#
	# the same level already exists which is not a forward declara-	#
	# tion, a 'redeclared' error is issued. See also 'level' and	#
	# 'symtab'. 							#

proc fieldentry(name, fdes)
(	var s := symtab[name],
	    f := fieldtab[name];

	if s ~= undefined
	then	if scan s[S_TYPE] for lit('forward') rof
		then	symtab[name] := undefined
		else	while s[S_NEXT] ~= undefined
			do	if scan s[S_NEXT][S_TYPE] for lit('forward') rof
				then	s[S_NEXT] := undefined
				else	s := s[S_NEXT]
				fi
			od;
			s := symtab[name]
		fi
	fi;
	if f ~= undefined & f[F_CLNAME] = clname
	then	if inhertab[name] ~= undefined
		then	redeffld(name, fdes);
			inhertab[name] := undefined;
		else	error(name || ' redeclared', lnr)
		fi;
		return(0)
	else	fdes[F_NEXT] := f;
		fieldtab[name] := fdes;
		return(1)
	fi
);
	# Enters 'name' into 'fieldtab' with value 'fdes'. If a forward	#
	# declaration for this name is found in symtab it is removed.	#
	# See 'make_decls' and D..... New entries are entered in front	#
	# of existing ones. This is used whenever it has to be checked	#
	# whether a name is defined as a field in the current class; if	#
	# it is, its entry is at the front: the test			#
	# 'fieldtab[name] ~= undefined & fieldtab[name][0] = clname'	#
	# suffices.							#
	# This procedure essentially uses the fact that arrays are not	#
	# copied when assigned to a variable.				#
	# See also 'addglobf'.						#

proc redeffld(name, fdes)
(	var old := fieldtab[name];

	if old[F_TYPE] = VAR
	then	if fdes[F_TYPE] ~= VAR
		then	error('inherited variable redefined as procedure', lnr)
		else	fdes[F_INTERN] := old[F_INTERN];
			offset := offset-1
		fi
	else	if fdes[F_TYPE] ~= PROC
		then	error('inherited procedure redefined as variable', lnr)
		fi
	fi;
	fdes[F_NEXT] := old[F_NEXT];
	fieldtab[name] := fdes
);
	# redeffld is called when a field inherited from a superclass is #
	# redefined in the subclass. The old entry is removed. Allowing  #
	# variables to be redefined as procedures and vice versa requires#
	# the following additions: if x was a var and becomes a proc, it #
	# must be removed from data_flds and added to proc_flds. All     #
	# offsets of data-fields > offset(x) must be decremented.     	 #
	# In the reverse case, x must be transferred from proc_flds to	 #
	# data_flds.							 #

proc addglobf(name)
(	var entry := fieldtab[name],
	    new   := ['~global', PROC, name, name, NIL, undefined];

	if entry = undefined
	then	entry := new
	else	while entry[F_NEXT] ~= undefined
		do entry := entry[F_NEXT] od;
		entry[F_NEXT] := new
	fi
);
	# 'addglobf' makes an additional entry with class name '~global'#
	# for user defined operators which are declared both globally	#
	# and within a class. The entry is added at the end of the list,#
	# this is required by the interpreter. As all other fieldentries#
	# are added at the front, it is guaranteed to remain the last.	#


proc locate_fld(fld, cl)
(	var e := fieldtab[fld];

	while e ~= undefined
	do if e[F_CLNAME] = cl then return(e) else e := e[F_NEXT] fi od;
	comerror('in locate_fld: fld ' || fld || ', class: ' || cl)
);
	# locate_fld finds the fieldtable entry created for field 'fld' #
	# in class 'cl'.						#


proc remove(names)
	scan names
	for	var s;
		while s := break(sc) & lit(sc) & symtab[s] := symtab[s][S_NEXT]
		do od
	rof;
	# 'undefine' resets the symbol table entries for the names in	#
	# its argument to their previous values. The names declared at	#
	# each level are explicitly remembered and passed as an argu-	#
	# ment instead of simply resetting all entries on the current	#
	# level, as this would require constructing the set of keys and	#
	# scanning the complete symbol table on each block exit; both	#
	# are expensive operations.					#

proc putopassoc(opname)
(	var mon := opname || '.1',
	    dy  := opname || '.2',
	    monentry := fieldtab[mon],
	    dyentry  := fieldtab[dy],
	    undef := 0;

	if monentry = undefined | monentry[F_CLNAME] ~= clname
	then	undef := undef+1
	else	fieldtab[mon][F_FETCH] := fieldtab[mon][F_INTERN]
	fi;
	if dyentry = undefined | dyentry[F_CLNAME] ~= clname
	then	undef := undef+1
	else	fieldtab[dy][F_FETCH] := fieldtab[dy][F_INTERN]
	fi;
	if undef = 2
	then	error('field ' || opname || ' undefined', lnr)
	fi
);
	# Puts fetch associations for an operator field in 'fieldtab'.	#
	# When, say, a declaration 'fetch @' is encountered, an entry	#
	# in 'fetchtab' is made with key '@' and value '_s'. A monadic	#
	# (dyadic) operator '@' declared within that class is entered	#
	# in 'fieldtab' with key '@.1' ('@.2'). 'Putopassoc' checks	#
	# whether the fetch association is indeed '_s' (the only one	#
	# allowed) and whether at least one version of @ is defined 	#
	# within the class, and adds the fetch association(s).	 	#

proc putassocs(type)
(	var field, fstab, ind, assoc;

	if type = t_fetch
	then	fstab := fetchtab; ind := F_FETCH
	else	fstab := storetab; ind := F_STORE
	fi;
	for field in fstab.index
	do assoc := fstab[field];
	   if assoc ~= '_s'
	   then	if fieldtab[assoc] = undefined |
	           fieldtab[assoc][F_CLNAME] ~= clname
	        then	error(   'fetch/store association '
			      || assoc || ' undeclared', lnr)
		elif fieldtab[assoc][F_TYPE] ~= PROC
		then	error('fetch/store association '
			      || assoc || ' is not a procedure', lnr)
		fi
	   fi;
	   if optab[field] ~= t_opseq
	   then if type = t_fetch & assoc = '_s'
		then putopassoc(field)
		else error('illegal ' ||
			   if type = t_fetch then 'fetch' else 'store' fi ||
			   ' association for ' || field, lnr
			  )
		fi
	   else	var entry;

		entry := fieldtab[field];
		if entry = undefined | entry[F_CLNAME] ~= clname
		then error('field ' || field || ' undeclared', lnr)
		elif entry[F_TYPE] = PROC
		then if type = t_fetch & assoc = '_s'
		     then fieldtab[field][F_FETCH] := entry[F_INTERN]
		     else error('illegal ' ||
				if type = t_fetch then 'fetch' else 'store' fi 
				|| ' association for ' || field, lnr
			       )
		    fi
		else	fieldtab[field][ind] :=
			  if assoc = '_s'
			  then SIMPLE else fieldtab[assoc][F_INTERN]
			  fi
		fi
	   fi
	od
);
	# Sets fetch or store associations for fields of the current	#
	# class, using the entries from 'fetchtab' or 'storetab'	#
	# (depending on the value of 'type').				#
	# 'putassocs' has to distinguish between operators, procedures	#
	# and data fields. For operators 'putopassoc' is called.	#
	# Procedures cannot have a store association. The only value	#
	# allowed for the fetch association in 'fetchtab' is '_s', but	#
	# the entry in 'fieldtab' will be the name of the procedure with#
	# the class suffix appended. Data fields can have both a fetch	#
	# and a store association; both can have value '~simple' or an	#
	# name of an associated procedure. 'putassocs' also check	#
	# whether all fields mentioned in 'fetch' and 'store' declara-	#
	# tions are indeed declared in the current class.		#
	# 'putopassoc' is called), procedures (which cannot have a store#
	# association and for which the only fetch association allowed	#


proc checktype(ident)
(	var entry := symtab[ident],
	    scope;

	if entry = undefined
	then	if fieldtab[ident] = undefined
		then	symentry(ident, 0,
				 'forward' || string(lnr) || '/' || src_name)
		fi;
		return('w' || ident)
	else	return( assert
			scan entry[S_TYPE]
			for	  lit('l') & entry[S_TYPE]
				| (lit('c') | lit('g') | lit('a')) || ident
				| lit('f') & ('w' || ident)
				| lit('C') &
				  scan rtab(0)
				  for if lit('-') & errors = 0
				      then ndpush(rtab(0));
					   make_tuple('-1', 1);
					   ndpop()
				      else text
				      fi
				  rof
			rof
		      )
	fi
);
	# identifies identifiers, returning the operand form required	#
	# by the im-file. (See D......). If the identifier is entered	#
	# neither in 'symtab' nor in 'fieldtab', it is put in 'symtab'	#
	# with type indication 'forward' followed by the current line	#
	# number. If the same identifier is encountered later on without#
	# intermediate declaration, its entry in symtab matches lit('f')#
	# Negative constants (say, -3) are put in the symbol table with	#
	# type 'C-n3'. Because no denotation for negative constants can #
	# occur in the parsetree, checktype takes care of the necessary	#
	# conversion.							#


proc lineinc()
(	ndpush('i' || string(lnr - lastlnr));
	lastlnr := lnr
);
	# line increment since last line instruction. See D....		#

proc convlocs()
	if loclist = ''
	then	return('nil')
	else	loclist := quote || loclist || quote;
		return(scan loclist for convstr(loclist.size ) rof)
	fi;
	# Constructs the string representation for the list of local	#
	# names (separated by comma's). The string label returned will	#
	# be part of a procedure heading (D......).			#


proc make_decls()
(	var dcl, nm, bl := ' ', e;

	if ~(dcl := file(pname || '.dc','w'))
	then	error('cannot open ' || pname || '.dc', lnr);
		stop(1)
	fi;
	f_er.put(newl);
	dcl.put('glcnt:\t', glcnt, newl);
	for nm in montab.index
	do	if (e := montab[nm][O_STATUS]) < 0
		then	error('undeclared monadic operator ' || nm, -e)
		fi
	od;
	for nm in dytab.index
	do	if (e := dytab[nm][O_STATUS]) < 0
		then	error('undeclared dyadic operator ' || nm, -e)
		fi
	od;
	for nm in symtab.index
	do	var x := symtab[nm], l, f;

		if scan x[S_TYPE]
		for lit('forward') & l := break('/') & lit('/') &
		    f := rtab(0)
		rof
		then if f ~= src_name
		     then error(f || ': ' || nm || ' undeclared', l)
		     else error(nm || ' undeclared', l)
		     fi
		elif errors = 0
		then	dcl.put(nm, coltab, x[S_TYPE], newl)
		fi
	od;
	if errors ~= 0 then return fi;
	dcl.put('endsyms', newl, 'classes', newl);
	for nm in classtab.index
	do	dcl.put(nm, sc, classtab[nm][0], newl) od;
	dcl.put('endclasses', newl, 'fields', newl, '');
	for nm in fieldtab.index
	do	var x := fieldtab[nm];

		dcl.put('fld\t', nm, newl);
		while x ~= undefined
		do	dcl.put(x[F_CLNAME], sc, x[F_TYPE], sc,
				 x[F_INTERN], sc, x[F_FETCH], sc, x[F_STORE],
				 newl
			   );
			x := x[F_NEXT]
		od;
	od;
	dcl.put('endfields', newl);
	dcl.close 
);
	# This procedure is called after completion of the parse of	#
	# the source program. It has two tasks: contsructing the dc-file#
	# and detecting undeclared identifiers.				#
	# For the format of the dc-file, see D.....			#
	# 'make-decl' performs (in that order) the following actions:	#
	# - It puts the number of globals invented by the parser on the	#
	#   dc-file.							#
	# - It scans 'montab' and 'dytab' to detect undefined operators,#
	#   i.e. operator names which occurred in 'monadic' and 'dyadic'#
	#   declarations without subsequent definition. They are	#
	#   recognized by a negative declaration status indicator, which#
	#   contains the source line number of the offensive declaration#
	# - It scans the symbol table, issuing error messages for any	#
	#   'forward' declarations that still remain, and writing	#
	#   identifier-type pairs to the dc-file.			#
	# - It scans the class table, writing class-size pairs to the	#
	#   dc-file.							#
	# - It scans the field table. Each entry in the list of entries	#
	#   for a certain field is put on a separate line.		#





#*************************************************************************#
#*************************************************************************#
#**									**#
#**			PARSER PROCEDURES.				**#
#**									**#
#*************************************************************************#
#*************************************************************************#



#******* SET declarations. All fixed set are allocated only once. *******#

var	s_startand	:= SET(	[t_int,
				 t_real,
				 t_str,
				 t_undef,
				 t_while,
				 t_return,
				 t_freturn,
				 t_array,
				 t_table,
				 t_if,
				 t_try,
				 t_scan,
				 t_for,
				 t_case,
				 t_assert,
				 t_lp,
				 t_self,
				 t_subject,
				 t_ident,
				 t_lbr
				]
			),
	s_startexpr	:= UN(SET([t_monop, t_opseq, t_bothop]), s_startand),
	s_dyop		:= SET([t_dyop, t_bothop, t_opseq]),
	s_op		:= SET([t_monop, t_dyop, t_bothop, t_opseq]),
	s_sem_com	:= SET([t_semi, t_comma]),
	s_lp_lbr	:= SET([t_lp, t_lbr]),
	s_com_rp	:= SET([t_comma, t_rp]),
	s_com_col	:= SET([t_comma, t_colon, t_opseq]),
	s_com_col_sem	:= SET([t_comma, t_colon, t_semi]),
	s_com_col_rbr	:= SET([t_comma, t_colon, t_opseq, t_rbr]),
	s_const_id	:= SET([t_int, t_real, t_str, t_undef, t_ident]),

	s_def_esac_expr := UN(SET([t_default, t_esac]), s_startexpr),
	s_id_in		:= SET([t_ident, t_in]),
	s_id_op		:= UN(t_ident, s_op),
	s_id_rp		:= SET([t_ident, t_rp]),
	s_until_yrt	:= SET([t_until, t_yrt]),
	s_iffi		:= SET([t_fails, t_succeeds, t_then, t_else, t_elif]),
	s_elif		:= SET([t_elif, t_else]),
	s_for_rof	:= SET([t_for, t_rof]),
	s_decl		:= UN(SET([t_comma, t_semi]), s_dyop),
	s_lbr_init	:= SET([t_lbr, t_init]),
	s_lbr_dot	:= SET([t_lbr, t_dot]),
	s_comma_rbr	:= SET([t_comma, t_rbr]),
	s_end_sem	:= SET([t_end, t_semi]),
	s_dy_expr	:= UN(s_dyop, s_startexpr),
	s_block	:= UN(SET([t_var, t_const]), s_startexpr),
	s_rp_expr	:= UN(t_rp, s_startexpr),
	s_od_expr	:= UN(t_od, s_startexpr),
        s_dood_expr     := UN(SET([t_fails, t_succeeds, t_do, t_od]),
			      s_startexpr),
	s_com_expr	:= UN(t_comma, s_startexpr),
	s_com_block	:= UN(SET([t_var, t_const]), s_com_expr),
	s_sem_expr	:= UN(t_semi, s_startexpr),
	s_com_col_expr	:= UN(s_com_col, s_startexpr),
	s_lbr_expr	:= UN(t_lbr, s_startexpr),
	s_rbr_expr	:= UN(t_rbr, s_startexpr),
	s_rp_block	:= UN(t_rp, s_block),
	s_in_expr	:= UN(t_in, s_startexpr),
	s_esac_block	:= UN(t_esac, s_block),
	s_prbody	:= UN(SET([t_code, t_semi]), s_startexpr),
	s_class		:= SET([t_var,
				t_const,
				t_proc,
				t_op,
				t_init,
				t_end]),
	s_sem_class	:= UN(t_semi, s_class),
	s_st_class	:= UN(t_store, s_class),
	s_fs_class	:= UN(t_fetch, s_st_class),
	s_sub_fs_class	:= UN(t_subclass, s_fs_class),
	s_bg_class	:= UN(t_begin, s_sub_fs_class),
	s_prog		:= SET([t_var,
				t_const,
				t_proc,
				t_op,
				t_class,
				t_monadic,
				t_dyadic,
				t_include,
				t_program,
				t_EOF]);



#***************************** procedures *******************************#


#
	__expr___________________________>
		|		|
		|		S (= , or ; )
		|___<__ expr____|

Exprlist should always at least parse one expression; empty alternatives
for exprlist are always included explicitly in the caller.
#

proc exprlist(dont_skip, sep)
(	var s1  := UN(s_startexpr, dont_skip),
	    s2 := UN(sep, s1),
	    sym := if sep = t_comma then ',' else ';' fi,
	    n := 1;

	expr(s2);
	while 'TRUE'
	do	if t_sy = sep
		then	nextsym();
			if sep = t_semi &
			   ~MEM(t_sy, s_startexpr) & MEM(t_sy, dont_skip)
			then	return(n)
				# to accept superfluous semicolons #
			else	expr(s2); n:=n+1
			fi
		elif MEM(t_sy, s_startexpr)
		then	error(sym || '  missing', lnr); expr(s2); n:=n+1
		elif MEM(t_sy, dont_skip)
		then	return(n)
		else	comerror('in exprlist, sy: ' || sy || 't_sy: '
				  || string(t_sy)
				)
		fi
	od
);


#
			 _______________
			|		|
	_____ ident_____|__ := __ expr__|________ ; _____>
	  |				    |
	  |________________<_______________ ,

#

proc locvars(dont_skip)
(	var s2 := UN(dont_skip, s_startexpr),
	    s3 := UN(s_decl, s2),
	    s4 := UN(dont_skip, s_sem_com),
	    n := 0,
	    nms := '',
	    name;

	invars := 1;
	if inproc = 0
	then	error('local variable declarations outside procedure', lnr)
	fi;
	while 'TRUE'
	do	testsym(t_ident, s3, 'identifier expected');
		if t_sy = t_ident
		then	name := sy;
			if symentry(sy, level, 'l' || string(loccnt)) = 1
			then	nms := nms || name || sc
			fi;
			loccnt := loccnt + 1;
			ndpush(symtab[name][S_TYPE]);
			nextsym(); testsym(s_decl, s2, '')
		else	name := nextglob();
		fi;
		if t_sy = t_opseq then parseop(t_dyop, s3) fi;
		if t_sy = t_dyop &
		   (sy = ':=' | error(sy || ' should be :=', lnr))
		then	nextsym();
			expr(s4)
		elif MEM(t_sy, s_startexpr)
		then	if   t_sy ~= t_ident | symtab[sy] ~= undefined
			then	error(':= assumed missing', lnr);
				expr(s4)
			fi
		else	ndpush('u')
		fi;
		make_tuple(o_assign, 2);
		n := n + 1;
		if t_sy = t_semi
		then	nextsym(); testsym(dont_skip, emptyset, '');
			invars := 0; loclist := loclist || nms;
			return([n, nms])
		elif t_sy = t_comma
		then	nextsym()
		elif t_sy = t_ident & symtab[sy] = undefined
		then	error(', missing', lnr)
		elif MEM(t_sy, dont_skip)
		then	error('; missing', lnr); invars := 0;
			loclist := loclist || nms; return([n, nms])
		elif t_sy ~= t_ident
		then	comerror('in vars, sy: ' || sy || ' t_sy: '
				  || string(t_sy)
				)
		fi
	od
);
	# All declarations of local variables are translated as assign-	#
	# ments, either of the initialisation expression, or of the	#
	# value 'undefined'. The latter is done to assure that variables#
	# local to a loop body are re-initialised on each new entry of	#
	# the body.							#
	# 'locvars' returns the number of variables declared and a	#
	# string consisting of their names, separated by comma's.	#



#
					 ___ STRING ____
					|		|
					|___ INTEGER ___|
        ___________ ident ___ ':=' _____|               |_________ ; ____>
                |                       |_____ REAL ____|      |
                |                       |               |      |
                |                       |_ 'undefined '_|      ,
                |                                              |
                |                                              |
                |____________________ < _______________________|
#

proc constdecl(dont_skip)
(	var s1 := UN(dont_skip, s_startexpr),
	    s2 := UN(s_decl, s1),
	    s3 := UN(dont_skip, s_sem_com),
	    name,
	    nms := '';

	inconst := 1;
	while 'TRUE'
	do	testsym(t_ident, s2, 'identifier expected');
		if t_sy = t_ident
		then	name := sy;
			nextsym();
			testsym(s_dyop, s2, '')
		else	name := nextglob();
		fi;
		if sy ~= ':='
		then	error(':= missing in constant declaration', lnr)
		fi;
		if MEM(t_sy, s_dyop)
		then	nextsym();
			testsym(s_startexpr, s2, '')
		fi;
		if MEM(t_sy, s_startexpr)
		then	var r;

			expr(s3);
			if errors = 0
			then r := (c_eval(ndpop()) | 'u');
			     if type(r) = 'integer'
			     then if r < 0 then r := '-' || 'n' || string(-r)
					   else r := 'n' || string(r)
				  fi
			     elif type(r) = 'real'
			     then if r < 0 then r := '-' || 'r' || string(-r)
					   else r := 'r' || string(r)
				  fi
			     elif type(r) ~= 'string'
			     then comerror('in constdecl; type = ' || type(r))
			     fi
			else r := 'u'
			fi;
			if symentry(name, level, 'C' || r) = 1
			then	nms := nms || name || sc
			fi;
		else	error('constant expression missing', lnr)
		fi;
		if t_sy = t_semi
		then	nextsym(); testsym(dont_skip, emptyset, '');
			inconst := 0; return(nms)
		elif t_sy = t_comma
		then	nextsym()
		elif t_sy = t_ident & symtab[sy] = undefined
		then	error(', missing', lnr)
		elif MEM(t_sy, dont_skip)
		then	error('; missing', lnr); inconst := 0; return(nms)
		elif t_sy ~= t_ident
		then	comerror('in constdecl, sy: ' || sy || ' t_sy: '
				  || string(t_sy)
				)
		fi
	od
);





#
                                         __ exprlist ___
                                        |               |
        ________________________________|               |______>
                |               |       |               |
                |               |       |               |
                |__ vardecl __<_|       |_______________|
#

proc block(dont_skip)
(	var s := UN(s_block, dont_skip),
	    nms := '',
	    cnms := '',
	    nvars := 0,
	    nexpr := 0,
	    nall;

	testsym(s, emptyset, '');
	level := level+1;
	while   t_sy = t_var &
	        (	var n, ns;

			nextsym(); [n,ns] := locvars(s);
			nvars := nvars + n; nms := nms || ns
		)
	      | t_sy = t_const &
		nextsym() & cnms := cnms || constdecl(s)
	do od;
	if MEM(t_sy, s_startexpr)
	then	nexpr := exprlist(dont_skip, t_semi);
	fi;
	nall := nvars + nexpr;
	if nall = 0
	then	ndpush('u')
	elif nall ~= 1
	then	ndpush(qn || string(nvars + nexpr));
		make_tuple(o_semi, nvars + nexpr + 1)
	fi;
	if nms ~= empty then remove(nms) fi;
	if cnms ~= empty then remove(cnms) fi;
	level := level - 1
);


#

		    _ 'succeeds'_
		   |		 |
	____ expr _|_ 'fails' ___|__ 'do' ___ block ____ 'od' ____>
		   |		 |
		   |_____________|

#

proc whiledo(dont_skip)
(	lineinc();
	expr(UN(dont_skip, s_dood_expr));
	if t_sy = t_fails & make_tuple('~', 1) | t_sy = t_succeeds
	then	nextsym(); testsym(t_do, UN(s_od_expr, dont_skip), '')
	fi;
	if t_sy ~= t_do
	then	error('do missing', lnr)
	else	nextsym()
	fi;
	block(UN(t_od, dont_skip));
	if t_sy ~= t_od
	then	error('od missing', lnr)
	else	nextsym(); testsym(dont_skip, emptyset, '')
	fi;
	make_tuple(o_whiledo, 3);
	return(0)
);



#
		 __ ( __ exprlist __ ) _
		|			|
	________|__ ( ______________ ) _|_______>
		|			|
		|_______________________|

#

proc mkrets(n)
(	make_tuple(o_ret, 1);
	if retcnt = undefined
	then	retcnt := n
	elif retcnt ~= n
	then	error('incompatible return expression', lnr)
	fi
);

proc ret(dont_skip)
(	var n;

	testsym(UN(t_lp, dont_skip), s_startexpr, '( missing');
	if t_sy = t_lp
	then	nextsym(); testsym(s_rp_expr, dont_skip, '')
	elif MEM(t_sy, dont_skip)
	then	ndpush(''); mkrets(0); return(0)
	fi;
	if MEM(t_sy, s_startexpr)
	then	expr(UN(t_rp, dont_skip)); n := 1
	else	ndpush(''); n := 0
	fi;
	if t_sy ~= t_rp
	then	error(') missing', lnr)
	else	nextsym(); testsym(dont_skip, emptyset, '')
	fi;
	mkrets(n);
	return(0)
);


#
	___ expr ___ , ___ expr ___ ) ___>
#

proc sizedef(dont_skip)
(	expr(UN(s_com_expr, dont_skip));
	if t_sy ~= t_comma
	then	error(', missing in size/default', lnr)
	else	nextsym()
	fi;
	expr(UN(t_rp, dont_skip));
	if t_sy ~= t_rp
	then	error(') missing in size/default', lnr)
	else	nextsym();
		testsym(dont_skip, emptyset, '')
	fi
);

#
				 _______________________________
				|				|
		 __ sizedef ____|				|_______>
		|		|				|
		|		|__ init ___ [ _ exprlist _ ] __|
	________|			  |
		|			  ^
		|_________________________|

#

proc arinit(dont_skip)
(	var n := 0;

	testsym(s_lp_lbr, UN(s_rbr_expr, dont_skip), '[ missing');
	if t_sy = t_lp
	then	nextsym(); sizedef(UN(s_lbr_init, dont_skip));
		if t_sy ~= t_init
		then	if t_sy ~= t_lbr
			then	ndpush('n0');
				make_tuple(o_arinit, 3);
				return(1)
			else	error('init missing', lnr)
			fi
		else	nextsym();
			testsym(t_lbr, UN(s_rbr_expr, dont_skip), '[ missing')
		fi
	else	ndpush('n0'); ndpush('u')
	fi;
	if t_sy = t_lbr
	then	nextsym(); testsym(s_rbr_expr, dont_skip, '')
	fi;
	if t_sy ~= t_rbr
	then	n := exprlist(UN(t_rbr, dont_skip), t_comma)
	fi;
	if t_sy = t_rbr
	then	nextsym(); testsym(dont_skip, emptyset, '')
	else	error('] missing', lnr)
	fi;
	ndpush(qn || string(n)); make_tuple(o_arinit, n+3);
	return(1)
);


#
	    __________________ expr _________________
		|	|		|	|
		|	|		:	,
		|	|
		|	|_______<_______|	|
		|				|
		|_______________<_______________|
#

proc tabelems(dont_skip)
(	var t := t_comma,
	    n := 0,
	    sumk := 0,
            s1 := UN(s_com_col_expr, dont_skip);

	while t = t_comma
	do(	var m := 0;

		t := t_colon;
		while t = t_colon
		do	expr(s1); m := m+1;
			if t_sy = t_opseq then parseop(t_colon, s1) fi;
			if MEM(t_sy, s_startexpr)
			then	error(': or , missing', lnr)
			elif t_sy = t_colon | t_sy = t_comma
			then	t := t_sy; nextsym()
			elif MEM(t_sy, dont_skip)
			then	t := undefined   # to get out both loops #
			else	comerror('in tabelems, sy: ' || sy ||
					 't_sy: ' || string(t_sy)
					)
			fi
		od;
		if m <= 1 then error('key(s) missing in table', lnr) fi;
		ndpush(qn || string(m-1));
		make_tuple(o_key, m+1);
		n := n+1; sumk := sumk + m;
	  )
	od;
	testsym(dont_skip, emptyset, '');
	return([n, sumk])
);

#
				 _______________________________
				|				|
		 __ sizedef ____|				|_______>
		|		|				|
                |		|__ init ___ [ _ tabelems _ ] __|
	________|			  |
		|			  ^
		|_________________________|

#

proc tabinit(dont_skip)
(       var n, sumk;

	testsym(s_lp_lbr, UN(s_rbr_expr, dont_skip), '[ missing');
	if t_sy = t_lp
	then    nextsym(); sizedef(UN(s_lbr_init, dont_skip));
		if t_sy ~= t_init
		then    if t_sy ~= t_lbr
			then	ndpush('n0');
				ndpush('n0');
				make_tuple(o_tabinit, 4);
				return(1)
			else    error('init missing', lnr)
			fi
		else    nextsym();
			testsym(t_lbr, UN(s_rbr_expr, dont_skip), '[ missing');
		fi
	else	ndpush('n0'); ndpush('u')
	fi;
	intab := 1;
	if t_sy = t_lbr
	then    nextsym(); testsym(s_rbr_expr, dont_skip, '')
	fi;
	if t_sy = t_rbr
	then	[n, sumk] := [0,0]
	else	intab := 1;
		[n, sumk] := tabelems(UN(t_rbr, dont_skip));
		intab := 0
	fi;
	if t_sy = t_rbr
	then    nextsym(); testsym(dont_skip, emptyset, '')
	else    error('] missing', lnr)
	fi;
	ndpush(qn || string(n));
	ndpush(qn || string(sumk));
	make_tuple(o_tabinit, n+4);
	return(1)
);



proc ar_or_tab(dont_skip)
(	var ar,
	    s := UN(s_com_col_rbr, dont_skip);

	intab := 1;
	  try	(nextsym(); testsym(s_startexpr, s, '');
		 if MEM(t_sy, s_startexpr) then expr(s) fi;
		 if t_sy = t_comma | t_sy = t_rbr
		 then	ar := 1
		 else	ar := 0
		 fi;
		 0 = 1	# which means "fail" #
		)
	  yrt
	| 'TRUE';
	intab := 0;
	if ar = 1 then arinit(dont_skip) else tabinit(dont_skip) fi;
	return(1)
);
	# ar_or_tab uses backtracking to decide whether an expression	#
	# starting with a left bracket is an array or a table initiali-	#
	# sation. The strategy is simple: "[]" is considered to be an	#
	# array; if the first symbol after an expression followinh the	#
	# left bracket is a comma, it is an array; else it is a table.	#
	# If the expression contains a syntactical error, ar_or_tab can	#
	# make the wrong decision which may result in unexpected error	#
	# messages.							#


#
				 ___ 'until' __ block __
				|			|
	_____ exprlist _________|			|____ 'yrt' ___>
				|_______________________|
#

proc try_yrt(dont_skip)
(	var n;

	lineinc();
	n := exprlist(UN(dont_skip, s_until_yrt), t_comma);
	ndpush(qn || string(n));
	if t_sy = t_until
	then	nextsym();
		block(UN(t_yrt, dont_skip));
		make_tuple(o_tru, n+3)
	else	ndpush(empty);
		make_tuple(o_try, n+3)
	fi;
	if t_sy = t_yrt
	then	nextsym(); testsym(dont_skip, emptyset, '')
	else	error('yrt missing', lnr)
	fi;
	return(1)
);
	# The code generated for the two forms of the try-statement	#
	# (with or without until) is nearly identical. The value	#
	# delivered is in the first case the value delivered by the	#
	# expression following 'until', and in the second case the value#
	# delivered by the succeeding expression in the list following	#
	# 'try'. This is signalled to the code-generator by the two	#
	# different operator forms.					#



#
              _ 'succeeds' _                      __ elif __ condexpr __
             |              |                    |                      |
   ___ expr _|_ 'fails' ____|__ then __ block ___|__ else ____ block ___|____>
             |              |                    |                      |
             |______________|                    |______________________|

#

proc condexpr(dont_skip)
(	var s1 := UN(s_elif, dont_skip);

	lineinc();
	expr(UN(s_iffi, dont_skip));
	if t_sy = t_fails & make_tuple('~', 1) | t_sy = t_succeeds
	then	nextsym(); testsym(t_then, s1, '')
	fi;
	if t_sy ~= t_then
	then	error('then missing', lnr)
	else	nextsym()
	fi;
	block(s1);
	if t_sy = t_elif
	then	nextsym(); condexpr(dont_skip);
		make_tuple(o_ifelse, 4)
	elif t_sy = t_else
	then	nextsym(); block(dont_skip);
		make_tuple(o_ifelse, 4)
	else	make_tuple(o_ifthen, 3)
	fi
);

#
	____ condexpr ____ fi ___>
#

proc iffi(dont_skip)
(	condexpr(UN(t_fi, dont_skip));
	if t_sy ~= t_fi
	then	error('fi missing', lnr)
	else	nextsym(); testsym(dont_skip, emptyset, '')
	fi;
	return(1)
);

#
	____ expr ____ for ____ block ____ rof
#

proc scanfor(dont_skip)
(	expr(UN(s_for_rof, dont_skip));
	if t_sy ~= t_for
	then	error('for missing', lnr)
	else	nextsym()
	fi;
	block(UN(t_rof, dont_skip));
	if t_sy ~= t_rof
	then	error('rof missing', lnr)
	else	nextsym(); testsym(dont_skip, emptyset, '?')
	fi;
	make_tuple(o_scanfor, 2);
	return(1)
);



#
	___ ident ___ 'in' ___ expr ___ 'do' ___ expr ___ 'od' ___
#

proc forloop(dont_skip)
(	var typ, var1, var2;

	lineinc();
	testsym(t_ident, UN(s_in_expr, dont_skip), 'identifier expected');
	if t_sy = t_ident
	then	typ := checktype(sy);
		if ~scan typ
		    for lit('l') | lit('g') | lit('c') | lit('w') rof
		then	error('illegal control variable in for loop', lnr)
		fi;
		nextsym();
		testsym(t_in, UN(s_startexpr, dont_skip), '')
	fi;
	if errors = 0
	then	if inproc = 1
		then	var1 := 'l' || string(loccnt);
			var2 := 'l' || string(loccnt + 1);
			loccnt := loccnt + 2;
			loclist := loclist || ',,'
				# to keep the relationship between local #
				# number and position in loclist valid	 #
				# for the sake of the tracer.		 #
		else	var1 := 'g' || nextglob();
			var2 := 'g' || nextglob()
		fi;
		ndpush(var1)
	fi;
	if t_sy = t_in
	then	nextsym()
	else	error('in missing', lnr)
	fi;
	expr(UN(s_dood_expr, dont_skip));
	ndpush(var2);
	ndpush(typ);
	if t_sy ~= t_do
	then	error('do missing', lnr)
	else	nextsym()
	fi;
	block(UN(t_od, dont_skip));
	if t_sy ~= t_od
	then	error('od missing', lnr)
	else	nextsym(); testsym(dont_skip, emptyset, '')
	fi;
	make_tuple(o_for, 6);
	return(0)
);
	# 'for x in c do e od' is translated as if it reads		#
	#	var1 := undefined;					#
	#	var2 := c;						#
	#	while [x,var1] := var2.next(var1) do e od;		#
	# On the im-file the operands are put out in the order		#
	# 	line increment, var1, c, var2, x, e			#



proc nextclab() return('C' || string(clab := clab + 1));

proc constcode()
	return( if t_sy = t_ident
		then	scan checktype(sy)
			for	if   lit('r') then 'real\t' || rtab(0)
				elif lit('n') then 'int\t'  || rtab(0)
				elif lit('u') then 'undef'
				elif lit('z') then 'nullstr'
				elif lit('S') then 'load\t' || text
				else error(sy || ' not constant', lnr); 1
				fi
			rof
		elif t_sy = t_int  then 'int\t' || sy
		elif t_sy = t_real then 'real\t' || sy
		elif t_sy = t_str
		then	if sy = 'z' then 'nullstr' else 'load\t' || sy fi
		elif t_sy = t_undef then 'undef'
		else	comerror(sy || ' not constant'); 1
		fi
	      );

#
				 ____ expr _____	 __ , __
				|		|	|	|
	_____ const ___ ':'_____|		|_______|	|____>
	  |		     |  |		|	|	|
	  |________<_________|  |_______________|	|_______|
#

proc case_elems(dont_skip)
(	var n := 0,
	    s1 := UN(s_com_block, dont_skip),
	    s2 := UN(t_colon, s1);

	testsym(s1, emptyset, '');
	while 'TRUE'
	do	if MEM(t_sy, s_const_id) &
		   try( if errors = 0
			then	f_cs.put(constcode(), newl)
			fi;
			nextsym();
			if t_sy = t_colon
			then	nextsym(); testsym(s1, emptyset, '')
			else	0=1	# fail #
			fi)
		   yrt
		then	n := n+1
		else	if n = 0
			then error('key(s) missing in case statement', lnr)
			fi;
			block(s2);
			if t_sy = t_colon
			then	error('key in case not constant', lnr);
				nextsym(); testsym(s1, emptyset, '')
			elif MEM(t_sy, s_startexpr)
			then	error(': or , missing', lnr)
			fi;
			if  t_sy = t_comma & nextsym() &
			    if t_sy = t_esac then error(', skipped', lnr) fi &
			    testsym(dont_skip, emptyset, '')
			  | MEM(t_sy, dont_skip)
			then	if errors = 0
				then	f_cs.put('tabelem\t', n, newl)
				fi;
				return
			fi
		fi
	od
);
        # Each iteration parses either (constant ':') or an expression. #
	# Backtracking is used to fail when a constant is not followed	#
	# by a colon, in which case it is assumed to be (the start of)	#
	# an expression.						#
	# A (not constant) expression followed by a colon is considered	#
	# an illegal key.						#

#
						 _'default'_:__expr_
						|		    |
	__ expr __ 'of' ________________________|		    |_ 'esac'_>
			|		    |   |		    |
			|__<__ case_elems __|   |___________________|

#

proc caseclause(dont_skip)
(	var n := 0, clab, deflab, gnm,
	    s1 := UN(s_def_esac_expr, dont_skip);

	lineinc();
	expr(UN(t_of, dont_skip));
	if t_sy ~= t_of
	then	error('of missing', lnr)
	else	nextsym();
		testsym(s_def_esac_expr, dont_skip, '')
	fi;
	if errors = 0
	then	deflab := nextclab();
		f_cs.put('load\t', deflab, newl, 'int\t30\n', 'tabinit\n');
		gnm := nextglob();
		ndpush('g' || gnm)
	fi;
	while MEM(t_sy, s_startexpr)
	do	if errors = 0
		then	clab := nextclab();
			ndpush(clab);
			f_cs.put('load\t', clab, newl);
		fi;
		case_elems(s1);
		n := n+1
	od;
	ndpush(deflab);
	if t_sy = t_default
	then	nextsym();
		testsym(t_colon, UN(s_esac_block, dont_skip), ': missing');
		if t_sy = t_colon
		then	nextsym()
		fi;
		if MEM(t_sy, s_block)
		then	block(UN(t_esac, dont_skip))
		else	ndpush('u')
		fi;
	else	ndpush('')
	fi;
	if t_sy ~= t_esac
	then	error('esac missing', lnr)
	else	nextsym(); testsym(dont_skip, emptyset, '')
	fi;
	if errors = 0
	then	f_cs.put('asglob\t', gnm, newl, 'void', newl);
		ndpush(qn || string(n));
		make_tuple(o_case, 2*(n+1)+4)
	fi;
	return(1)
);

#
	--- 'assert' ---- expr ----->
#

proc assertion(dont_skip)
(	expr(dont_skip);
	make_tuple(o_assert, 1);
	return(0)
);



#
		 ____ block ____
		|		|
	________|		|___ ) ___>
		|___ exprlist __|
#

proc parexpr(dont_skip)
(	var n := 0; 

	testsym(s_rp_block, dont_skip, '');
	if t_sy = t_var | t_sy = t_const
	then	block(UN(t_rp, dont_skip))
	elif	MEM(t_sy, s_startexpr)
	then	n := exprlist(UN(t_rp, dont_skip), t_semi);
		if n > 1
		then	ndpush(qn || string(n));
			make_tuple(o_semi, n+1)
		fi
	else	# expression () # ndpush('u')
	fi;
	if t_sy ~= t_rp
	then	error(') missing', lnr)
	else	nextsym(); testsym(dont_skip, emptyset, '')
	fi;
	return(1)
);



#
	____ expr ___ ] ___>
#

proc indic(dont_skip)
(	expr(UN(t_rbr, dont_skip));
	if t_sy ~= t_rbr
	then	error('] missing', lnr)
	else	nextsym(); testsym(dont_skip, emptyset, '')
	fi;
	make_tuple(o_arind, 2)
);



#		 __ exprlist ___
		|		|
	________|		|____ ) ____>
		|_______________|
#

proc call(dont_skip, o_fc)
(	var n;

	testsym(s_rp_expr, dont_skip, '');
	if MEM(t_sy, s_startexpr)
	then	n := exprlist(UN(t_rp, dont_skip), t_comma)
	else	n := 0	# either t_sy = t_rp, or t_sy in dont_skip #
	fi;
	if o_fc = o_field then n:=n+1 fi;
	if t_sy ~= t_rp
	then	error(') missing', lnr)
	else	ndpush(qn || string(n));
		make_tuple(o_fc, n+2);
		nextsym(); testsym(dont_skip, emptyset, '')
	fi
);
	# 'call' is called from 'operand' as well as from 'field'.	#
	# Its second argument is the operator to be passed on to	#
	# 'make_tuple', which can be 'o_call' or 'o_field'.		#
	# If it is 'o_field', the number of arguments parsed is incre-	#
	# mented by one: the class object at the left of the dot, parsed#
	# already by 'field'.						#

#
			 ____ call _____
			|		|
	_____ ident ____|		|
			|_______________|
#

proc field(dont_skip)
(	var s1 := UN(t_lp, dont_skip);

	testsym(t_ident, s1, 'identifier expected in selection');
	if t_sy = t_ident
	then	ndpush('w' || sy);
		nextsym();
		testsym(s1, emptyset, '')
	fi;
	if t_sy = t_lp
	then	nextsym(); call(dont_skip, o_field)
	else	ndpush('n1'); make_tuple(o_field, 3)
	fi
);

#

			      (_call__
		 __ name ___ |        |_
		|	     |________| |
		|_________ int _________|
		|			|
		|________ real _________|
		|			|
		|_______ string ________|
		|			|
		|_____ 'undefined' _____|
		|			|
		|______ 'freturn' ______|
		|			|
		|_______ 'self' ________|
		|			|
   _____________|_____ 'subject' _______|____________>________________________>
		|			|     |			|
		|______ whiledo ________|     |__<_ [ _ indic __|   
		|			|     |			|     
		|_________ ret _________|     |__<_ . _ field __|
		|			|
		|_______ arinit ________|
		|			|
		|______ tabinit ________|
		|			|
		|________ iffi _________|
		|			| 
		|_______ try_yrt _______|
		|			|
		|_______ scanfor _______|
		|			|
		|_______ forloop _______|
		|			|
		|______ caseclause _____|
		|			|
		|______ assertion ______|
		|			|
		|_______ parexpr _______|

#

proc leave_case()
case t_sy of
	t_int:		ndpush('n' || sy),
	t_real:		ndpush('r' || sy),
	t_str:		ndpush(sy),
	t_undef:	ndpush('u'),
	t_freturn:	ndpush('f'),
	default:	freturn
esac;

proc stat_case(dont_skip)
(	var start := t_sy;

	nextsym();
	return( case start of
			 t_while:	 whiledo(dont_skip),
			 t_return:	 ret(dont_skip),
			 t_array:	 arinit(dont_skip),
			 t_table:	 tabinit(dont_skip),
			 t_if:		 iffi(dont_skip),
			 t_try:		 try_yrt(dont_skip),
			 t_scan:	 scanfor(dont_skip),
			 t_for:		 forloop(dont_skip),
			 t_case:	 caseclause(dont_skip),
			 t_assert:	 assertion(dont_skip),
			 t_lp:		 parexpr(dont_skip)
		esac)
);

proc operand(dont_skip)
(	var typ, indics, andproc,
	    pname := '',
	    s := UN(s_lbr_dot, dont_skip);

	if t_sy = t_ident
	then	typ := checktype(sy);
		ndpush(typ);
		indics := 1; nextsym(); testsym(UN(t_lp, s), emptyset, '');
		if t_sy = t_lp
		then	if scan typ for any('lnrSu') rof
			then	error('illegal call', lnr)
			fi;
			nextsym();
			call(s, o_call)
		fi
	elif	leave_case()
	then	indics := 1; nextsym(); testsym(s, emptyset, '')
	elif   t_sy = t_self	& ndpush('m') &
	       if clname = '' then error('self used outside class', lnr) fi
	     | t_sy = t_subject & ndpush('b')
	then	indics := 1; nextsym(); testsym(s, emptyset, '')
	elif t_sy = t_lbr
	then	ar_or_tab(dont_skip);
		indics := 1
	elif	MEM(t_sy, s_startand)
	then	indics := stat_case(s)
        elif MEM(t_sy, dont_skip)
	then	return
	else	comerror('in operand, sy: ' || sy || 't_sy: '
			 || string(t_sy)
			)
	fi;
	if indics = 1
	then	while   t_sy = t_lbr & nextsym() & indic(dont_skip)
		      | t_sy = t_dot & nextsym() & field(dont_skip)
		do od
	else	testsym(dont_skip, emptyset, '')
	fi
);
	# 'indics' denotes whether the operand being parsed can be	#
	# followed by a field selection or an indexing. Procedures	#
	# called via 'andtab' return the value to be assigned to	#
	# 'indics'.							#



#
     _______ monop ____ operand ___________>
	|	    |
	|_____<_____|

#

proc unexpr(dont_skip)
(	var s1 := UN(s_startexpr, dont_skip);

	testsym(s_startexpr, dont_skip, 'illegal or missing operand');
	if t_sy = t_opseq then parseop(t_monop, s1) fi;
	while	(t_sy = t_monop | t_sy = t_bothop) & treatop(montab[sy])
	do	nextsym();
	 	testsym(s_startexpr, dont_skip, 'illegal or missing operand');
		if t_sy = t_opseq then parseop(t_monop, s1) fi
	od;
	operand(dont_skip);
);



#
	___ unexpr _____ dyop _____ unexpr_______>
		     |			    |
		     |________<_____________|
#

proc expr(dont_skip)
(	var s := UN(s_dy_expr, dont_skip);

	opush(dytab[o_lpar]);
	unexpr(s);
	if t_sy = t_opseq then parseop(t_dyop, s) fi;
	while   (t_sy = t_dyop | t_sy = t_bothop) &
		treatop(dytab[sy]) & nextsym()
	      | MEM(t_sy, s_startexpr) & mess = '' & invars = inconst = 0 &
		t_sy ~= t_for & error('dyadic operator or ; missing', lnr)
			# This is the fix explained in the comment that	#
			# accompanies the declaration of 'mess'. 'for'	#
			# is excepted from 's_startexpr' because it can	#
			# also occur correctly in 'scan expr for..,	#
			# in which case this error message should not be#
			# issued.					#
	do	unexpr(s);
		if t_sy = t_opseq then parseop(t_dyop, s) fi;
	od;
	emptystack();
	testsym(dont_skip, emptyset, '')
);


#
		 ____ (____________________________ ) __
		|	 |			|	|
		|	 |_ id__________________|	|
		|		|		|	|
	________|		|		|	|_________>
		|		|__<_ id _ , _<_|	|
		|					|
		|				 	|
		|_______________________________________|

#


proc params(dont_skip, scope)
(	var n := 0, nms := '';

	inparams := 1;
	testsym(t_lp, UN(s_id_rp,dont_skip), '( missing');
	if t_sy = t_lp
	then	nextsym();
		testsym(s_id_rp, UN(t_comma, dont_skip), '')
	fi;
	while 'TRUE'
	do	if t_sy = t_ident
		then	n := n+1;
			if scope = t_class
			then	if fieldentry(sy,
					   [clname, VAR, offset := offset+1,
					    NIL, NIL, undefined]
					  ) = 1
				then	symentry(sy, level, 'c');
					nms := nms || sy || sc
				fi
			else	if symentry(sy, level, 'l' || string(loccnt))=1
				then	nms := nms || sy || sc
				fi;
				loccnt := loccnt + 1;
			fi;
			nextsym();
			testsym(s_com_rp, UN(t_ident, dont_skip), '')
		fi;
		if t_sy = t_rp
		then	nextsym(); testsym(dont_skip, emptyset, empty);
			inparams := 0;
			return([n,nms])
		elif t_sy = t_ident
		then	error(', missing', lnr)
		elif MEM(t_sy, dont_skip)
		then	error(') missing', lnr);
			inparams := 0;
			return([n, nms])
		elif t_sy = t_comma
		then	nextsym();
			testsym(t_ident, UN(s_com_rp, dont_skip),
					'identifier expected')
		else	comerror('in params, sy: ' || sy || ' t_sy: '
				 || string(t_sy)
				)
		fi
	od
);

#
                         _______________
                        |               |
        _____ ident_____|__ := __ expr__|________ ; _____>
          |                                 |
          |________________<_______________ ,

#


proc vars(dont_skip, scope)
(	var s2 := UN(dont_skip, s_startexpr),
	    s3 := UN(s_decl, s2),
	    s4 := UN(dont_skip, s_sem_com),
	    stlnr,
	    name,
	    typ := '';

	invars := 1;
	if scope = t_class
	then	f_ := f_init;
		imlab := cllab
	else	f_ := f_gl;
		imlab := gllab
	fi;
	while 'TRUE'
	do	testsym(t_ident, s3, 'identifier expected');
		if t_sy = t_ident
		then	if scope = t_class
			then	if fieldentry(sy,
					   [clname, VAR, offset := offset+1,
					    NIL, NIL, undefined]
					  ) = 1
				then	symentry(sy, level, 'c');
					data_flds := data_flds || sy || sc
				fi;
				typ := 'c' || sy;
			else	symentry(sy, level, 'g');
				typ := 'g' || sy
			fi;
			name := sy; stlnr := lnr;
			nextsym(); testsym(s_decl, s2, '')
		else	name := nextglob()
		fi;
		if t_sy = t_opseq then parseop(t_dyop, s3) fi;
		if t_sy = t_dyop &
		   (sy = ':=' | error(sy || ' should be :=', lnr))
		then	ndpush(typ);
                        nextsym();
                        expr(s4);
                        make_tuple(o_assign, 2);
                        if errors = 0
			then	f_.put('I:\t', stlnr, sc, ndpop(), sc,
					lnr, sc, newl
				   )
                        fi
                elif MEM(t_sy, s_startexpr)
                then    if t_sy ~= t_ident | symtab[sy] ~= undefined
                        then    error(':= assumed missing', lnr);
                                expr(s4)
                        fi
                fi;
                if scope = t_program & errors = 0
                then    f_im.put(globhead, name, newl)
                fi;
                if t_sy = t_semi
                then    nextsym(); testsym(dont_skip, emptyset, '');
                        invars := 0; 
                        if scope = t_class then cllab else gllab fi := imlab;
                        f_ := f_im;
                        return
                elif t_sy = t_comma
                then    nextsym()
		elif t_sy = t_ident & symtab[sy] = undefined
		then	error(', missing', lnr)
                elif MEM(t_sy, dont_skip)
                then    error('; missing', lnr); invars := 0;
			return
                elif t_sy ~= t_ident
                then    comerror('in vars, sy: ' || sy || ' t_sy: '
                                  || string(t_sy)
                                )
                fi
        od
);


#
       ______ opname _____ params _____ expr _____ ; ___>

#

proc mondy(nf)
	if nf = 1
	then	return([montab, t_monop])
	elif nf = 2
	then	return([dytab, t_dyop])
	else	error('operator should be either monadic or dyadic', lnr);
		return([dytab, t_dyop])
	fi;

proc operator(dont_skip, scope)
(	var name, fnms, nf, stlnr, tab, tp, intname,
	    s1 := UN(s_prbody, dont_skip);

	stlnr := lastlnr := lnr;
	loccnt := if scope = t_class then 1 else 0 fi;
	retcnt := undefined;
	imlab := 0;
	resetstacks();
	testsym(s_op, s1, 'illegal operator name');
	if MEM(t_sy, s_op)
	then	name := sy;
		nextsym()
	else	name := nextglob()
	fi;
	inproc := 1;
	level := level+1;
	[nf, fnms] := params(s1, t_program);
	loclist := fnms;
        if name ~= ''
        then if scope = t_class
             then var nm := name || '.' || string(nf:=nf+1), e;
                  intname := nm || clsuffix;
		  loclist := sc || loclist;
                  if fieldentry(nm,
                             [clname, PROC, intname, NIL, NIL, undefined]) = 1
		  then	op_flds := op_flds || nm || sc
		  fi;
                  [tab, tp] := mondy(nf);
                  e := tab[name];
                  if e = undefined | e[O_STATUS] < 0
                  then    tab[name] := [nm,nf,3,priofdef(nf),priogdef(nf)]
		  elif e[O_STATUS] = 1
                  then    addglobf(nm); e[O_STATUS] := 2
                  fi
	     else var e, t;

                  intname := name || '.' || string(nf);
                  [tab, tp] := mondy(nf);
                  e := tab[name]; t := 1;
		  if   e = undefined
		     | e[O_STATUS] < 0
		     | e[O_STATUS] = 3 & addglobf(intname) & t := 2
		  then	tab[name] := [intname,nf,t,priofdef(nf),priogdef(nf)]
		  else	error('global op ' || name || ' redeclared', lnr)
		  fi
             fi;
             if optab[name] = undefined
             then    optab[name] := tp
             elif optab[name] ~= tp
             then    optab[name] := t_bothop
             fi
	fi;
	if MEM(t_sy, s_startexpr)
	then	expr(UN(t_semi, dont_skip))
	else	ndpush('u')
	fi;
	if retcnt = undefined then retcnt := 0 fi;
	if errors = 0
	then	f_im.put(prochead, retcnt, tabsym,
			 intname, sc, convlocs(), sc, nf, sc,
			 loccnt-nf, sc, stlnr, sc, lnr,
			 tabsym, ndpop(), sc, newl
		   )
	fi;
	if t_sy ~= t_semi
	then	error('; missing', lnr)
	else	nextsym(); testsym(dont_skip, emptyset, '')
	fi;
	remove(fnms); level := level-1
);


#

				 ____ expr _____
				|		|
   ___ ident _____ params ______|___ 'code' ____|___ ; ___>
				|		|
				|_______________|

#

proc procedure(dont_skip, scope)
(	var name, nf, fnms, stlnr, intname, fld, s1 := UN(s_prbody, dont_skip);

	stlnr := lastlnr := lnr;
	loccnt := if scope = t_class then 1 else 0 fi;
	retcnt := undefined;
	imlab := 0;
	resetstacks();
	testsym(t_ident, s1, 'identifier expected');
	if t_sy = t_ident
	then	name := sy;
		nextsym();
		testsym(s_prbody, dont_skip, 'unrecognizable procedure body')
	else	name := nextglob()
	fi;
	inproc := 1;
	level := level + 1;
	[nf, fnms] := params(s1, t_program);
	loclist := fnms;
	if scope = t_class & name ~= ''
	then	nf := nf+1;
		loclist := sc || loclist;
		intname := name || clsuffix;
		if assoctab[name] = t_store
		then	if nf ~= 2
			then	error('store assoc should have one parameter',
					lnr)
			fi
		elif assoctab[name] = t_fetch
		then	if nf ~= 1
			then	error('fetch assoc cannot have parameters',lnr)
			fi
		fi;
		if fieldentry(name,
				[clname, PROC, intname, NIL, NIL, undefined]
			     ) = 1
		then	proc_flds := proc_flds || name || sc;
			symentry(name, level-1, 'c')
				# level has been incremented already to #
				# parse parameters.			#
		fi
	elif name ~= ''
	then	symentry(name, level-1, 'gp' || string(nf));
		intname := name
	fi;
	if t_sy = t_code
	then	nextsym();
		if ~(symtab[name][S_TYPE] :=
			scan symtab[name][S_TYPE]
			for lit('gp') &
			    'gb' || rtab(0)
			rof)
		then	error('non global procedure with body code', lnr)
		fi
	else	if MEM(t_sy, s_startexpr)
		then	expr(UN(t_semi, dont_skip))
		else	ndpush('u')
		fi;
		if retcnt = undefined then retcnt := 0 fi;
		if errors = 0
		then	f_im.put(prochead,
				 retcnt, tabsym, intname, sc,
				 convlocs(), sc, nf, sc, loccnt-nf, sc,
				 stlnr, sc, lnr, tabsym, ndpop(), sc, newl
			   )
		fi;
	fi;
	inproc := 0;
	if t_sy ~= t_semi
	then	error('; missing', lnr)
	else	nextsym(); testsym(dont_skip, emptyset, '')
	fi;
	if assoctab[name] ~= undefined
	then	if retcnt ~= 1
		then	error('fetch or store association ' ||
			       name || ' does not return value', lnr)
		fi
	fi;
	remove(fnms); level := level-1
);


#
	____ 'of' ____ ident ____ ; ___>
#

proc do_subclass(dont_skip)
(	var s := UN(t_semi, dont_skip),
	    super, cl_super;

	testsym(t_of, UN(t_ident, s), 'of missing');
	if t_sy = t_of
	then nextsym(); testsym(t_ident, s, 'identifier expected')
	fi;
	if t_sy = t_ident
	then super := sy;
	     if (cl_super := classtab[super]) = undefined
	     then error(super || ' not (yet) defined as class', lnr)
	     fi;
	     nextsym(); testsym(t_semi, dont_skip, '; missing');
	     if cl_super ~= undefined
	     then var fldlist, fld, sub_entry, super_entry;

		  fldlist := cl_super[1];		# parameters #
		  if scan par_flds for lit(fldlist) rof fails
		  then error('parameters of ' || clname ||
			      'should include those of ' || super, lnr)
		  else fldlist := scan_string(fldlist);
		       while scan fldlist for fld := break(sc) & lit(sc) rof
		       do sub_entry := fieldtab[fld];
			  super_entry := locate_fld(fld, super);
			  sub_entry[F_FETCH] := super_entry[F_FETCH];
			  sub_entry[F_STORE] := super_entry[F_STORE];
		       od
		  fi;
		  fldlist := scan_string(cl_super[2]);	# data fields #
		  while scan fldlist for fld := break(sc) & lit(sc) rof
		  do super_entry := locate_fld(fld, super);
		     fieldentry(fld,
				[clname, VAR, offset := offset + 1,
				 super_entry[F_FETCH], super_entry[F_STORE],
				 undefined]
			       );
		     data_flds := data_flds || fld || sc;
		     symentry(fld, level, 'c');
		     inhertab[fld] := 1;
		  od;
		  fldlist := scan_string(cl_super[3]);	# procedures #
		  while scan fldlist for fld := break(sc) & lit(sc) rof
		  do super_entry := locate_fld(fld, super);
		     fieldentry(fld,
				[clname, PROC, super_entry[F_INTERN],
				 super_entry[F_FETCH], NIL, undefined]
			       );
		     proc_flds := proc_flds || fld || sc;
		     symentry(fld, level, 'c');
		     inhertab[fld] := 1;
		  od;
		  fldlist := scan_string(cl_super[4]);	# operators #
		  while scan fldlist for fld := break(sc) & lit(sc) rof
		  do super_entry := locate_fld(fld, super);
		     fieldentry(fld,
				[clname, PROC, super_entry[F_INTERN],
				 super_entry[F_FETCH], NIL, undefined]
			       );
		     op_flds := op_flds || fld || sc;
		     inhertab[fld] := 1
		  od
	     fi
	fi;
	if t_sy = t_semi
	then	nextsym(); testsym(dont_skip, emptyset, '')
	fi;
	return(super)
);
	# All fieldtable entries of the superclass are copied. Parameters #
	# have been entered already; only the fetch and store associations#
	# are changed. They may not be redefined. For all other fields a  # 
	# new entry is created; and they are entered in inhertab to       #
	# denote that they may be redefined.				  #
	# Offsets: if A(a) with datafields x and y is the superclass of	  #
	# B(a,b,c) then after 'do_subclass' B has five datafields:	  #
	# 'a' (offset 0), 'b' (1), 'c' (2), 'x' (3) and 'y' (4).	  #


#
		 ____ ident ____	 __ : __ ident _
		|		|	|		|
   _____________|		|_______|		|_________ ; ___>
	|	|		|	|		|	|
	|	|____ opname ___|	|_______________|	|
	|							|
	|_______________________ , _______________<_____________|
#


proc assocs(dont_skip, type)
(	var fstab := if type = t_fetch then fetchtab else storetab fi,
	    field,
	    s1 := UN(s_com_col_sem, dont_skip),
	    s2 := UN(s_id_op, dont_skip),
	    s3 := UN(s_sem_com, dont_skip);

	testsym(s_id_op, s1, 'fieldname expected');
	while 'TRUE'
	do	if MEM(t_sy, s_id_op)
		then	field := sy;
			nextsym();
			testsym(s_com_col_sem, s2, '')
		fi;
		if t_sy = t_colon
		then	nextsym();
			testsym(t_ident, s3, 'identifier required');
			if t_sy = t_ident
			then	if field ~= undefined
				then	fstab[field] := sy;
					assoctab[sy] := type
				fi;
				nextsym(); testsym(s_sem_com, s2, '')
			fi
		elif field ~= undefined
		then	fstab[field] := '_s'
		fi;
		if t_sy = t_semi
		then	nextsym(); testsym(dont_skip, emptyset, '');
			return
		elif t_sy = t_comma
		then	nextsym(); testsym(s_id_op, s1, 'fieldname expected')
		elif MEM(t_sy, s_id_op)
		then	error(', missing', lnr)
		elif MEM(t_sy, dont_skip)
		then	error('; missing', lnr); return
		else	comerror('in assocs; sy, t_sy: ' || sy || string(t_sy))
		fi
	od
);

#
					 __ 'fetch' __ assocs __
					|			|
  __'class'__ ident __ params __'begin'_|__ 'store' __ assocs __|___>>>
					|			|
					|_______________________|


 	 __'proc'__ procedure _		 _'init'_ : _ block_
	|			|	|		    |
 >>>____|__'op_____ operator ___|_______|		    |__'end'__ ident__>
     |  |			|   |   |		    |
     |  |__'var'___ vars _______|   |   |___________________|
     |				    |
     |___________<__________________|
#


proc classdecl(dont_skip)
(	var nf, stlnr, super, cnms := '', s1 := UN(dont_skip, s_class);

	offset := -1; cllab := 0;
	par_flds := data_flds := proc_flds := '';
	classcnt := classcnt + 1;
	clsuffix := '.' || string(classcnt);
	if errors = 0
	then	if ~(f_init := file(pname || '.in','w'))
		then	error('cannot open ' || pname || '.in', lnr)
		fi
	fi;
	testsym(t_ident, UN(t_lp, dont_skip), 'identifier expected');
	if t_sy = t_ident
	then	clname := sy;
		nextsym()
	else	clname := 'C' || nextglob()
	fi;
	level := level+1;
	[nf, par_flds] := params(UN(dont_skip, s_bg_class), t_class);
	nf := nf+1;
	symentry(clname, level-1, 'ap' || string(nf));
		# level has been incremented before to parse parameters #
	if errors = 0
	then f_im.put(classbegin, clname, sc, classcnt, newl)
	fi;
	if t_sy ~= t_begin
	then	error('begin missing', lnr)
	else	nextsym();
		testsym(s_sub_fs_class, dont_skip, '');
	fi;
	if t_sy = t_subclass
	then	nextsym();
		super := do_subclass(UN(s_fs_class, dont_skip))
	fi;
	if t_sy = t_fetch
	then	nextsym(); assocs(UN(s_st_class, dont_skip), t_fetch)
	fi;
	if t_sy = t_store
	then	nextsym(); assocs(UN(s_class, dont_skip), t_store)
	fi;
	while   t_sy = t_var & nextsym() & vars(s1, t_class)
	      | t_sy = t_const & nextsym() & cnms := cnms || constdecl(s1)
	      | t_sy = t_proc & nextsym() & procedure(s1, t_class)
	      | t_sy = t_op & nextsym() & operator(s1, t_class)
	do od;
	stlnr := lnr; loccnt := nf; loclist := par_flds; imlab := cllab;
	resetstacks(); inproc := 1;
	if super ~= undefined
	then	var nfs :=
		     integer(scan symtab[super][S_TYPE]
			    for lit('ap') & rtab(0) rof),
		    i := 0;
		ndpush('g' || super);
		for i in interval(0, nfs-1, 1)
		do	ndpush('l' || string(i)) od;
		ndpush(qn || string(nfs));
		make_tuple(o_call, nfs+2)
	fi;
	if t_sy = t_init
	then	nextsym();
		testsym(t_colon, UN(s_startexpr, dont_skip), ': missing');
		if t_sy = t_colon then nextsym() fi;
		block(UN(s_end_sem, dont_skip));
		if super ~= undefined
		then	ndpush('n2');
			make_tuple(o_semi, 3)
		fi;
		inproc := 0
	elif	super = undefined then ndpush('u')
	fi;
	if t_sy = t_end
	then	nextsym(); testsym(t_ident, UN(t_semi, dont_skip), '')
	else	error('end missing', lnr)
	fi;
	if sy ~= clname
	then	error(clname || ' missing', lnr)
	fi;
	if t_sy = t_ident
	then	nextsym(); testsym(t_semi, dont_skip, '')
	fi;
	if t_sy = t_semi
	then	nextsym(); testsym(dont_skip, emptyset, '')
	else	error('; missing', lnr)
	fi;
	putassocs(t_fetch); putassocs(t_store);
	fetchtab := table(5, undefined);
	storetab := table(5, undefined);
	assoctab := table(5, undefined);
	if errors = 0
	then	f_im.put(classhead,
			 1, tabsym, clname, sc, convlocs(), sc, nf, sc,
			 loccnt - nf, sc, stlnr, sc, lnr, tabsym, ndpop(),
			 sc, newl
		   );
		f_init.close ;
		f_init := file(pname || '.in','r');
		while f_im.put(f_init.get , newl) do od;
		f_init.close ;
		f_im.put('CLASSEND', newl)
	fi;
	classtab[clname]:= [offset+1, par_flds, data_flds, proc_flds, op_flds];
	remove(par_flds); remove(data_flds); remove(proc_flds); remove(cnms);
	level := level-1;
	par_flds := data_flds := proc_flds := op_flds := clname := '';
	inhertab := table(10, undefined)
);


#

	____ opname ____________ ; _____>
	  |		 |
	  |_______<_____ ,
#

proc opnames(dont_skip, n_adic)
(	var s1 := UN(s_sem_com, dont_skip),
	    s2 := UN(s_op, dont_skip);

	while 'TRUE'
	do	testsym(s_op, s1, 'operator name expected');
		if MEM(t_sy, s_op)
		then	if t_sy = t_opseq
			then	optab[sy] := n_adic
			elif t_sy ~= t_bothop & t_sy ~= n_adic
			then	optab[sy] := t_bothop
			fi;
			if n_adic = t_monop
			then	montab[sy] := array
				 [sy || '.1', 1, -lnr, priofdef(1),priogdef(1)]
			else	dytab[sy] := array
				 [sy || '.2', 2, -lnr, priofdef(2),priogdef(2)]
			fi;
			nextsym(); testsym(s_sem_com, s2, '')
		fi;
		if t_sy = t_semi
		then	nextsym(); testsym(dont_skip, emptyset, '');
			return
		elif t_sy = t_comma
		then	nextsym()
		elif MEM(t_sy, s_op)
		then	error(', missing', lnr)
		elif MEM(t_sy, dont_skip)
		then	error('; missing', lnr); return
		else	comerror('in opnames; sy:' || sy || ' t_sy:' || t_sy)
		fi
	od
);


proc include_file(dont_skip)
(	var s := '', f;

	line.span(' \t') | 'OK';
	if scan line
	   for	lit(quote) &
		while s := s || break(quote) & lit(quote || quote) &
		      s := s || quote
		do od &
		lit(quote)
	   rof  fails
	then	error('error in include syntax', lnr);
	else	if try nextsym() & t_sy = t_semi yrt fails
		then	error('; missing', lnr)
		fi;
		if f := file(s, 'r') fails
		then	error('cannot open ' || s, lnr)
		else	if src_stp >= 24
			then	comerror('source_stack overflow')
			fi;
			src_stack[src_stp := src_stp + 1]
				:= [f_src, src_name, line, lnr];
			f_src := f;
			src_name := s;
			line := scan_string(f_src.get());
			lnr := 1
		fi
	fi;
	nextsym(); testsym(s_prog, emptyset, '')
);
	
		     


#

                                 ____ expr _____
                                |               |
   ___ ident _____ params ______|               |_________>
                                |               |
                                |_______________|

#

proc programme(dont_skip)
(	var name, nf, stlnr, fnms,
	    s1 := UN(s_sem_expr, dont_skip);


	lastlnr := stlnr := lnr;
	loccnt := 0; loclist := empty; imlab := gllab;
	testsym(t_ident, s1, 'identifier expected');
	resetstacks();
	if t_sy = t_ident
	then	name := sy;
		if symtab[name] ~= undefined
		then	error(name || ' redeclared',lnr)
		fi;
		nextsym();
	fi;
	inproc := 1; level := level+1;
	[nf, fnms] := params(UN(dont_skip, s_sem_expr), t_program);
	loclist := fnms;
	if nf > 1
	then	error('program can have at most one parameter', lnr)
	fi;
	if MEM(t_sy, s_startexpr)
	then	expr(UN(t_semi, dont_skip))
	else	ndpush('u')
	fi;
	inproc := 0;
	if errors = 0
	then	f_im.put(proghead, name, sc, convlocs(), sc, nf, sc, 
			 loccnt-nf, sc, stlnr, sc, lnr, tabsym, ndpop(), sc,
			 newl
		   )
	fi;
	if t_sy = t_semi
	then	nextsym()
	fi;
	testsym(dont_skip, emptyset, empty);
	remove(fnms); level := level-1; gllab := imlab
);


program parser(a)
(	var cnms := '', prog := 0;

	pname := a[0];
	src_name := pname || '.sm';
	errors := 0;
	lnr := 1;
	if ~ (f_src := file(src_name,'r'))
	then	put('cannot open ', src_name, '\n');
		stop(1)
	fi;
	if ~ (f_er := file(pname || '.er','w'))
	then	put('cannot open ', pname, '.er', '\n');
		stop(1)
	fi;
	if ~ (f_im := file(pname || '.im','w'))
	then	put('cannot open ', pname, '.im', '\n');
		stop(1)
	fi;
	if ~ (f_gl := file(pname || '.gl','w'))
	then	put('cannot open ', pname, '.gl', '\n');
		stop(1)
	fi;
	if ~ (f_st := file(pname || '.st','w'))
	then	put('cannot open ', pname, '.st\n');
		stop(1)
	fi;
	if ~(f_cs := file(pname || '.cs','w'))
	then	put('cannot open ', pname, '.cs\n');
		stop(1)
	fi;
	line := scan_string(f_src.get );
	f_ := f_im;
	nextsym();
	testsym(s_prog, emptyset, '');
	while   t_sy = t_var & nextsym() & vars(s_prog, t_program)
	      | t_sy = t_const & nextsym() & cnms := cnms || constdecl(s_prog)
	      | t_sy = t_proc & nextsym() & procedure(s_prog, t_program)
	      | t_sy = t_op & nextsym() & operator(s_prog, t_program)
	      | t_sy = t_class & nextsym() & classdecl(s_prog)
	      | t_sy = t_program &
		if prog = 0
		then	prog := 1
		else	error('only one program declaration allowed', lnr)
		fi &
		nextsym() & programme(s_prog)
	      | t_sy = t_monadic & nextsym() & opnames(s_prog, t_monop)
	      | t_sy = t_dyadic & nextsym() & opnames(s_prog, t_dyop)
	      | t_sy = t_include & include_file(s_prog)
	do od;
	if prog = 0
	then	error('program declaration missing', lnr)
	fi;
	f_src.close ; f_cs.close ; f_gl.close ; f_st.close ;
	remove(cnms);
	make_decls();
	f_er.close ; stop(errors)
);
