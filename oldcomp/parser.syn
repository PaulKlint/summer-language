LEXICAL	identifier,
	integer_constant,
	real_constant,
	string_constant,
	operator_symbol .



<summer_program>    ::= (  <global_variable_declaration>
			 | nms:<constant_declaration> /cns/
			 | <global_procedure_declaration>
			 | <global_operator_declaration>
			 | <class_declaration>
			 | <monadic_symbol_declaration>
			 | <dyadic_symbol_declaration>
			 | <program_declaration> /prg/
			 | <include_file>
			)* .

	INIT:	var cnms := '', prog := 0;

		pname := args[0];
		src_name := pname || '.sm';
		if f_src := file(src_name, 'r') fails
		then	cant(src_name);
		fi;
		if f_im := file(pname || '.im','w') fails
		then	cant(pname || '.im');
		fi;
		if f_gl := file(pname || '.gl','w') fails
		then	cant(pname || '.gl');
		fi;
		if f_st := file(pname || '.st','w') fails
		then	cant(pname || '.st');
		fi;
		if f_cs := file(pname || '.cs','w') fails
		then	cant(pname || '.cs');
		fi;
		if f_er := file(pname || '.er', 'w') fails
		then	cant(pname || '.er');
		fi;
		line := scan_string(f_src.get );
		lnr := 1;
		f_ := f_im;
		init_types();
		keytab['init'] := kartab['init'];

		#*******************************************************#
		# 'init' is a keyword, but the syntax of parsgen	#
		# does not allow writing it as INIT. Nevertheless, it	#
		# should be in keytab, in order to retrieve its type	#
		# correctly.						#
		#*******************************************************#

	/cns/:	cnms := cnms || nms;

	/prg/:	if prog = 0
		then	prog := 1
		else	ermsg('multiple program declaration', lnr)
		fi;

	EXIT:	if prog = 0
		then	ermsg('program declaration missing', lnr)
		fi;
		f_src.close ; f_cs.close ; f_gl.close ; f_st.close ;
		remove(cnms);
		make_decls();
		if errcnt = 0 then stop(0) else stop(1) fi;



<global_variable_declaration> ::=
			VAR { <global_initialization> /nxt/ ',' }+ ';' .

	INIT:	f_ := f_gl;
		imlab := gllab;

		#*******************************************************#
		# All code for initializations of globals is written	#
		# to the .gl file. Labels occurring on that file must	#
		# be unique; "gllab" remembers the number of the last	#
		# label used.						#
		#*******************************************************#

	/nxt/:	# INSERT REAL CODE HERE #
	EXIT:	f_ := f_im;
		gllab := imlab;



<global_initialization> ::= <identifier> /id/
			    [ <operator_symbol> /ass/ <expression> /exp/ ] .

	INIT:	var name := '',
		    typ := '',
		    stlnr := lnr;

	/id/:	name := sy;
		symentry(name, level, 'g', '');
		typ := 'g' || name;

	/ass/:	if sy ~= ':='
		then	ermsg('":=" expected instead of "' || sy || '"', lnr)
		fi;
		ndpush(typ);

	/exp/:	make_tuple(o_assign, 2);
		if errcnt = 0
		then	f_gl.put('I:\t', stlnr, sc, ndpop(), sc, lnr, sc, newl)
		fi;

	EXIT:	if errcnt = 0
		then	f_im.put(globhead, name, newl)
		fi;



<constant_declaration> ::=
		CONST { ci:<constant_initialization> /nxt/ ',' }+ ';' .
				
	INIT:	var nms := '';

	/nxt/:	if ci[0] = 1 then nms := nms || ci[1] || sc fi;

		#*******************************************************#
		# ci[0] = 1 if the current identifier was not declared	#
		# before on the same level. ci[1] contains the current	#
		# identifier.						#
		#*******************************************************#

	EXIT:	return(nms);



<constant_initialization> ::= <identifier> /id/
			      <operator_symbol> /ass/ <expression> .

	INIT:	var name := '',
		    new := 0;

	/id/:	name := sy;

	/ass/:	if sy ~= ':='
		then	ermsg('":=" expected instead of "' || sy || '"', lnr)
		fi;

	EXIT:	(var r;

		 if errcnt = 0
		 then	r := ndpop();
			case r[0]
			of	'n': 'r': 'S': 'z': 'u': ,
				   # Everything OK: there is a constant #
				   # on top of the stack.		#
				default:
				   ermsg('constant expression required', lnr);
				   r := 'u'
			esac
		 else	r := 'u'
		 fi;
		 if name ~= ''
		 then	new := symentry(name, level, 'C', r);
		 fi;
		 return([new, name])
		);



<global_procedure_declaration> ::= PROC <identifier> /id/
		       		        n_nms:<formals_of_procedure> /par/
		       			( <expression> | <empty> /emp/ ) ';' .

	INIT:	var name := '',
		    nf := 0,
		    fnms := '',
		    stlnr := lnr;

		loccnt := 0;
		proc_op_init();	

	/id/:	name := sy;

	/par/:	nf := n_nms[0];
		loclist := fnms := n_nms[1];
		if name ~= ''
		then	symentry(name, level-1, 'gp', nf)
		fi;

	/emp/:	ndpush('u');

	EXIT:	proc_op_exit(name, nf, fnms, stlnr);

	#***************************************************************#
	# A 'code'-body (for procedures written in C and linked after	#
	# compilation) is no longer allowed!				#
	#***************************************************************#



<formals_of_procedure> ::= '(' { <identifier> /nxt/ ',' }* ')' .

	INIT:	var n := 0, nms := '';

	/nxt/:	n := n+1;
		if symentry(sy, level, 'l', loccnt) = 1
		then	nms := nms || sy || sc
		fi;
		loccnt := loccnt + 1;

	EXIT:	return([n, nms]);



<global_operator_declaration> ::= OP <operator_symbol> /sym/
			 	     n_nms:<formals_of_procedure> /par/
		         	     ( <expression> | <empty> /emp/ ) ';' .

	INIT:	var name := '',
		    stlnr := lnr,
		    nf := 0,
		    fnms := '',
		    intname;

		n_nms := [0,0];
		loccnt := 0;
		proc_op_init();

	/sym/:	name := sy;

	/par/:	nf := n_nms[0];
 		if ~ (1 <= nf <= 2)
		then	ermsg('operator should have one or two parameters', lnr)
		fi;
		fnms := loclist := n_nms[1];
        	if name ~= ''
	        then	var entry, stat, tab;

                  	intname := name || '.' || string(nf);
			tab := if nf = 1 then montab else dytab fi;
                  	entry := tab[name]; stat := 1;
		  	if   entry = undefined
		     	   | entry[O_STATUS] < 0
		     	   | entry[O_STATUS] = 3 & addglobf(intname) & stat := 2
		  	then tab[name] :=
				 [intname, nf, stat, priofdef(nf), priogdef(nf)]
		  	else ermsg('global operator "' || name || '" redeclared', lnr)
			fi
		fi;

		#*******************************************************#
		# This creates a correct entry for the global operator	#
		# in montab or dytab. There are three (correct)		#
		# possibilities: The operator is completely new (entry	#
 		# is undefined), it was declared in a MONADIC or DYADIC	#
		# statement (status < 0), or it was previously declared	#
		# within a class.					#
		#*******************************************************#

	/emp/:	ndpush('u')
	
	EXIT:	proc_op_exit(intname, nf, fnms, stlnr);



<class_declaration> ::= CLASS   <identifier> /id/
			        n_nms:<formals_of_class> /par/
			BEGIN	super:<subclass_declaration>
				<fetch_associations>
				<store_associations>
				(  <procedure_field_declaration>
				 | <operator_field_declaration>
				 | <data_field_declaration>
				 | c:<constant_declaration> /cns/
				)* /body/
				(  'init' ':' <block> /init/
				 | <empty> /emp/
				)
			END <identifier> /end/ ';' .

	INIT:	var nf := 0,
		    stlnr,
		    cnms := '';

		offset := -1; cllab := 0;
		classcnt := classcnt + 1;
		clsuffix := '.' || string(classcnt);
		if errcnt = 0
		then	if ~(f_init := file(pname || '.in','w'))
			then	ermsg('cannot open "' || pname || '.in"', lnr)
			fi
		fi;

	/id/:	clname := sy;
		level := level+1;

	/par/:	nf := n_nms[0] + 1;
		par_flds := n_nms[1];
		symentry(clname, level-1, 'ap', nf);
		      # level has been incremented before to parse parameters #
		if errcnt = 0
		then f_im.put(classbegin, clname, sc, classcnt, newl)
		fi;

	/cns/:	cnms := cnms || c;

	/body/:	stlnr := lnr;
		loccnt := nf;
		loclist := par_flds;
		imlab := cllab;
		inproc := 1;
		if super ~= undefined
		then	var nfs := symtab[super][S_VALUE],
		    	    i := 0;
			ndpush('g' || super);
			for i in interval(0, nfs-1, 1)
			do	ndpush('l' || string(i)) od;
			ndpush(qn || string(nfs));
			make_tuple(o_call, nfs+2)
		fi;

		#*******************************************************#
		# If the current class is a subclass, a call to the	#
		# init-procedure of the superclass is generated.	#
		# If the superclass had n-1 declared parameter, then	#
		# the actual parameters of this call are exactly the	#
		# first n parameters of the current class (including	#
		# the parameter which equals the "self" object.		#
		# This accounts for the pushing on the stack of the	#
		# locals.						#
		#*******************************************************#

	/init/:	if super ~= undefined
		then	ndpush('n2');
			make_tuple(o_semi, 3)
		fi;

	/emp/:	if super = undefined then ndpush('u') fi;

	/end/:	if sy ~= clname
		then	ermsg('"end" not followed by class name "' ||
				clname ||'"', lnr)
		fi;

	EXIT:	putassocs(fetch_type); putassocs(store_type);
		fetchtab := table(5, undefined);
		storetab := table(5, undefined);
		assoctab := table(5, undefined);
		if errcnt = 0
		then	f_im.put(classhead,
			 	 1, tabsym, clname, sc, convlocs(), sc, nf, sc,
			         loccnt-nf, sc, stlnr, sc, lnr, tabsym, ndpop(),
			 	 sc, newl
		   		);
			f_init.close ;
			f_init := file(pname || '.in','r');
			while f_im.put(f_init.get , newl) do od;
			f_init.close ;
			f_im.put('CLASSEND', newl)
		fi;
		classtab[clname] :=
			[offset+1, par_flds, data_flds, proc_flds, op_flds];
		remove(par_flds);
		remove(data_flds);
		remove(proc_flds);
		remove(cnms);
		level := level-1;
		par_flds := data_flds := proc_flds := op_flds := clname := '';
		inhertab := table(10, undefined);



<formals_of_class> ::= '(' { <identifier> /nxt/ ',' }* ')' .

	INIT:	var n := 0, nms := '';

	/nxt/:	n := n+1;
		offset := offset + 1;
		if fieldentry(sy, [clname, VAR, offset, NIL, NIL, undefined])
		   = 1
		then	symentry(sy, level, 'c', '');
			nms := nms || sy || sc
		fi;

	EXIT:	return([n, nms]);



<subclass_declaration> ::= [ SUBCLASS OF <identifier> /id/ ';' ] .

	INIT:	var super;

	/id/:	super := sy;
		do_subclass(super);

	EXIT:	return(super);



<fetch_associations> ::= [  FETCH
			   { ( (<identifier> /fld/ | <operator_symbol> /fld/ )
			       ( ':' <identifier> /ass/ | <empty> /emp/)
			     ) ','
			   }+ ';'
			 ] .

	INIT:	var field;

	/fld/:	field := sy;

	/ass/:	fetchtab[field] := sy;
		assoctab[sy] := fetch_type;

	/emp/:	if field ~= undefined
		then	fetchtab[field] := '_s'
		fi;



<store_associations> ::= [  STORE
			   { ( (<identifier> /fld/ | <operator_symbol> /fld/ )
			       ( ':' <identifier> /ass/ | <empty> /emp/)
			     ) ','
			   }+ ';'
			 ] .

	INIT:	var field;

	/fld/:	field := sy;

	/ass/:	storetab[field] := sy;
		assoctab[sy] := store_type;

	/emp/:	if field ~= undefined
		then	storetab[field] := '_s'
		fi;



<procedure_field_declaration> ::= PROC <identifier> /id/
		      		  n_nms:<formals_of_procedure> /par/
		      		  ( <expression> | <empty> /emp/ ) ';' .

	INIT:	var name := '',
		    intname := '',
		    nf := 0,
		    fnms := '',
		    stlnr := lnr;

		loccnt := 1;
		proc_op_init();	

	/id/:	name := sy;

	/par/:	nf := n_nms[0] + 1;
			# procedures and operators declared within	#
			# a class have an additional (invisible)	#
			# paarmeter: the class-object.			#
		loclist := fnms := n_nms[1];
		if name ~= ''
		then	loclist := sc || loclist;
				# for the sake of the tracer #
			intname := name || clsuffix;
			if assoctab[name] = store_type
			then if nf ~= 2
			     then ermsg('store assoc "' || name ||
					'" should have one parameter', lnr)
			     fi
			elif assoctab[name] = fetch_type
			then if nf ~= 1
			     then ermsg('fetch assoc "' || name ||
					'" cannot have parameters', lnr)
			     fi
			fi;
			if fieldentry(name,
				[clname, PROC, intname, NIL, NIL, undefined]
			     ) = 1
			then	proc_flds := proc_flds || name || sc;
				symentry(name, level-1, 'c', '')
				   # level has been incremented already to #
				   # parse parameters.			#
			fi
		fi;

	/emp/:	ndpush('u');

	EXIT:	proc_op_exit(intname, nf, fnms, stlnr);
		if assoctab[name] ~= undefined
		then	if retcnt ~= 1
			then	ermsg('fetch or store association "' ||
			       	      name || '" does not return value', lnr)
			fi
		fi;



<operator_field_declaration> ::= OP <operator_symbol> /sym/
			 	    n_nms:<formals_of_procedure> /par/
		         	    ( <expression> | <empty> /emp/ ) ';' .

	INIT:	var name := '',
		    stlnr := lnr,
		    nf := 0,
		    fnms := '',
		    intname;

		nf := [0,0]; 
		loccnt := 1;
		proc_op_init();

	/sym/:	name := sy;

	/par/:	nf := n_nms[0] + 1;
		if nf > 2
		then	ermsg('operator has too many parameters', lnr)
		fi;
		fnms := loclist := n_nms[1];
        	if name ~= ''
             	then	var nm := name || '.' || string(nf), entry, tab;

                  	intname := nm || clsuffix;
		  	loclist := sc || loclist;
                  	if fieldentry(nm,
                             [clname, PROC, intname, NIL, NIL, undefined]) = 1
		  	then	op_flds := op_flds || nm || sc
		  	fi;
			tab := if nf = 1 then montab else dytab fi;
                  	entry := tab[name];
                  	if entry = undefined | entry[O_STATUS] < 0
                  	then    tab[name] := [nm,nf,3,priofdef(nf),priogdef(nf)]
		  	elif entry[O_STATUS] = 1
                  	then    addglobf(nm); entry[O_STATUS] := 2
                  	fi
		fi;

		#*******************************************************#
		# A fieldentry and an entry in an operator table are	#
		# created. There are three legal possibilities: The	#
		# operator was never declared before; the operator was	#
		# declared in a MONADIC or DYADIC statement; the	#
		# operator was declared before as a global operator;	#
		# the operator was declared in a different class.	#
		# In the last case nothing needs to be done. Fieldentry	#
		# checks for redeclaration.				#
		#*******************************************************#

	/emp/:	ndpush('u')
	
	EXIT:	proc_op_exit(intname, nf, fnms, stlnr);



<data_field_declaration> ::= VAR { <field_initialization> ',' }+ ';' .

	INIT:	f_ := f_init;
		imlab := cllab;

		#*******************************************************#
		# All code of initialisations is written to the		#
		# (temporary) .in file; it is copied to the .im file	#
		# at the end of the class declaration, to go with the	#
		# init-procedure. The labels in all the field initiali-	#
		# zations must be unique; cllab remembers the label	#
		# most recently used.					#
		#*******************************************************#

	EXIT:	f_ := f_im;
		cllab := imlab;



<field_initialization> ::= <identifier> /id/
			   [ <operator_symbol> /ass/ <expression> /exp/ ] .


	INIT:	var name := '',
		    typ := '',
		    stlnr := lnr;

	/id/:	name := sy;
		offset := offset+1;
		if fieldentry(name, [clname, VAR, offset, NIL, NIL, undefined])
		   = 1
		then	symentry(name, level, 'c', '');
			data_flds := data_flds || sy || sc
		fi;
		typ := 'c' || sy;

	/ass/:	if sy ~= ':='
		then	ermsg('":=" expected instead of "' || sy || '"', lnr)
		fi;
		ndpush(typ);

	/exp/:	make_tuple(o_assign, 2);
		if errcnt = 0
		then	f_init.put('I:\t', stlnr, sc, ndpop(), sc,
				    lnr, sc, newl)
		fi;



<monadic_symbol_declaration> ::= MONADIC { <operator_symbol> /sy/ ',' }+ ';' .

	/sy/:	montab[sy] :=
		    array[sy || '.1', 1, -lnr, priofdef(1), priogdef(1)];



<dyadic_symbol_declaration> ::= DYADIC { <operator_symbol> /sy/ ',' }+ ';' .

	/sy/:	dytab[sy] :=
		   array[sy || '.2', 2, -lnr, priofdef(2), priogdef(2)];



<program_declaration> ::= PROGRAM <identifier> /id/
			  n_nms:<formals_of_procedure> /par/
			  ( <expression> | <empty> /emp/) [';'] .

	INIT:	var name := '',
		    nf := 0,
		    stlnr,
		    fnms := '';

		lastlnr := stlnr := lnr;
		loccnt := 0; loclist := empty_string; imlab := gllab;
		inproc := 1; level := level+1;

	/id/:	name := sy;
		if symtab[name] ~= undefined
		then	ermsg('"' || name || '" redeclared',lnr)
		fi;

	/par/:	nf := n_nms[0];
		loclist := fnms := n_nms[1];
		if nf > 1
		then	ermsg('program can have at most one parameter', lnr)
		fi;

	/emp/:	ndpush('u')

	EXIT:	inproc := 0;
		if errcnt = 0
		then	f_im.put(proghead, name, sc, convlocs(), sc, nf, sc, 
			 	 loccnt-nf, sc, stlnr, sc, lnr, tabsym,
				 ndpop(), sc, newl
		   	        )
		fi;
		remove(fnms); level := level-1; gllab := imlab;


<include_file> ::= INCLUDE <string_constant> ';' /treatstring/ .

	/treatstring/:
		if laststringcon = undefined
		then	ermsg('malformed include string', lnr);
		else	var s := laststringcon, f;
			if f := file(s, 'r') fails
			then ermsg('cannot open "' || s || '"', lnr)
			else	src_stack.append([f_src, src_name, line, lnr, lastlnr]);
				f_src := f;
				src_name := s;
				line := scan_string(f_src.get());
				lnr := 1;
				lastlnr := 1;
			fi
		fi;

<expression> ::= <monadic_expression>
		 ( <operator_symbol> /op/ <monadic_expression> ) * .

	INIT:	opush(dytab[o_lpar]);

	/op/:	check_dyop(sy);
		treatop(dytab[sy]);
	
	EXIT:	emptystack();



<monadic_expression> ::= <operator_symbol>* /op/ <primary> .

	/op/:	check_monop(sy);
		treatop(montab[sy]);



<primary> ::= a:<unit> ( /sub/ <subscript> | /sel/ <select> )* .

	/sub/:	if a[0] = 0
		then	ermsg('illegal subscription', lnr);
			a := a11;
		fi;

	/sel/:	if a[1] = 0
		then	ermsg('illegal field selection', lnr);
			a := a11;
		fi;



<subscript> ::= '[' <expression> ']' .

	EXIT:	make_tuple(o_arind, 2);


<select> ::= '.' <identifier> /id/ [ n:<actuals> ] .

	INIT:	n := 0;

	/id/:	ndpush('w' || sy);

	EXIT:	ndpush(qn || string(n+1));
		make_tuple(o_field, n+3);



<unit> ::=	  <constant>			/a01/
		| <identifier_or_call>		/a11/
		| <parenthesized_expression>	/a11/
		| <if_expression>		/a11/
		| <for_expression>		/a00/
		| <array_expression>		/a11/
		| <table_expression>		/a11/
		| <array_or_table_initialization>	/a11/
		| <case_expression>		/a11/
		| <while_expression>		/a00/
		| <return_expression>		/a00/
		| <scan_expression>		/a11/
		| <try_expression>		/a11/
		| <assert_expression>		/a11/
		| <self>			/a11/
		| <subject>			/a11/
		.

	INIT:	var a;

	/a00/:	a := a00;
	/a01/:	a := a01;
	/a11/:	a := a11;

	EXIT:	return(a);

	#***************************************************************#
	# The formal syntax allows a subscript and a field selection	#
	# following each unit. In some cases, it is however easy to	#
	# detect that subscription and/or selection are illegal: e.g.	#
	# after a while-do expression, which does not yield a value,	#
	# both subscription and selection are illegal; a constant can	#
	# not be subscripted. Therefore, unit returns an array which	#
	# denotes  whether subscription (0) and field selection (1)	#
	# are allowed.							#
	#***************************************************************#



<constant> ::=    <string_constant>  /str/
		| <integer_constant> /int/
		| <real_constant>    /real/
		| UNDEFINED	     /und/
		.

	/str/:	ndpush(sy);
	/int/:	ndpush('n' || sy);
	/real/:	ndpush('r' || sy);
	/und/:	ndpush('u');



<identifier_or_call> ::= <identifier> /id/ [ n:<actuals> /call/ ] .

	INIT:	var typ;

	/id/:	typ := checktype(sy);
		ndpush(typ);

	/call/:	if scan typ for any('lnrSu') rof
		then	ermsg('illegal call', lnr)
		fi;
		ndpush(qn || string(n));
		make_tuple(o_call, n+2);



<actuals> ::= '(' [ n:<expression_list> ] ')' .

	INIT:	n := 0;

	EXIT:	return(n);



<expression_list> ::= { <expression> /inc/ ','}+ .

	INIT:	var n := 0;
	/inc/:	n := n+1;
	EXIT:	return(n);

	#***************************************************************#
	# Expression_list parses at least one expression;		#
	# empty alternatives are always included explicitly		#
	# in the calling rule.						#
	#***************************************************************#



<self> ::= SELF .

	EXIT:	ndpush('m');
	        if clname = '' then ermsg('"self" used outside class', lnr) fi;



<subject> ::= SUBJECT .

	EXIT:	ndpush('b');



<return_expression> ::=   RETURN (  '(' (<expression> /rv/ | <empty> /re/) ')'
				  | <empty> /re/
			         ) /ret/
			| FRETURN /fr/ .

	INIT:	var n := 0;

	/rv/:	n := 1;

	/re/:	ndpush('u');

	/ret/:	make_tuple(o_ret, 1);
		if retcnt = undefined
		then	retcnt := n
		elif retcnt ~= n
		then	ermsg('incompatible number of return values', lnr)
		fi;

	/fr/:	ndpush('f');

	#***************************************************************#
	# There is a slight deviation here from the syntax accepted	#
	# by the "formal" imlementation: this rule accepts "return"	#
	# as well as "return()", while the formal syntax only accepts	#
	# "return".							#
	#***************************************************************#



<if_expression> ::=	IF <if_body> FI .

	#***************************************************************#
	# The syntax of the if-then-else deviates from the one given	#
	# in the formal definition of SUMMER. This is a consequence	#
	# of the parsetree structure, which for e.g.			#
	# "if t1 then e1 elif t2 then e2 fi" looks like			#
	# ife(t1, e1, ife(t2, e2, e3)). Building the innermost "ife"	#
	# first is simplified by the recursion.				#
	# Another possibility would be, to make 'ife' an n-adic operator#
	# like ";".							#
	#***************************************************************#



<if_body> ::=	<test>
		THEN <block>
	      (  ELIF <if_body>	/ife/
	       | ELSE <block>	/ife/
	       | <empty>	/ift/
	      ) .

	INIT:	lineinc();

	/ife/:	make_tuple(o_ifelse, 4);

	/ift/:	make_tuple(o_ifthen, 3);



<test> ::= <expression> [ FAILS /f/ | SUCCEEDS ] .

	/f/:	make_tuple('~', 1);



<case_expression> ::= CASE <expression> /def/
		      OF { ( <case_entry> /inc/ | <empty> ) ',' }*
			 ( DEFAULT ':' <block> | <empty> /nod/ ) 
		      ESAC .

	INIT:	var clab, deflab, gnm, n := 0;

		lineinc();

	/def/:	if errcnt = 0
		then	deflab := nextclab();
			f_cs.put('load\t', deflab, newl,
				 'int\t30\n', 'tabinit\n');
			gnm := nextglob();
			ndpush('g' || gnm)
		fi;

	/inc/:	n := n+1;

	/nod/:	ndpush('');	# no default expression #

	EXIT:	ndpush(deflab);
		if errcnt = 0
		then	f_cs.put('asglob\t', gnm, newl, 'void', newl);
			ndpush(qn || string(n));
			make_tuple(o_case, 2*(n+1)+4)
		fi;



<case_entry> ::= <block> ( ':' /tst/ <block> )+ .

	INIT:	var clab, n := 0;

		if errcnt = 0
		then	clab := nextclab();
			f_cs.put('load\t', clab, newl)
		fi;

	/tst/:	key_out();
		n := n+1;

	EXIT:	if errcnt = 0
		then	f_cs.put('tabelem\t', n, newl)
		fi;
		ndpush(clab);

	#***************************************************************#
	# In order to enforce the LL(1) property, the constant key in	#
	# a case is parsed as a block. The procedure key_out afterwards	#
	# checks, whether this block was indeed a simple constant: if	#
	# not, an error message is issued.				#
	# The LL(1) restrictions also require that <case_entry>s cannot #
	# produce empty, hence the repetition.				#
	#***************************************************************#



<while_expression> ::= WHILE <test> DO <block> OD .

	INIT:	inloop := inloop + 1;
		lineinc();

	EXIT:	make_tuple(o_whiledo, 3);
		inloop := inloop - 1;



<for_expression> ::= FOR <identifier> /id/ IN <expression> /exp/
		     DO <block> OD .

	INIT:	var typ, var1, var2;

		inloop := inloop + 1;
		lineinc();

	/id/:	typ := checktype(sy);
		if ~scan typ
		    for lit('l') | lit('g') | lit('c') | lit('w') rof
		then	ermsg('illegal control variable in for loop', lnr)
		fi;
		if errcnt = 0
		then	if inproc = 1
			then	var1 := 'l' || string(loccnt);
				var2 := 'l' || string(loccnt + 1);
				loccnt := loccnt + 2;
				loclist := loclist || ',,'
				   # to keep the relationship between local #
				   # number and position in loclist valid   #
				   # for the sake of the tracer. 	    #
			else	var1 := 'g' || nextglob();
				var2 := 'g' || nextglob()
			fi;
			ndpush(var1)
		fi;

	/exp/:	ndpush(var2);
		ndpush(typ);

	EXIT:	make_tuple(o_for, 6);
		inloop := inloop - 1;

	#***************************************************************#
	# 'for x in c do e od' is translated as if it reads		#
	#	var1 := undefined;					#
	#	var2 := c;						#
	#	while [x,var1] := var2.next(var1) do e od;		#
	# On the im-file the operands are put out in the order		#
	# 	line increment, var1, c, var2, x, e			#
	#***************************************************************#



<scan_expression> ::= SCAN <expression> FOR <block> ROF .

	EXIT:	make_tuple(o_scanfor, 2);



<try_expression> ::= TRY n:<expression_list> /exp/
		     (UNTIL /tru1/ <block> /tru2/ | <empty> /try/)
		     YRT .

	INIT:	lineinc();

	/exp/:	ndpush(qn || string(n));

	/tru1/:	inloop := inloop + 1;

	/tru2/:	make_tuple(o_tru, n+3);
		inloop := inloop - 1;

	/try/:	ndpush(empty_string);
		make_tuple(o_try, n+3);

	#***************************************************************#
	# The code generated for the two forms of the try-statement	#
	# (with or without until) is nearly identical. The value	#
	# delivered is in the first case the value delivered by the	#
	# expression following 'until', and in the second case the value#
	# delivered by the succeeding expression in the list following	#
	# 'try'. This is signalled to the code-generator by the two	#
	# different operator forms.					#
	#***************************************************************#



<assert_expression> ::= ASSERT <expression> .

	EXIT:	make_tuple(o_assert, 1);



<parenthesized_expression> ::= '(' <block> ')' .



<array_expression> ::= ARRAY (  <size_definition>
				[ 'init' n:<array_initialization> ]
			      | /nosz/ n:<array_initialization> 
			     ) .
	INIT:	n := 0;

	/nosz/: ndpush('n0'); ndpush('u');

	EXIT:	ndpush(qn || string(n)); make_tuple(o_arinit, n+3);



<size_definition> ::= '(' <expression> ',' <expression> ')' .



<array_initialization> ::= '[' n:<expression_list> ']' .

	EXIT:	return(n);



<table_expression> ::= TABLE (  <size_definition>
				[ 'init' nsum:<table_initialization> /mkt/ ]
			      | /nosz/ nsum:<table_initialization> /mkt/
			     ) .

	INIT:	nsum := [0,0];	# number of table_elements; number of keys #

	/nosz/:	ndpush('n0'); ndpush('u');

	/mkt/:	# INSERT REAL CODE HERE #
	EXIT:	ndpush(qn || string(nsum[0]));	# number of table_elements #
		ndpush(qn || string(nsum[1]));	# number of keys #
		make_tuple(o_tabinit, nsum[0]+4);



<table_initialization> ::= '[' { nk:<table_element> /nxt/ ',' }* ']' .

	INIT:	var n := 0,
		    sumk := 0;

	/nxt/:	n := n+1;
		sumk := sumk + nk;

	EXIT:	return([n, sumk]);



<table_element> ::= { <expression> /inc/ ':' }+ .

	INIT:	var m := 0;

	/inc/:	m := m+1;

	EXIT:	if m <= 1
		then	ermsg('key(s) missing in table', lnr)
		fi;
		ndpush(qn || string(m-1));
		make_tuple(o_key, m+1);
		return(m-1);



<array_or_table_initialization> ::=
		'['
		 (   ']' /ar/
		   | <expression>
			  (   /one/ ']' /ar/
			    | ',' n:<expression_list> /inc/ ']' /ar/
			    | ':' nk:<table_element_tail> /nxt/
			      [ ',' { nk:<table_element> /nxt/ ',' }* ]
			      ']' /tab/
			  )
		 ) .

	INIT:	var sumk := 0;

		n := 0;
		ndpush('n0'); ndpush('u');

	/one/:	n := 1;

	/inc/:	n := n+1;

	/ar/:	ndpush(qn || string(n));
		make_tuple(o_arinit, n+3);

	/nxt/:	sumk := sumk + nk;
		n := n+1;

	/tab/:	ndpush(qn || string(n));
		ndpush(qn || string(sumk));
		make_tuple(o_tabinit, n+4);



<table_element_tail> ::= {<expression> /inc/ ':'}+ .

	INIT:	var m := 1;	# the expression parsed already! #

	/inc/:	m := m+1;

	EXIT:	ndpush(qn || string(m-1));
		make_tuple(o_key, m+1);
		return(m-1);



<block> ::= (   v:<local_variable_declaration> /var/
	      | c:<constant_declaration>       /cns/
	    )*
	      { [<expression> /cnt/] ';' }* .

	INIT:	var vnms := '',
		    cnms := '',
		    n := 0;

		level := level+1;

	/var/:	n := n + v[0];
		vnms  := vnms || v[1];

	/cns/:	cnms := cnms || c;

	/cnt/:	n := n+1;

	EXIT:	if n = 0
		then	ndpush('u')
		elif n ~= 1
		then	ndpush(qn || string(n));
			make_tuple(o_semi, n + 1)
		fi;
		if vnms ~= empty_string then remove(vnms) fi;
		if cnms ~= empty_string then remove(cnms) fi;
		level := level - 1



<local_variable_declaration> ::=
			VAR { li:<local_initialization> /nxt/ ',' }+ ';' .

	INIT:	var n := 0,
		    nms := '';

		if inproc = 0
		then	ermsg('local variable declarations outside procedure',
				lnr)
		fi;

	/nxt/:
		if li[0] = 1 then nms := nms || li[1] || sc fi;
		n := n + li[2];

	EXIT:	loclist := loclist || nms;
		return([n, nms]);



<local_initialization> ::= <identifier> /id/
			   (  <operator_symbol> /ass/ <expression> /notemp/
			    | <empty> /emp/
			   ) .

	INIT:	var name := '',
		    new := 0, typ, g := 0;

	/id/:	name := sy;
		typ := 'l' || string(loccnt);
		new := symentry(sy, level, 'l', loccnt);
		loccnt := loccnt + 1;

	/ass/:	if sy ~= ':='
		then	ermsg('":=" expected instead of "' || sy || '"', lnr)
		fi;
		ndpush(typ);

	/notemp/:
		make_tuple(o_assign, 2);
		g := 1;

	/emp/:	if inloop > 0
		then	ndpush(typ);
			ndpush('u');
			make_tuple(o_assign, 2);
			g := 1;
		fi;

	EXIT:	return([new, name, g]);

	#***************************************************************#
	# All declarations of local variables are translated as assign-	#
	# ments, either of the initialisation expression, or of the	#
	# value 'undefined'. The latter is done to assure that variables#
	# local to a loop body are re-initialised on each new entry of	#
	# the body.							#
	#***************************************************************#



<empty> ::= .
