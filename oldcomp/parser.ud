#*************************************************************************#
#*************************************************************************#
#**									**#
#**		INTERMEDIATE CODE GENERATOR				**#
#**									**#
#** This file contains declarations which enable intermediate code	**#
#** generation by the SUMMER parser. Together with the file parser.syn	**#
#** and parser.sn, it form the input for pgen, a parsergenerator written**#
#** in SUMMER.								**#
#**									**#
#** Variables/procedures used here which are (pre)defined by the	**#
#** parsergenerator:							**#
#** 	ermsg:		issues error messages,				**#
#**	errcnt:		number of errors in source,			**#
#**	lnr:		current source line number.			**#
#**									**#
#** Procedure defined in parser.ns:					**#
#**	convstr:	converts a string to internal representation.	**#
#**									**#
#*************************************************************************#
#*************************************************************************#

const	lpar		:= '(',
	colon		:= ':',
	qn		:= 'n',
	tabsym		:= '\t',
	sc		:= ',',
	newl		:= '\n',
	quote		:= '''',
	NIL		:= '~nil',
	SIMPLE		:= '~simple',
	PROC		:= '~proc',
	VAR		:= '~var',
	coltab		:= ':\t',
	prochead	:= 'P:\t',
	classhead	:= 'C:\t',
	classbegin	:= 'CLASS:\t',
	globhead	:= 'G:\t',
	proghead	:= 'M:\t',
	fetch_type	:= 'fetch',
	store_type	:= 'store',

	o_assign	:= ':=',
	o_lpar		:= '(',
	o_whiledo	:= 'wd',
	o_ifthen	:= 'ift',
	o_ifelse	:= 'ife',
	o_scanfor	:= '?',
	o_for		:= 'fr',
	o_case		:= 'cs',
	o_arind		:= 'ind',
	o_field		:= 'fld',
	o_try		:= 'try',
	o_tru		:= 'tru',
	o_assert	:= 'as',
	o_semi		:= ';',
	o_call		:= 'cl',
	o_opcall	:= 'clo',
	o_arinit	:= 'ar',
	o_key		:= 'key',
	o_tabinit	:= 'tb',
	o_ret		:= 'rt',




	S_TYPE		:= 0,
	S_LEVEL		:= 1,
	S_NEXT		:= 2,
	S_VALUE		:= 3,

	F_CLNAME	:= 0,
	F_TYPE		:= 1,
	F_INTERN	:= 2,
	F_FETCH		:= 3,
	F_STORE		:= 4,
	F_NEXT		:= 5,

	O_NAME		:= 0,
	O_ADIC		:= 1,
	O_STATUS	:= 2,
	O_PRIOF		:= 3,
	O_PRIOG		:= 4;






#*************************** GENERAL GLOBAL VARIABLES *********************#


var	f_im,
		# File containing the parsetrees of procedures,		#
		# operators and classes.				#
	f_gl,
		# File containing the parsetree for initialisations of	#
		# globals.						#
	f_init,
		# Scratch file used by 'classdecl' to assemble code	#
		# for initialisation of fields in classes.		#
	f_cs,
		# File containing the case tables.			#
	f_,
		# The current output file for tuples. It is initialized #
		# to f_im. Procedure 'var' sets it to either f_gl (for  #
		# initialisation of globals) or f_in (for initialisation#
		# of fields), and resets it to f_im before returning.	#
		# 'make_tuple' and 'var' itself write to _f.		#

	f_er,
		# error message file					#
	src_name,
		# The name of the current source file			#
	errors_on_tab := table(5, undefined),
		# Administrates on which files errors have occurred, in	#
		# order to produce 'errors on ...' only when 		#
		# necessary. See procedure err				#
	src_stack := [],
		# Source files stack. Pushed by 'include_file' with	#
		# current source file, current linenumber and current	#
		# line. Popped by 'nextsym' on EOF.			#

	opstack := [],
		# The operator stack.					#
		# The stack is pushed by 'opush', popped by 'opush'	#
		# Elements on opstack are entries from montab and dytab.#

	ndstack := [],
		# The operand stack.					#
		# Pushed by 'ndpush', popped by 'ndpop'			#
		# Entries on the stack are operands.        		#

	symtab	  := table (100, undefined) init
	[	'string':	'real':		'integer':
		'scan_string':			   ['ab', 0, undefined, '2'],
		'file':		'bits':		   ['ab', 0, undefined, '3'],
		'interval':			   ['ab', 0, undefined, '4'],
		'stop':		'copy':		'type':
						   ['gb', 0, undefined, '1'],
		'put':		'get':		   ['gb', 0, undefined, '?'],
		'stand_in':	'stand_out':	'stand_er':
						   ['g', 0, undefined, '']
	],
		# Symbol table. Keys are all variables defined at the	#
		# current source program point. Entries contain type,	#
		# level and pointer to namesake.			#

	fieldtab := table(50, undefined) init
	[  'any':    ['scan_string', PROC, 'any'  ,  'any',    NIL, undefined],
	   'append': ['array',       PROC, 'append', 'append', NIL, undefined],
	   'break':  ['scan_string', PROC, 'break',  'break',  NIL, undefined],
	   'center': ['string',      PROC, 'center', 'center', NIL, undefined],
	   'close':  ['file',	     PROC, 'close',  'close',  NIL, undefined],
	   'compl':  ['bits',        PROC, 'compl',  'compl',  NIL, undefined],
	   'conj':   ['bits',        PROC, 'conj',   'conj',   NIL, undefined],
	   'delete': ['array',       PROC, 'delete', 'delete', NIL, undefined],
	   'disj':   ['bits',        PROC, 'disj',   'disj',   NIL, undefined],
	   'find':   ['scan_string', PROC, 'find',   'find',   NIL, undefined],
	   'get':    ['file',        PROC, 'get',    'get',    NIL, undefined],
	   'index':  ['array',       PROC, 'index',  'index',  NIL,
		      ['table',       PROC, 'index',  'index',  NIL,
		       ['string',      PROC, 'index',  'index',  NIL,
			['bits',	PROC, 'index',  'index',  NIL,
			 undefined
		     ]]]],
	   'last':   ['array',       PROC, 'last',   'last',   NIL, undefined],
	   'left':   ['string',      PROC, 'left',   'left',   NIL, undefined],
	   'lit':    ['scan_string', PROC, 'lit',    'lit',    NIL, undefined],
	   'move':   ['scan_string', PROC, 'move',   'move',   NIL, undefined],
	   'next':   ['string',      PROC, 'next',   'next',   NIL,
		      ['array',       PROC, 'next',   'next',   NIL,
		       ['table',       PROC, 'next',   'next',   NIL,
			['interval',    PROC, 'next',   'next',   NIL,
		         ['bits',        PROC, 'next',   'next',   NIL,
                         undefined
                     ]]]]],
	   'pos':    ['scan_string', PROC, 'pos',    'pos',    NIL, undefined],
	   'put':    ['file',        PROC, 'put',    'put',    NIL, undefined],
	   'repl':   ['string',      PROC, 'repl',   'repl',   NIL, undefined],
	   'replace':['string',      PROC, 'replace','replace',NIL, undefined],
	   'retrieve':['array',      PROC, 'retrieve',  'retrieve',  NIL,
		      ['table',       PROC, 'retrieve',  'retrieve',  NIL,
		       ['string',      PROC, 'retrieve',  'retrieve',  NIL,
			['bits',	PROC, 'retrieve',  'retrieve',  NIL,
			 undefined
		     ]]]],
	   'reverse':['string',      PROC, 'reverse','reverse',NIL, undefined],
	   'right':  ['string',      PROC, 'right',  'right',  NIL, undefined],
	   'rpos':   ['scan_string', PROC, 'rpos',   'rpos',   NIL, undefined],
	   'rtab':   ['scan_string', PROC, 'rtab',   'rtab',   NIL, undefined],
	   'size':   ['array',       PROC, 'size',   'size',   NIL,
		      ['bits',        PROC, 'size',   'size',   NIL,
		       ['string',      PROC, 'size',   'size',   NIL,
                        ['table',       PROC, 'size',   'size',   NIL,
		         undefined
		     ]]]],
	   'sort':   ['array',       PROC, 'sort',   'sort',   NIL, undefined],
	   'span':   ['scan_string', PROC, 'span',   'span',   NIL, undefined],
	   'substr': ['string',      PROC, 'substr', 'substr', NIL, undefined],
	   'tab':    ['scan_string', PROC, 'tab',    'tab',    NIL, undefined],
	   'update':['array',        PROC, 'update',  'update',  NIL,
		      ['table',       PROC, 'update',  'update',  NIL,
			['bits',	PROC, 'update',  'update',  NIL,
			 undefined
		     ]]],
	   'bal':    ['scan_string', PROC, 'bal',    'bal',    NIL, undefined],
	   'text':   ['scan_string', VAR,   0,        SIMPLE,  NIL, undefined],
	   'cursor': ['scan_string', VAR,   1,        SIMPLE,  NIL, undefined]
	],
	   	# Fieldtable. Keys are all field names defined up to the#
		# current program point. Entries consist of classname,	#
		# PROC or VAR, the internal name (for procedures) or the#
		# offset (for data-fields), the fetch association, the  #
                # store association, and a successor.			#
		# For operator fields, the key is the internal operator	#
		# name (without class suffix): for a monadic (dyadic)	#
		# operator @, '@.1' ('@.2').				#
	stdops := table(10, undefined) init [
	   '+.2':
	   '-.2':
	   '-.1':
	   '*.2':
	   '/.2':
	   '%.2':
	   '||.2':
	   '=.2':
	   '~=.2':
	   '>.2':
	   '>=.2':
	   '<.2':
	   '<=.2':
			1
	],
		# stdops, table with standard operators, used by	#
		# make_decls to force fld declarations of otherwise	#
		# not redefined standard operators.			#

        classtab := table(10, undefined),
		# Class table. Keys are classnames, entries are arrays	#
		# of five elements. The first one contains the number of#
		# datafields declared within the class (used by		#
		# 'make_decls'), the other four contain the fieldnames, #
		# separated according to their type: the seond element	#
		# contains the parameters, the third the remaining data-#
		# fields, the fourth the procedures, anf the fifth the	#
		# operators. These elements are used by 'do_subclass'	#
		# when a subclass is defined.				#

	inhertab := table(10, undefined),
		# During the parse of a subclass, inhertab contains	#
		# entries for fields which are inherited from the super-#
		# class and may still be redefined.			#

        fetchtab := table(5, undefined),
	storetab := table(5, undefined),
		# Keys are fieldnames occurring in respectively the	#
		# 'fetch' and the 'store' declaration of the current	#
		# class. Values are the associations ('_s' for simple,	#
		# or a name).						#

	assoctab := table(5, undefined),
		# keys are procedure names declared as associations,	#
		# values are fetch_ or store_type. Used to check whether#
		# number of arguments and return values are correct.	#

	loclist := '',
		# Names of locals of the current procedure. Used to	#
		# produce string representing symbolic names (convlocs).#

	par_flds := '',
	data_flds := '',
	proc_flds := '',
	op_flds := '',
		# parameters, data fields and procedure and operator	#
		# fields of current class.				#
		# Names of fields of current class. Used by 'undefine'	#
		# to remove them from symtab on class exit.		#

	level := 0,
		# Current depth of name-nesting. Incremented on proce-	#
		# dure entry, on class entry and on block entry. Decre-	#
		# Used by 'symentry' to check for illegal redefinitions.#
	loccnt := 0,
		# Determines the offset of the next local variable to	#
		# be declared. For global procedures and operators, the	#
		# offset is initially 0; for classes and their associa-	#
		# ted procedures it is 1, as 0 is reserved for the class#
		# object passes as additional argument.			#
		# Because the tracer needs a unique mapping from local	#
		# numbers to associated names, the offset is not reset	#
		# on block exit. This does however cause an inefficient	#
		# use of space in the interpreter.			#

	classcnt := 0,
		# To determine class sequence number. Incremented on 	#
		# entry of a new class.					#

	clsuffix := '',
		# The current class suffix: '.' || classcnt. Used to	#
		# determine internal names of procedures and operators	#
		# defined within a class. (See proceduress 'procedure',#
		# 'operator', 'putopassoc' and 'putassocs'.		#
	retcnt,
		# The current number of return values in a procedure.	#
		# Is set to undefined on procedure entry, and reset to	#
		# 0 or 1 by 'mkrets'.					#

	clab := 0,
		# Determines the next case label. ('nextclab').		#
	glcnt := 0,
		# Determines the next global name invented by the	#
		# parser (see 'nextglob').				#
	imlab,
		# Determines the next label denoting a complex operand.	#
		# Reset to 0 on procedure entry, incremented for each	#
		# new complex operand by 'make_tuple'.			#
	cllab,
		# Guarantees continuity in the numbering of labels	#
		# denoting complex operands in initialisations of data	#
		# fields in a class. 'cllab' is set to 0 on class entry.#
		# It provides a strating value for 'imlab' when parsing	#
		# data field declarations (procedure 'vars') and is set	#
		# to the then current value of 'imlab' at the end of	#
		# such declarations. It also provides the starting value#
		# 'imlab' for parsing the class init statement.		#
	gllab := 0,
		# Plays a similar role for globals; provides the	#
		# starting value for 'imlab' when parsing global initia-#
		# lisations, and when parsing the main program body.	#
	offset,
		# The current class offset. Set to 0 on class entry,	#
		# incremented for each new data field.			#
	pname,
		# Name of the summer source, without the .sm extension.	#
		# Used by 'error', 'make_decls', 'classdecl' and the	#
		# main program to construct the names of intermediate	#
		# files.						#
	clname,
		# The name of the current class. Used to make field-	#
		# entries ('procedure', 'vars', 'operator', 'params')	#
		# and to check whether a field is not redefined within	#
		# the same class ('fieldentry').			#
	inproc := 0,
		# Flag which signals whether the current program point	#
		# lies within a procedure, an operator, a class init	#
		# statement or the main program. Used by 'locvars' to	#
		# detect illegal local declarations (allowed only when	#
		# inproc = 1), and by 'forloop' to recognize whether it	#
		# must invent global or local variables.		#
	inloop := 0,
		# Indicator for nesting level inside while, for or try	#
		# expressions; used to determine whether explicit	#
		# variable initialization should be generated for	#
		# declaration without initializing expression.		#
		# See <local_initialization>.				#

	lastlnr := 1,
		# The source line number on which the most recent line	#
		# increment was generated. (Such an instruction enables	#
		# the interpreter and the tracer to compute source line	#
		# numbers from the ic-code). 'lastlnr' is set to lnr by #
		# 'lineinc' and each time an absolute linenumber is	#
		# generated in the code.				#




	montab := table (20, undefined) init
		[	'-' :		['-1', 1,0,13,14],
			'~' :		['~',  1,0,13,14]
                ],


        dytab := table(20, undefined) init
                [       ':=':           [':=', 2, 0,  7, 8],
                        '+' :           [ '+', 2, 0, 11,11],
                        '-' :           ['-2', 2, 0, 11,11],
                        '*' :           [ '*', 2, 0, 12,12],
                        '/' :           [ '/', 2, 0, 12,12],
                        '%' :           [ '%', 2, 0, 12,12],
                        '||':           ['||', 2, 0, 13,13],
                        '&' :           [ '&', 2, 0,  6, 6],
                        '|' :           [ '|', 2, 0,  4, 5],
                        '<' :           [ '<', 2, 0, 10,10],
                        '<=':           ['<=', 2, 0, 10,10],
                        '>' :           [ '>', 2, 0, 10,10],
                        '>=':           ['>=', 2, 0, 10,10],
                        '=' :           [ '=', 2, 0, 10,10],
                        '~=':           ['~=', 2, 0, 10,10],
                        '(' :           [ '(', 2, 0,  1, 2]
		],
		# 'montab' and 'dytab' map operator names to a 5-tuple,	#
		# consisting of the following items:			#
		# - An internal name (without class suffix). For user	#
		#   defined operators, this is their external name	#
		#   followed by a dot followed by 1 or 2 according to	#
		#   their adicity.					#
		# - A 1 for monadic and a 2 for dyadic operators.	#
		#   Entries from montab and dytab are stacked on the	#
		#   operator stack, and unstacked (by 'treatop' and	#
		#   'emptystack') without knowing from which table they #
		#   originally came. Hence the necessity to include the #
		#   adicity.						#
		# - A declaration status indicator:			#
		#   - 0 for build in, global operators.			#
		#   - 1 for user defined, global operators as yet 	#
		#     without a namesake within a class.		#
		#   - 2 for user defined, global operators with a name-	#
		#     sake within a class. User defined operators which #
		#     occur both globally and within a class, get an    #
                #     additional entry in 'fieldtab'. The 1 and 2 serve #
		#     to see whether this entry has been made already.	#
		#     (see also 'operator' and 'addglobf').		#
		#   - 3 for operators defined as yet only within a class#
		#     Built-in class operators don't occur as yet, but  #
		#     should get the same treatment as user defined	#
		#     ones, i.e. when a global namesake is defined, an  #
		#     additional entry must be amde in the fieldtable.  #
		#   - -lnr for operator names occurring in 'monadic' and#
		#     'dyadic' declarations, but not yet defined. lnr	#
		#     is the source line number on which the declaration#
		#     occurred, rememberd here in order to be able to	#
		#     issue an error message at the correct line when	#
		#     the operator remains undefined.			#
		#   - The f-priority.					#
		#   - The g-priority.					#
		#   All user defined operators get the same priority.   #

	a00 := [0, 0],
	a01 := [0, 1],
	a11 := [1, 1];
		# Three array constants frequently used by <unit>	#



#********* Procedures to produce tuples on the intermediate file *******#

proc ord_choice(opr, n)
return( case opr of
		o_assign:	ord_ass(n),
		o_semi:		ord_semi(n),
		o_call:		ord_call(n),
		o_opcall:	ord_opcall(n),
		o_field:	ord_fields(n),
		o_arinit:	ord_arinit(n),
		o_key:		ord_key(n),
		o_tabinit:	ord_tabinit(n),
		o_case:		ord_case(n),
		o_try:
		o_tru:		ord_try(n),
		default:	ord_def(n)
	esac
       );

	# The order in which the operands are pushed on the operand stack #
	# is not always the one in which they are needed by the code	  #
	# generator. The procedures starting with ord_ return an array	  #
	# in which the i-th index denotes the operand position in the	  #
	# final tuple, of the operand which is the i-th to be popped from #
	# the operand stack.						  #
	# For example, the operands of the operator call '10 @ 11' are	  #
	# popped from the stack in the order 'n2', 'o@.2', 'n11', 'n10',  #
	# but should appear on the im-file in the order 'o@.2', 'n2',	  #
	# 'n10', 'n11'. So for this case, 'ord_opcall' returns [1,0,2,3]. #
	# The comment accompanying each ord_ procedure contains one such  #
	# an example, with the stack groeing to the right.		  #
	# The argument of the ord_ procedures is the number of operands.  #
	# The default case is returned by 'ord_def', which if called with #
	# a number n as argument, returns the integers from n-1 to 0 in	  #
	# that order.							  #
var	ad0	:= [],
	ad1	:= [0],
	ad2	:= [1, 0],
	ad3	:= [2, 1, 0],
	ad4	:= [3, 2, 1, 0],
	ad5	:= [4, 3, 2, 1, 0],
	ad6	:= [5, 4, 3, 2, 1, 0],
	advec	:= [ad0, ad1, ad2, ad3, ad4, ad5, ad6];


proc ord_def(n)
if n <= 6 then return(advec[n])
else
	var o := array(n,0),
	    i;

	for i in o.index do o[i] := n-i-1 od;
	return(o)
fi;
	# a + b.			#
	# stack:	a,b;		#
	# im:		a,b;		#

var	aa01	:= [0,1];

proc ord_ass(n)		return(aa01);
	# x := e.			#
	# stack:	x,e;		#
	# im:		e,x;		#


proc ord_semi(n)
(	var o := array(n,0),
	    i;

	for i in interval(1, n-1, 1)
	do o[i] := n-i od;
	return(o)
);	# o[0] = 0 #
	
	# s1; s2; s3;			#
	# stack:	s1,s2,s3,3;	#
	# im:		3,s1,s2,s3.	#

var	ao1032	:= [1, 0, 3, 2],
	ao102	:= [1, 0, 2];

proc ord_opcall(n)
	if n = 4
	then	return(ao1032)
	elif n = 3
	then	return(ao102)
	else	comermsg('in ord_opcall')
	fi;

	# x @ y;			#
	# stack:	x,y,o@,2;	#
	# im:		o@,2,x,y;	#


proc ord_call(n)
(	var o := array(n,0) init [1],
	    i;

	for i in interval(1, n-2, 1)
	do	o[i] := n-i od;
	return(o)
);	# o[n-1] = 0 #

	# p(a1, a2);			#
	# stack:	p,a1,a2,2;	#
	# im:		p,2,a1,a2;	#

proc ord_fields(n)
(	var o := array(n,0) init [1],
	    i;

	for i in interval(1, n-3, 1)
	do o[i] := n-i od;
	o[n-1] := 2;
	return(o)
);	# o[n-2] = 0 #

	# c.f(a)			#
	# stack:	c,f,a,2;	#
	# im:		f,2,c,a;	#


proc ord_arinit(n)
(	var o := array(n,0),
	    i;

	for i in interval(1, n-3, 1)
	do o[i] := n-i-2 od;
	o[n-2] := n-2;
	o[n-1] := n-1;
	return(o)
);	# o[0] = 0 #

	# array(3,0)[7,8]		#
	# stack:	3,0,7,8,1;	#
	# im:		2,7,8,0,3;	#

proc ord_key(n)
(	var o := array(n,0) init [0,1],
	    i;

	for i in interval(2,n-1,1)
	do o[i] := n-i+1 od;
	return(o)
);
	# 'a': 'b': 1,			#
	# stack:	'a','b',1,2;	#
	# im:		2,1,'a','b';	#

proc ord_tabinit(n)
(	var o := array(n,0) init [0, 3],
	    i;
	for i in interval(2, n-3, 1)
	do o[i] := n-i+1 od;
	o[n-2] := 1;
	o[n-1] := 2;
	return(o)
);
	# table(10,0)['a':'b':1, 'c':2]	#
	# stack:	10,0,k1,k2,2,3;	#
	# im:		3,0,10,2,k1,k2;	#
	# k1 and k2 are produced by	#
	# mk_tuple(o_key, ..).		#

proc ord_case(n)
(	var o := array(n, 0) init [3],
	    i;

	for i in interval(1, n-5, 2)
	do	o[i]   := n-i-1;
		o[i+1] := n-i
	od;
	o[n-3] := 2;
	o[n-2] := 1;
	o[n-1] := 0;
	return(o)
);
	# case e of v1: e1, v2: e2, default: ed esac	#
	# stack: l_inc,e,g_c,e1,C1,e2,C2,ed,Cd,2;	#
	# im:	 l_inc,e,g_c,2,C1,e1,C2,e2,Cd,ed; 	#
	# l_inc is a line increment;			#
	# g_c is the global to which the case_table	#
	# is assigned;					#
	# Lx is the label designating ex.		#

proc ord_try(n)
(	var o := array(n, 0) init [n-1, 1],
	    i;

	for i in interval(2, n-2, 1)
	do o[i] := n-i od;
	return(o)
);	# o[n-1] = 0 #

	# try e1, e2, e3 until eu yrt;	#
	# stack: e1,e2,e3,3,eu;		#
	# im:    l_inc,3,e1,e2,e3,eu;	#





proc make_tuple(opr, n)
if errcnt = 0
then	var ands, ord, i, lab;

	ord := ord_choice(opr, n);
	ands := array(n, '');
	for i in ord do ands[i] := ndpop() od;

	  ndpush(try_eval(opr, ands))
	| (	lab := 'L' || string(imlab := imlab + 1);
	  	f_.put(lab, coltab, opr, tabsym);
	  	for i in ands do f_.put(i, sc) od;
	  	f_.put(newl);
	  	ndpush(lab)
	  )
fi;
	# Make-tuple writes labeled tuples to the current output file	#
	# assigned to the global 'f_'. Its possible values are 'f_im',	#
	# 'f_gl' or 'f_in'. The arguments of 'make_tuple' are an	#
	# operator and the number of operands. (For a listing of pos-	#
	# sible operators, see D.....). 'make_tuple' pops the right	#
	# number of operands from the operand stack and reorders them	#
	# if necessary. Then make_tuple calls try_eval, which tests	#
	# whether the expression is a simple constant expression which	#
	# can be evaluated by the compiler. If this succeeds, the	#
	# result is pushed back on the stack. Otherwise, make_tuple	#
	# writes the new tuple (operator + operands) with a	#
	# label attached to them to the current output file, and pushes #
	# that label on the operand stack.				#



proc try_eval(opr, ands)
(	var r, a0, a1;

	if case opr of
	        '+':	r := try_and(ands[0]) + try_and(ands[1]),
	        '-2':	r := try_and(ands[0]) - try_and(ands[1]),
		'-1':	r := - try_and(ands[0]),
	        '*':	r := try_and(ands[0]) * try_and(ands[1]),
	        '/':	a0 := try_and(ands[0]) & a1 := try_and(ands[1]) &
	            	if a1 = 0
		    	then	ermsg('division by 0', lnr); freturn
			else	r := a0/a1
			fi,
	        '%':	a0 := try_and(ands[0]) &
			a1:= try_and(ands[1]) &
            	       	if a1 = 0
			then	ermsg('division by 0', lnr);
				freturn
			elif type(a0) ~= type(a1) ~= 'integer'
			then	ermsg('% requires integer operands',lnr);
				freturn
			else r := a0 % a1
			fi,
	        default:
             	       freturn
	    esac fails
	then	freturn
	else	case type(r)
		of 'real':	return('r' || string(r)),
		   'integer':	return('n' || string(r))
		esac
	fi
);

proc try_and(and)
scan and
for	case move(1)
	of	'n':		return(integer(rtab(0))),
		'r':	 	return(real(rtab(0))),
		default:	freturn
	esac
rof;


proc key_out()
if errcnt = 0
then	var r := ndpop();

	scan r
	for	if   lit('r') then f_cs.put('real\t', rtab(0), newl)
		elif lit('n') then f_cs.put('int\t',  rtab(0), newl)
		elif lit('S') then f_cs.put('load\t', text,    newl)
		elif lit('z') then f_cs.put('nullstr', newl)
		elif lit('u') then f_cs.put('undef', newl)
		else ermsg('key in case not constant', lnr)
		fi
	rof
fi;

#************ Procedures for the treatment of operators ****************#




proc check_monop(symbol)
if montab[symbol] = undefined
then	if dytab[symbol] = undefined
	then	ermsg('"' || symbol || '" undefined', lnr)
	else	ermsg('dyadic operator "' || symbol
		      || '" used in monadic position', lnr)
	fi
fi;


proc check_dyop(symbol)
if dytab[symbol] = undefined
then	if montab[symbol] = undefined
	then	ermsg('"' || symbol || '" undefined', lnr)
	else	ermsg('monadic operator "' || symbol
		      || '" used in dyadic position', lnr)
	fi
fi;



proc opush(opr)
if errcnt = 0 then opstack.append(opr); fi;

proc opop()
if errcnt = 0 then return(opstack.delete) fi;
	# Pushing and popping the operator stack.			#

proc ndpush(and)
if errcnt = 0 then ndstack.append(and) fi;

proc ndpop()
if errcnt = 0 then return(ndstack.delete) fi;

	# Pushing and popping the operand stack				#

proc priofdef(nf)
	return(if nf = 1 then 13 else 9 fi);
	# The standard f-priorities (monadic: 13, dyadic: 9) for user	#
	# defined operators.						#

proc priogdef(nf)
	return(if nf = 1 then 14 else 9 fi);
	# The standard g-priorities for user defined operators.		#


proc treatop(newop)
if errcnt = 0
then(	var prg, oldop;

	prg := newop[O_PRIOG];
	while  opstack.last[O_PRIOF] >= prg
	do	oldop := opop();
		if oldop[O_STATUS] = 0
		then	make_tuple(oldop[O_NAME], oldop[O_ADIC])
		else	var a := oldop[O_ADIC];

			ndpush('o' || oldop[O_NAME]);
			ndpush(qn || string(a));
			make_tuple(o_opcall, a+2)
		fi
	od;
	opush(newop)
    )
fi;
	# The argument is an operator (or, more accurately, an entry	#
	# from 'montab' or 'dytab') to be pushed on the operator stack.	#
	# Before this is done, operators are popped from opstack and	#
	# handed to make_tuple until one is found with an f-priority	#
	# lower than the g-priority of the new operator. (See D......)	#
	# A left parenthesis has an f-priority lower than the g-priority#
	# of any operator and is hence never popped.			#
	# 'treatop' has to distinguish built-in from user defined	#
	# operators; the latter are operands of the operator 'o_opcall'.#
	# Before transferring such an operator to 'make_tuple', its	#
	# internal name and its number of arguments are pushed on the	#
	# operand stack.						#


proc emptystack()
if errcnt = 0
then(	var oldop, osp := opstack.size;

	while osp > 0
	do	oldop := opop(); osp := osp - 1;
		if oldop[O_NAME] = lpar
		then	 return
		elif oldop[O_STATUS] = 0
		then	make_tuple(oldop[O_NAME], oldop[O_ADIC])
		else	var a := oldop[O_ADIC];

			ndpush('o' || oldop[O_NAME]);
			ndpush(qn || string(a));
			make_tuple(o_opcall, a+2)
		fi
	od
    )
fi;
	# Resembles 'treatop', but pops operators until either the	#
	# stack is empty or a left parenthesis (which is also popped)	#
	# is found.							#




#******************* Symbol table routines *****************************#




proc symentry(name, lev, typ, val)
(	var oldentry;

	oldentry := symtab[name];
	if   oldentry = undefined
	  | oldentry[S_LEVEL] ~= lev
	  | oldentry[S_TYPE] = 'forward' &
		 if typ = 'C'
		 then	ermsg('illegal forward reference(s) to constant "' ||
				name || '" ; first in line ' ||
				oldentry[S_VALUE], lnr
			     )
		 fi
	    & oldentry := undefined
	then	symtab[name] := [typ, lev, oldentry, val];
		return(1)
	else	ermsg('"' || name || '" redeclared', lnr);
		return(0)
	fi
);
	# Enters 'name' in symtab with value 'entry'. If an entry with	#
	# the same level already exists which is not a forward declara-	#
	# tion, a 'redeclared' error is issued. See also 'level' and	#
	# 'symtab'. 							#

proc fieldentry(name, fdes)
(	var s := symtab[name],
	    f := fieldtab[name];

	if s ~= undefined
	then	if s[S_TYPE] = 'forward'
		then	symtab[name] := undefined
		else	while s[S_NEXT] ~= undefined
			do	if s[S_NEXT][S_TYPE] = 'forward'
				then	s[S_NEXT] := undefined
				else	s := s[S_NEXT]
				fi
			od;
			s := symtab[name]
		fi
	fi;
	if f ~= undefined & f[F_CLNAME] = clname
	then	if inhertab[name] ~= undefined
		then	redeffld(name, fdes);
			inhertab[name] := undefined;
		else	ermsg('"' || name || '" redeclared', lnr)
		fi;
		return(0)
	else	fdes[F_NEXT] := f;
		fieldtab[name] := fdes;
		return(1)
	fi
);
	# Enters 'name' into 'fieldtab' with value 'fdes'. If a forward	#
	# declaration for this name is found in symtab it is removed.	#
	# See 'make_decls' and D..... New entries are entered in front	#
	# of existing ones. This is used whenever it has to be checked	#
	# whether a name is defined as a field in the current class; if	#
	# it is, its entry is at the front: the test			#
	# 'fieldtab[name] ~= undefined & fieldtab[name][0] = clname'	#
	# suffices.							#
	# This procedure essentially uses the fact that arrays are not	#
	# copied when assigned to a variable.				#
	# See also 'addglobf'.						#

proc redeffld(name, fdes)
(	var old := fieldtab[name];

	if old[F_TYPE] = VAR
	then	if fdes[F_TYPE] ~= VAR
		then	ermsg('inherited variable redefined as procedure', lnr)
		else	fdes[F_INTERN] := old[F_INTERN];
			offset := offset-1
		fi
	else	if fdes[F_TYPE] ~= PROC
		then	ermsg('inherited procedure redefined as variable', lnr)
		fi
	fi;
	fdes[F_NEXT] := old[F_NEXT];
	fieldtab[name] := fdes
);
	# redeffld is called when a field inherited from a superclass is #
	# redefined in the subclass. The old entry is removed. Allowing  #
	# variables to be redefined as procedures and vice versa requires#
	# the following additions: if x was a var and becomes a proc, it #
	# must be removed from data_flds and added to proc_flds. All     #
	# offsets of data-fields > offset(x) must be decremented.     	 #
	# In the reverse case, x must be transferred from proc_flds to	 #
	# data_flds.							 #

proc addglobf(name)
(	var entry := fieldtab[name],
	    new   := ['~global', PROC, name, name, NIL, undefined];

	if entry = undefined
	then	entry := new
	else	while entry[F_NEXT] ~= undefined
		do entry := entry[F_NEXT] od;
		entry[F_NEXT] := new
	fi
);
	# 'addglobf' makes an additional entry with class name '~global'#
	# for user defined operators which are declared both globally	#
	# and within a class. The entry is added at the end of the list,#
	# this is required by the interpreter. As all other fieldentries#
	# are added at the front, it is guaranteed to remain the last.	#


proc locate_fld(fld, cl)
(	var e := fieldtab[fld];

	while e ~= undefined
	do if e[F_CLNAME] = cl then return(e) else e := e[F_NEXT] fi od;
	comermsg('in locate_fld: fld ' || fld || ', class: ' || cl)
);
	# locate_fld finds the fieldtable entry created for field 'fld' #
	# in class 'cl'.						#


proc remove(names)
	scan names
	for	var s;
		while s := break(sc) & lit(sc) & symtab[s] := symtab[s][S_NEXT]
		do od
	rof;
	# 'undefine' resets the symbol table entries for the names in	#
	# its argument to their previous values. The names declared at	#
	# each level are explicitly remembered and passed as an argu-	#
	# ment instead of simply resetting all entries on the current	#
	# level, as this would require constructing the set of keys and	#
	# scanning the complete symbol table on each block exit; both	#
	# are expensive operations.					#



proc checktype(ident)
(	var entry := symtab[ident],
	    scope, typ;

	if entry = undefined
	then	if fieldtab[ident] = undefined
		then	symentry(ident, 0, 'forward', lnr)
		fi;
		return('w' || ident)
	else	return( case typ := entry[S_TYPE][0] of
			'l':	typ || string(entry[S_VALUE]),
			'c': 'g' : 'a':
				typ || ident,
			'f':	'w' || ident,
			'C':	string(entry[S_VALUE])
			esac
		      )
	fi
);
	# identifies identifiers, returning the operand form required	#
	# by the im-file. (See D......). If the identifier is entered	#
	# neither in 'symtab' nor in 'fieldtab', it is put in 'symtab'	#
	# with type indication 'forward' followed by the current line	#
	# number. If the same identifier is encountered later on without#
	# intermediate declaration, its entry in symtab matches lit('f')#





#********** Procedures associated with the treatment of classes *********#




proc putopassoc(opname)
(	var mon := opname || '.1',
	    dy  := opname || '.2',
	    monentry := fieldtab[mon],
	    dyentry  := fieldtab[dy],
	    undef := 0;

	if monentry = undefined | monentry[F_CLNAME] ~= clname
	then	undef := undef+1
	else	fieldtab[mon][F_FETCH] := fieldtab[mon][F_INTERN]
	fi;
	if dyentry = undefined | dyentry[F_CLNAME] ~= clname
	then	undef := undef+1
	else	fieldtab[dy][F_FETCH] := fieldtab[dy][F_INTERN]
	fi;
	if undef = 2
	then	ermsg('field "' || opname || '" undefined', lnr)
	fi
);
	# Puts fetch associations for an operator field in 'fieldtab'.	#
	# When, say, a declaration 'fetch @' is encountered, an entry	#
	# in 'fetchtab' is made with key '@' and value '_s'. A monadic	#
	# (dyadic) operator '@' declared within that class is entered	#
	# in 'fieldtab' with key '@.1' ('@.2'). 'Putopassoc' checks	#
	# whether the fetch association is indeed '_s' (the only one	#
	# allowed) and whether at least one version of @ is defined 	#
	# within the class, and adds the fetch association(s).	 	#

proc putassocs(type)
(	var field, fstab, ind, assoc;

	if type = fetch_type
	then	fstab := fetchtab; ind := F_FETCH
	else	fstab := storetab; ind := F_STORE
	fi;
	for field in fstab.index
	do assoc := fstab[field];
	   if assoc ~= '_s'
	   then	if fieldtab[assoc] = undefined |
	           fieldtab[assoc][F_CLNAME] ~= clname
	        then	ermsg('fetch/store association "'
			      || assoc || '" undeclared', lnr)
		elif fieldtab[assoc][F_TYPE] ~= PROC
		then	ermsg('fetch/store association "'
			      || assoc || '" is not a procedure', lnr)
		fi
	   fi;
	   if montab[field] ~= undefined | dytab[field] ~= undefined
	   then if type = fetch_type & assoc = '_s'
		then putopassoc(field)
		else ermsg('illegal ' || type ||
			   ' association for "' || field || '"', lnr)
		fi
	   else	var entry;

		entry := fieldtab[field];
		if entry = undefined | entry[F_CLNAME] ~= clname
		then ermsg('field "' || field || '" undeclared', lnr)
		elif entry[F_TYPE] = PROC
		then if type = fetch_type & assoc = '_s'
		     then fieldtab[field][F_FETCH] := entry[F_INTERN]
		     else ermsg('illegal ' || type ||
				' association for "' || field || '"', lnr)
		     fi
		else	fieldtab[field][ind] :=
			  if assoc = '_s'
			  then SIMPLE else fieldtab[assoc][F_INTERN]
			  fi
		fi
	   fi
	od
);
	# Sets fetch or store associations for fields of the current	#
	# class, using the entries from 'fetchtab' or 'storetab'	#
	# (depending on the value of 'type').				#
	# 'putassocs' has to distinguish between operators, procedures	#
	# and data fields. For operators 'putopassoc' is called.	#
	# Procedures cannot have a store association. The only value	#
	# allowed for the fetch association in 'fetchtab' is '_s', but	#
	# the entry in 'fieldtab' will be the name of the procedure with#
	# the class suffix appended. Data fields can have both a fetch	#
	# and a store association; both can have value '~simple' or an	#
	# name of an associated procedure. 'putassocs' also check	#
	# whether all fields mentioned in 'fetch' and 'store' declara-	#
	# tions are indeed declared in the current class.		#
	# 'putopassoc' is called), procedures (which cannot have a store#
	# association and for which the only fetch association allowed	#


proc do_subclass(super)
(	var cl_super;

	if (cl_super := classtab[super]) = undefined
	then ermsg('"' || super || '" not (yet) defined as class', lnr)
	else var fldlist, fld, sub_entry, super_entry;

	     fldlist := cl_super[1];		# parameters #
	     if scan par_flds for lit(fldlist) rof fails
	     then ermsg('parameters of "' || clname ||
			'" should include those of "' || super || '"', lnr)
	     else fldlist := scan_string(fldlist);
		  while scan fldlist for fld := break(sc) & lit(sc) rof
		  do sub_entry := fieldtab[fld];
		     super_entry := locate_fld(fld, super);
		     sub_entry[F_FETCH] := super_entry[F_FETCH];
		     sub_entry[F_STORE] := super_entry[F_STORE];
		  od
	     fi;
	     fldlist := scan_string(cl_super[2]);	# data fields #
	     while scan fldlist for fld := break(sc) & lit(sc) rof
	     do super_entry := locate_fld(fld, super);
	        fieldentry(fld,
				[clname, VAR, offset := offset + 1,
				 super_entry[F_FETCH], super_entry[F_STORE],
				 undefined]
			  );
		data_flds := data_flds || fld || sc;
		symentry(fld, level, 'c', '');
		inhertab[fld] := 1;
	     od;
	     fldlist := scan_string(cl_super[3]);	# procedures #
	     while scan fldlist for fld := break(sc) & lit(sc) rof
	     do super_entry := locate_fld(fld, super);
	        fieldentry(fld,
				[clname, PROC, super_entry[F_INTERN],
				 super_entry[F_FETCH], NIL, undefined]
			  );
		proc_flds := proc_flds || fld || sc;
		symentry(fld, level, 'c', '');
		inhertab[fld] := 1;
	     od;
	     fldlist := scan_string(cl_super[4]);	# operators #
	     while scan fldlist for fld := break(sc) & lit(sc) rof
	     do super_entry := locate_fld(fld, super);
	        fieldentry(fld,
				[clname, PROC, super_entry[F_INTERN],
				 super_entry[F_FETCH], NIL, undefined]
	           	  );
	        op_flds := op_flds || fld || sc;
		inhertab[fld] := 1
	     od
	fi
);
	# All fieldtable entries of the superclass are copied. Parameters #
	# have been entered already; only the fetch and store associations#
	# are changed. They may not be redefined. For all other fields a  # 
	# new entry is created; and they are entered in inhertab to       #
	# denote that they may be redefined.				  #
	# Offsets: if A(a) with datafields x and y is the superclass of	  #
	# B(a,b,c) then after 'do_subclass' B has five datafields:	  #
	# 'a' (offset 0), 'b' (1), 'c' (2), 'x' (3) and 'y' (4).	  #



#****************** Miscellaneous procedures *****************************#



proc comermsg(m)
(	put(string(lnr).right(5, ' '), ': compiler error; ', m, newl);
	stop(-1)
);

proc ermsg(message, lnr)
(	if errors_on_tab[src_name] = undefined
	then	f_er.put(newl, 'errors in ', src_name, ':', newl);
		errors_on_tab[src_name] := 1
	fi;
	f_er.put(string(lnr).right(5, ' ') , ': ', message, newl);
	errcnt := errcnt + 1;
);

proc cant(name)
(	put('Cannot open ', name, '\n');
	stop(1);
);

proc nextglob() return('_' || string(glcnt := glcnt + 1));
	# returns a new global name invented by the parser. The syntax	#
	# is not that of a summer identifier or operator name, so it is #
	# guranteed to be unique. Used by 'caseclause' and by 'forloop'.#

proc nextclab() return('C' || string(clab := clab + 1));


proc lineinc()
(	ndpush('i' || string(lnr - lastlnr));
	lastlnr := lnr
);
	# line increment since last line instruction.			#


proc enlarge(arr,step,size)
(	var newarr := array(size + step, undefined),
	    i;

        for i in arr.index do newarr[i] := arr[i] od;
	return(newarr)
);


proc proc_op_init()
(	lastlnr := lnr;
	retcnt := undefined;
	imlab := 0;
	inproc := 1;
	level := level+1
);

proc proc_op_exit(intname, nf, fnms, stlnr)
(	if retcnt = undefined then retcnt := 0 fi;
	if errcnt = 0
	then	f_im.put(prochead,
			 retcnt, tabsym, intname, sc,
			 convlocs(), sc, nf, sc, loccnt-nf, sc,
			 stlnr, sc, lnr, tabsym, ndpop(), sc, newl
			)
	fi;
	inproc := 0;
	remove(fnms);
	level := level-1
);
	# These two procedures are called by procedure and operator	#
	# declarations.							#



proc convlocs()
	if loclist = ''
	then	return('nil')
	else	loclist := quote || loclist || quote;
		return(scan loclist for convstr(loclist.size ) rof)
	fi;
	# Constructs the string representation for the list of local	#
	# names (separated by comma's). The string label returned will	#
	# be part of a procedure heading.				#


proc make_decls()
(	var dcl, nm, bl := ' ', e;

	if ~(dcl := file(pname || '.dc','w'))
	then	ermsg('cannot open "' || pname || '.dc"', lnr);
		stop(1)
	fi;
	dcl.put('glcnt:\t', glcnt, newl);
	for nm in montab.index
	do	if (e := montab[nm][O_STATUS]) < 0
		then	ermsg('undeclared monadic operator "' || nm || '"', -e)
		fi
	od;
	for nm in dytab.index
	do	if (e := dytab[nm][O_STATUS]) < 0
		then	ermsg('undeclared dyadic operator "' || nm || '"', -e)
		fi
	od;
	for nm in symtab.index
	do	var x := symtab[nm];

		if x[S_TYPE] = 'forward'
		then	ermsg('"' || nm || '" undeclared', x[S_VALUE])
		elif errcnt = 0
		then	dcl.put(nm, coltab, x[S_TYPE], x[S_VALUE], newl)
		fi
	od;
	if errcnt ~= 0 then return fi;
	dcl.put('endsyms', newl, 'classes', newl);
	for nm in classtab.index
	do	dcl.put(nm, sc, classtab[nm][0], newl) od;
	dcl.put('endclasses', newl, 'fields', newl, '');
	for nm in fieldtab.index
	do	var x := fieldtab[nm];

		dcl.put('fld\t', nm, newl);
		while x ~= undefined
		do	dcl.put(x[F_CLNAME], sc, x[F_TYPE], sc,
				 x[F_INTERN], sc, x[F_FETCH], sc, x[F_STORE],
				 newl
			   );
			x := x[F_NEXT]
		od;
	od;
	for nm in stdops.index
	do	if fieldtab[nm] = undefined
		then	dcl.put('fld\t', nm, newl);
		fi
	od;
	dcl.put('endfields', newl);
	dcl.close 
);
	# This procedure is called after completion of the parse of	#
	# the source program. It has two tasks: contsructing the dc-file#
	# and detecting undeclared identifiers.				#
	# 'make-decl' performs (in that order) the following actions:	#
	# - It puts the number of globals invented by the parser on the	#
	#   dc-file.							#
	# - It scans 'montab' and 'dytab' to detect undefined operators,#
	#   i.e. operator names which occurred in 'monadic' and 'dyadic'#
	#   declarations without subsequent definition. They are	#
	#   recognized by a negative declaration status indicator, which#
	#   contains the source line number of the offensive declaration#
	# - It scans the symbol table, issuing error messages for any	#
	#   'forward' declarations that still remain, and writing	#
	#   identifier-type pairs to the dc-file.			#
	# - It scans the class table, writing class-size pairs to the	#
	#   dc-file.							#
	# - It scans the field table. Each entry in the list of entries	#
	#   for a certain field is put on a separate line.		#
