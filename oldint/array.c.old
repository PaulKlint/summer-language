#
/*
 * SUMMER -- array
 */

#include "summer.h"

/*
 * Class creation is handled by the IC_ARINIT instruction.
 * See eval.c
 */


SUBR DATATYPE F_Aupdate(){
	register int n;
	register ARRAY a;

	ARGCNT(3);
	ARGTYPE(0,DT_ARRAY);
	ARGTYPE(1,DT_INTEGER);
	n = INTVAL(ARG1);
	a = T_ARRAY(ARG0);
	if((n < 0) || (n >= a->ar_size))
		error("array bounds exceeded");
#ifdef ATSTATS
	putstring("U:A:");put1(findname(a));
	putstring(":"); printint(a); putstring(":"); printint(n); putstring("\n");
#endif
	if((curcache != NIL) && INRECFLOAT(ARG0)){
		register SUMDP *p1;
		register SUMDP *p2;

		p1 = CAST(SUMDP *) T_DATATYPE(ARG0);
		p2 = &a->ar_elements[n];
		save_in_cache(ARG0, p2 - p1);
	}
	a->ar_elements[n] = ARG2;
	return(T_DATATYPE(ARG2));
}

SUBR DATATYPE F_Aretrieve(){
	register int n;
	register ARRAY a;

	ARGCNT(2);
	ARGTYPE(0,DT_ARRAY);
	ARGTYPE(1,DT_INTEGER);
	n = INTVAL(ARG1);
	a = T_ARRAY(ARG0);

	if((n < 0) || (n >= a->ar_size))
		error("array bounds exceeded");
#ifdef ATSTATS
	putstring("R:A:"); put1(findname(a));
        putstring(":"); printint(a); putstring(":"); printint(n); putstring("\n");
#endif
	return(T_DATATYPE(a->ar_elements[n]));
}
SUBR ARRAY F_Aindex(){
	register int n;
	extern CLASS _interval();
	ARGCNT(1);
	ARGTYPE(0,DT_ARRAY);
	n = T_ARRAY(ARG0)->ar_size - 1;
	T_INTEGER(ARG0) = newinteger(n);	/* use ARG0 as safe loc */
	return(CAST(ARRAY) call(4, _interval, undefined, ZERO, ARG0, ONE));
}

SUBR ARRAY F_Anext(){
	int n;

	ARGTYPE(0,DT_ARRAY);
	if(DT(ARG1) == DT_UNDEFINED)
		n = 0;
	else {
		ARGTYPE(1,DT_INTEGER);
		n = INTVAL(ARG1);
	}
	if(n < T_ARRAY(ARG0)->ar_size){
		ar2->ar_elements[0] = T_ARRAY(ARG0)->ar_elements[n];
		T_INTEGER(ARG0) = newinteger(n + 1);	/* use ARG0 as safe loc */
		ar2->ar_elements[1] = ARG0;
		return(ar2);
	} else
		FAIL;
}

SUBR INTEGER F_Asize(){
	ARGCNT(1);
	ARGTYPE(0,DT_ARRAY);
	return(newinteger(T_ARRAY(ARG0)->ar_size));
}

ARRAY F_Asort(){
	extern ARRAY _sort();

	return(_sort());
}
struct subr Aindex, Anext, Aretrieve, Asize, Asort, Aupdate;

array_init(){
	extern struct fld f_index, f_next, f_retrieve, f_size, f_sort, f_update;

	DCLSUBR(Aindex,F_Aindex,&f_index,cvt_array);
	DCLSUBR(Anext,F_Anext,&f_next,cvt_array);
	DCLSUBR(Aretrieve,F_Aretrieve,&f_retrieve,cvt_datatype);
	DCLSUBR(Asize,F_Asize,&f_size,cvt_integer);
	DCLSUBR(Asort,F_Asort,&f_sort,cvt_array);
	DCLSUBR(Aupdate,F_Aupdate,&f_update,cvt_datatype);

}
