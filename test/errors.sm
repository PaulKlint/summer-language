proc prec(n) prec(n+1);

proc pnoval () return;

proc pfail () return(1 > 2);

class a_class()
begin fetch f1, f2; store s1, s2;
      var f1, f2, s1, s2;
end a_class;

program errors(arg)
( var k := 3, s, abc := 'abc', a := [1, 2, 3],
      t := ['ab' : 1, 'ac': 2], b := bits(3, 0), x, y, z;

  case arg[0] of

  'arith1': k + abc,
  'arith2': abc + k,
  'arith3': k % 3.5,
  'arith4': k % 0,
  'arith5': k / 0,
  'arith6': k / 0.0,
  'array1': a[-1],
  'array2': a[5],
  'array3':	x := array('abc', 0),
  'array4':	a['abc'],
  'bits1':	x := bits(-1, 0),
  'bits2':	x := bits(1, 3),
  'bits3':	b['abc'],
  'bits4':	bits(3, 0)[4],
  'bits5':	bits(3, 0)[0] := 4,
  'table1':	x := table(-3, 0),
  'table2':	x := table('abc', 0),
  'integer1':	x := integer('abc'),
  'integer2':	x := integer('999999999999999999999999999'),
  'string1':	x := string([1, 2, 3]),
  'real1':	x := real([1, 2]),
  'stack1':	prec(0),
  'mulas1':	[x, y, z] := 'abc',
  'mulas2':	[x, y, z] := [1, 2],
  'conc1':	abc || 3,
  'conc2':	3 || abc,
  'rel1':	[1, 2] > 3,
  'rel2':	abc = 3,
  'fail1':	1 > 2,
  'fail2':	x := scan_string('abc') & x.lit('3'),
  'fail3':	pfail,
  'subject1':	x := subject,
  'subject2':   lit('abc'),
  'subject3':	cursor,
#  'call1':	2(3),#
  'call2':	x := pnoval,
  'assert1':	assert 2 > 3,
  'field1':	abc.span,
  'field2':	abc.span := 3,
  'fetch':	(s := a_class; x := s.s1),
  'store':	(s := a_class; s.f1 := 3)
  esac
)
