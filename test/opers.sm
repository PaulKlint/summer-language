#	operator definitions and applications	#

proc error(n) put('ERROR: ', n, '\n');

monadic >>, !;

dyadic !, @, _in_, >>;

op $ (a,b) return((a+b)*(a-b));

proc callops()
(	var a1 := [1, 2, 3, 4, 5],
	    a2 := [6, 7, 8, 9, 10];

	var x := 4, y := ops(5), z := ops2(6);

	if (x + x) ~= 8 then error(1) fi;
	if (y + x) ~= 1 then error(2) fi;
	if (z + x) ~= 24 then error(3) fi;
	if (x $ x) ~= 0 then error(4) fi;
	if (y $ x) ~= 81 then error(5) fi;
	if (z $ x) ~= 4 then error(6) fi;
	if (y ! x) ~= 1 then error(7) fi;
	if (z ! x) ~= 100 then error(8) fi;
	if (x @ x) ~= -48 then error(9) fi;
	if >>a1 & >>a2 & a1>>a2 succeeds
	then	# do nothing #
	else	error(10)
	fi;
	if !3 _in_ [!2, !6]
	then	# do nothing #
	else	error(10)
	fi
);


op >> (a)
	if a[a.size -1] > a[0] then return else freturn fi;

op >> (a,b)
(	if >>a & >>b then return else freturn fi);

op _in_ (a, intv)
(	if a > intv[0] & a < intv[1]
	then	return
	else	freturn
	fi
);

op ! (n)
if n = 0 then return(1) else return(n * !(n-1)) fi;


class ops(int)
begin	fetch +, $, !;

	op + (a) return(int - a);

	op $ (a) return((int + a) * (int + a));

	op ! (a) return((int - a) * (int - a));
end ops;


op @ (a,b) return((a*a - 4*a*b));

class ops2(int)
begin	fetch +, $, !;

	op + (a) return(int * a);

	op $ (a) return((int-a)*(int-a));

	op ! (a) return((int+a)*(int+a));
end ops2;

program opers()
	callops();
