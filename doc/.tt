
.	\" definitions for font switching:
.	\" syntactic notions:
.	\" 	in text:	\*< and \*>
.	\" 	in display:	.<< and .>>
.	\" (parts of) programs
.	\"	in text:	 \fIand\fR 
.	\"	in display	.{{ and .}}
.	\" quoted text:		\*` and \*'
.	\"
.ds < \\s-2<\\s0
.ds > \\s-2>\\s0
.de <<
.in +\\n(PIu
.ft R
.ne 4
.ta 12n 24n 36n 48n
.nf
.na
.{{
..
.de >>
.fi
.ad
.in -\\n(PIu
.}}
..
.ds { \\fI
.ds } \\fP
.de {{
.	\".nr PS -1p
.	\".nr VS -1p
.	\".ps \\n(PSp
.	\".vs \\n(VSp
..
.de }}
.	\".nr PS +1p
.	\".nr VS +1p
.	\".ps \\n(PSp
.	\".vs \\n(VSp
..
.de D{
.LP
.nf
.na
.in +\\n(PIu
.ne 6
.{{
..
.de D}
.in -\\n(PIu
.}}
.fi
.ad
..
.de E{
.na
.nf
.sp -1v
..
.de E}
.fi
.ad
..
.de XP
.sp \\$1
..
.ds ` \(fm
.ds ' \(fm
.	\" miscellaneous characters:
.	\" sc : sequence concatenation
.	\" an : logical and
.	\" el : element of
.ds sc \z\(ci\(pl
.	\" logical and
.ds an &
.	\" element of
.ds el \\s-2\(mo\\s0
.	\" prototype arithmetical op
.ds o1 \z\(ci\(pl
.	\" prototype relational op
.ds o2 \z\(ci\h'0.1m'=
.ds MK "\ \ \s-2\(sq\s0
.	\" ix -- put item in index.
.	\" $1=index name
.	\" $2=item name
.	\" $3=optional layout symbol
.	\" 
.	\" typical usage: .ix C item ,
.	\" which puts "item" in index C, and adds "item," to the text stream.
.de ix
.tm .In \\$1 "\\$2" \\n%
\\$2\\$3
..
.	\" iy -- put item in index, but do not print it
.de iy
.tm .In \\$1 "\\$2" \\n%
..
.rn SH @S
.de SH
.if !'\\$3'-' .ds RH "\\$1  \\$2
.br
.ne 5
.@S
\\fB\\$1  \\$2\\fP
.iy C "\\$1 \\$2"
..
.	\" Redefined "ms" page-title macro
.	\" @C= 0	previous chapter has ended
.	\" @C= 1	at page 1 of new chapter
.	\" @C= 2	at page >1 of new chapter
.	\" @C= 3	at last page of new chapter
.de PT
.lt \\n(LLu
.pc %
.if \\n(@C=2 .if \\n% .if e .tl '%'\\*(LH''
.if \\n(@C=2 .if \\n% .if o .tl ''\\*(RH'%'  
.lt \\n(.lu
..
.de BT
.lt \\n(LLu
.pc %
.if \\n(@C=3 \{\
.nr @C 0 \}
.if \\n(@C=1 \{\
.nr @C 2 \}
.lt \\n(.lu
..
.nr @C 0
.de NC
.ps +20
.sp 0.5i
.ce 1
\\fB\\$1
.sp 0.5i
.ps -12
.ce 1
\\$2
.sp 0.5i
.ce 1
\\$3\\fP
.sp 0.5i
.ps -8
.iy C  "\\$1 \\$2 \\$3"
.nr @C 1
..
.de EC
.rm LH
.rm RH
.nr @C 3
.bp
..
.rm CH
.	\" NOte macro for refman2.ms
.de NO
.br
.ne 5
.LP
\\fBNotes\\fP
..
.	\" macros for SUMMER library
.de PC 
.br
.ne 6
.sp 0.5
.IP Proc: 10
\\fI\\$2\\$3\\fP
.iy I \\$2
.IP Action: 10
..
.de EX
.br
.ne 5
.IP "Examples:" 10
.ta 6c 6c 6c 6c
..
.de NT
.br
.ne 4
.IP "Notes:" 10
..
.de OP
.br
.ne 6
.sp 1
.IP "Operator:" 10
\\$2\\fI\\$3\\fP
.iy I \\$2
.IP Action: 10
..
.de OB
.br
.ne 8
.sp 1
.IP "Operator:" 10
\\$2\\h'2m-\\w'\\$2'u'\\fI\\$3\\fP
.iy I \\$2
.br
..
.de OM
\\$2\\h'2m-\\w'\\$2'u'\\fI\\$3\\fP
.iy I \\$2
.br
..
.de OE
\\$2\\h'2m-\\w'\\$2'u'\\fI\\$3\\fP
.iy I \\$2
.IP Action: 10
..
.de NX
..
.ds _ \h'-0.2m'\v'0.4m'\(mi\v'-0.4m'\h'-0.2m'
.ds # \s-2#\s0
.	\" initialize eqn
.	\" (redefine $ as DL to avoid clashes
.ds DL \\\$
.EQ
.nr 99 \n(.s
.nr 98 \n(.f
.ps 10
.ft 2
.ps 9
.ps \n(99
.ft \n(98
.EN




.DS C
.sp 2
.ft B
\s+7A Study in\s-7
.sp 3
\s+7String Processing Languages\s-7
.sp 7
.ft R
\s+3\fBPaul Klint\fP\s-3
.sp 2
.ft R
Centre for Mathematics and Computer Science
Amsterdam
The Netherlands
.DE
.bp
.NC " " "PREFACE" " "
.ds LH PREFACE
.ds RH PREFACE
.PP
Written text is an essential element in our culture and
various technical means have been invented to aid in its production.
Paper and pencil, the typewriter and the typesetter are examples
of such inventions.
.PP
Continuing this same line of development, computers are nowadays
being used to alleviate the writing task.
Computerized text processing systems
(ranging from word processors for writing and editing simple texts to
fully automated newspaper and book printing systems)
are rapidly penetrating
into all areas of human activity where written text is the primary
means of communication.
.PP
Historically, the impetus behind the development of computers
has always been primarily numerical in nature.
This is reflected in the design of most computers and programming languages.
However, the increasing use of computers for text processing and
other non-numeric tasks makes the purely arithmetic design obsolete.
.PP
This monograph concentrates on the programming language aspects of
computerized text handling
and, to be more precise, on the design and implementation of
\fBstring processing languages\fP.
The term `string processing' refers to the process of inspecting, modifying
and transforming texts, i.e. sequences of symbols.
It comprises such seemingly disparate activities as text editing,
transforming a text with embedded formatting directives into
a final layout, and compiling a source program into a string
of machine instructions.
.PP
An account is given
of attempts to solve some of the problems in string processing languages.
First of all, an exercise
in designing an application oriented programming language is described.
This has resulted in the language \s-2SUMMER\s0.
Next, an exercise in the
formal definition of the semantics of programming languages is described.
The formal definition and implementation of \s-2SUMMER\s0
together constitute the final result of the project.
.PP
This monograph consists of two parts.
Part I is devoted to string processing languages in general and consists of chapters
1 through 5.
Part II is devoted to the definition of \s-2SUMMER\s0 and
consists of chapters 6 through 10.
The contents of the monograph are now briefly summarized.
.PP
Chapter 1 is introductory and gives the necessary
motivation and background for the study of string processing languages.
.PP
Chapter 2 is devoted to general design considerations
for string processing languages and compares
the semantics of various pattern matching models.
Attention is paid to different forms of side-effects during a pattern match.
This is done by giving an operational, formal definition of the semantics
of the various models.
As a result of this, a new pattern matching model based on side-effect recovery
is developed.
.PP
Chapter 3 gives an overview of the language \s-2SUMMER\s0.
S\s-2UMMER\s0 may be characterized as a \fBsmall\fP
language, i.e. it consists of a relatively small set of primitive operations
together with a modest extension mechanism.
.PP
Chapter 4 concentrates on the problem of finding a
method for formal language definition that is suitable for the designers
as well as the implementors and users of a language.
An improved method for the operational definition of programming language
semantics is developed and the result of applying this method to
S\s-2UMMER\s0 is illustrated.
.PP
Chapter 5 concludes the first part of this monograph
with an evaluation of the research described in it and
suggestions for further research.
.PP
Part II is devoted to the
definition of the \s-2SUMMER\s0 programming language.
It provides both a formal and informal language definition
and tutorial examples.
.PP
In Chapter 6 the techniques and notational conventions that
are used in the definition are introduced.
Much attention is paid to the method used for the formal definition of
the semantics of \s-2SUMMER\s0.
.PP
Chapter 7 contains a semi-formal definition of the \s-2SUMMER\s0 kernel.
This is a small subset of the language on which a semantic
definition of the whole language can be based.
The description of each language feature consists of
its syntax, an informal as well as a formal definition of its semantics, and examples.
.PP
In Chapter 8 the kernel is extended with
useful data types and associated operations,
such as reals, arrays, tables, files, bit strings, etc.
Some complete, annotated \s-2SUMMER\s0 programs are presented in Chapter 9.
Finally, a summary of the syntax is given in Chapter 10.
.PP
Readers who are only interested in getting
a general impression of the language \s-2SUMMER\s0 may confine themselves to
Chapter 3 and the
annotated examples in Chapter 9.
Readers who are not interested in the formal definition of the language
may skip Chapter 6 (except Sections 6.1 and 6.2),
and all subsections of
Chapter 7 entitled `Semantics'.
.PP
This monograph is a revision of the author's dissertation
as presented at the Technical University Eindhoven, The Netherlands.
It was supervised by Prof. dr. F.E.J. Kruseman Aretz
(Technical University Eindhoven, The Netherlands) and
Prof. H. Whitfield, b.s., d.i.c.
(University of Newcastle upon Tyne, Great Britain).
The research was conducted while the
author was employed at the Mathematical Centre, Amsterdam, The Netherlands.
.PP
Several people contributed to this effort.
Design and implementation of \s-2SUMMER\s0
(as well as of its predecessor \s-2SPRING\s0)
were done in close cooperation with Marleen Sint.
Contributions to the design of \s-2SUMMER\s0 were made by Jan Heering.
Their enthusiasm, patience and friendship were essential to the success
of this project.
.PP
Jan Heering, Marleen Sint and Arthur Veen have read drafts of this monograph.
They pointed out various errors
and made numerous suggestions for improving the style and presentation
of it.
I am grateful for their support and criticism.
Comments made by
Leo Geurts,
R.J. Lunbeck,
Lambert Meertens and
W.L. van der Poel
are gratefully acknowledged.
.EC
.bp 1
.DS C
.sp 12
.ft B
\s+8PART I
.sp 8
String Processing Languages\s-8
.ft R
.DE
.bp
.bp
.hy

.NC 1 "INTRODUCTION" " "
.ds LH INTRODUCTION
.SH 1.1. "Subject of this monograph"
.PP
Written text is an essential element in our culture and
various technical means have been invented to aid in its production.
Paper and pencil, the typewriter and the typesetter are examples
of such inventions.
.PP
Continuing this same line of development, computers are nowadays
being used to alleviate the writing task.
Computerized text processing systems
(ranging from word processors for writing and editing simple texts to
fully automated newspaper and book printing systems)
are rapidly penetrating
into all areas of human activity where written text is the primary
means of communication.
.PP
Historically, the impetus behind the development of computers
has always been primarily numerical in nature.
This is reflected in the design of most computers and programming languages.
However, the increasing use of computers for text processing and for
other non-numeric tasks makes the purely arithmetic design obsolete.
.PP
This monograph concentrates on the programming language aspects of
computerized text handling
and, to be more precise, on the design and implementation of
\fBstring processing languages\fP.
The term `string processing' refers to the process of inspecting, modifying
and transforming texts, i.e. sequences of symbols.
It comprises such seemingly disparate activities as text editing,
transforming a text with embedded formatting directives into
a final layout, and compiling a source program into a string
of machine instructions.
.PP
In motivating the study of string processing languages
we shall first consider three typical applications
for which a string processing language would be a prime choice
as implementation language.
At the same time, we shall try to fit the problems and language requirements
that are typical for string processing applications into a general scheme.
It is not our intention to contend that the solutions proposed and
the techniques used are the only ways to solve these problems.
There are indeed many programs that solve them without relying
on higher level concepts in their implementation language.
In such programs the method of procedural extension is used to realize
higher level concepts.
What we do contend, however, is that the concepts proposed here follow
in a natural way from the various applications.
.PP
\fBTypical application 1\fP:
count the frequency of occurrence of all
words in a text and print an alphabetically sorted list of the results.
This is a prototype of many simple editing
and text processing problems.
A program to perform this task will presumably consist of the modules:
\fBRead word\fP, \fBTally\fP and \fBSort and Print\fP.
.PP
\fBRead word\fP
isolates the next `word' from the input and fails if no more words are available.
This requires a simple lexical recognition capability to distinguish
letters, digits and punctuation marks.
\fBTally\fP compares the word just read with the words in a table
containing all previously read words.
If the word occurred before, its frequency is incremented in the table,
otherwise a new table entry is created with frequency set to one.
This requires table lookup and automatic storage allocation.
Note that neither the maximum length of a word nor the maximum number
of different words is known in advance.
\fBSort and Print\fP
sorts the table and prints it.
This requires a sorting facility and simple string synmonograph functions
to produce output in tabular form.
.PP
\fBTypical application 2\fP:
format a text containing embedded formatting directives.
A text formatting program might contain the modules:
\fBRead input\fP, \fBManage text streams\fP, \fBAdjust\fP an \fBHyphenate\fP.
.PP
\fBRead input\fP reads input text and
recognizes embedded formatting directives.
In a simple system, this requires recognition power at the lexical level.
More sophisticated systems might support input specifications for the
formatting of mathematical formulas, tables, block diagrams, etc.
In that case more complex patterns must be recognized in the input text.
\fBManage text streams\fP supervises the output stream.
Various areas in the `current' output page
(like headers, text columns and footnotes) are usually filled independently.
This is implemented most naturally by storing the information related to them
in separate data structures.
This requires data structures allowing their components to grow dynamically.
\fBAdjust\fP distributes the spaces embedded in a text line
so as to obtain right adjusted margins.
This can be done in several ways and it depends on the particular
implementation which language features are needed.
One implementation might, for example, represent a line
as a linked list of words with
each word containing a relative distance to the previous word.
If the amount of blank space in a line becomes too large, Adjust calls
\fBHyphenate\fP.
The latter subdivides words into syllables.
Hyphenation is used when a given word fits the current output line only partially.
This requires table lookup in tables with hyphenation prefixes and suffixes
or in tables containing words with exceptional hyphenation points.
.PP
\fBTypical application 3\fP:
compile a source program in some programming language
into machine code.
The modules
\fBLexical analyzer\fP, \fBSyntax analyzer\fP and \fBCode generator\fP
can be found in most traditional compilers.
.PP
A
\fBLexical analyzer\fP
reads the input stream character by character and constructs from these
characters the basic symbols (such as integers, identifiers and keywords)
of the programming language.
This requires lexical level recognition power.
The \fBSyntax analyzer\fP
performs the syntactic analysis of the stream of symbols
produced by the lexical analyzer.
For each type of context-free grammar there exists an associated recognizer and
the precise form and efficiency of such a recognizer depends on the kind of grammar.
Each recognition function should be able
to handle the case that its input string is \fBnot\fP
recognized, i.e. that the recognition fails.
The output of the syntax analyzer is the
parse tree that corresponds to the source program.
The construction of parse trees requires dynamically allocated data structures.
The \fBCode generator\fP transforms parse trees into executable machine code.
The requirements depend in this case
on the particular implementation method chosen.
.PP
Before embarking on yet another effort to design a programming language
it is worthwhile to answer the question as to how well existing languages satisfy
the typical requirements of string processing or, if they are inadequate in
this respect, in what way they can be extended so as to meet them in a more
satisfactory manner.
This is done in Section 1.3 below.
As a preparation for this the reader is first,
in Section 1.2,
familiarized with some basic notions
that are used frequently in subsequent chapters.
Problems in existing string processing languages
are illustrated in Section 1.4 by means of some \s-2SNOBOL\s04 programs.
Section 1.5 contains a list of questions that can serve as a basis
for the evaluation of string processing languages,
while at the same time suggesting the direction of future developments.
.PP
This monograph gives an
account of attempts to solve some of the problems in string processing languages.
It consists of two parts.
.PP
Part I is devoted to string processing languages in general.
Chapter 1 is introductory and gives the necessary
motivation and background for the study of string processing languages.
.PP
Chapter 2 is devoted to general design considerations
for string processing languages and compares
the semantics of various pattern matching models.
Attention is paid to different forms of side-effects during a pattern match.
This is done by giving an operational, formal definition of the semantics
of the various models.
As a result of this, a new pattern matching model, based on side-effect recovery,
is developed.
.PP
Chapter 3 gives an overview of the language \s-2SUMMER\s0
an attempt to design a string processing language.
S\s-2UMMER\s0 may be characterized as a \fBsmall\fP
language, i.e. it consists of a relatively small set of primitive operations
together with a modest extension mechanism.
.PP
Chapter 4 concentrates on the problem of finding a
method for formal language definition that is suitable for the designer
as well as the implementors and users of a language.
An improved method for the operational definition of programming language
semantics is developed and the result of applying this method to
S\s-2UMMER\s0 is illustrated.
.PP
Chapter 5 concludes the first part of this monograph
by evaluating the research described in it and by outlining several
areas for further research.
.PP
Part II contains a complete definition of the \s-2SUMMER\s0 programming language.
It consists of a definition of the language
(both formal and informal), gives examples
of the various language constructs and discusses some annotated programs.
.PP
In this monograph we are not concerned with the social implications
of text processing and office automation.
The interested reader is referred to the
literature for a discussion of this issue.
[Mowshowitz81] discusses the different approaches to the study
of social issues in computing.
[Weizenbaum76] analyzes the influence of technology
(and in particular computer science) on our society and
exposes (mis)conceptions among computer scientists regarding the tasks
that can ultimately be delegated to computers.
.SH 1.2. "Basic operations on strings"
.PP
Agreement is necessary on what we shall mean by \fBstrings\fP and \fBstring processing\fP
before a characterization of string processing languages is possible.
A \fBstring\fP is defined as a sequence of
\fBstring-items\fP (to be defined below), such that:
.IP \*(MK
The sequence is linearly ordered and of arbitrary (finite) size.
.IP \*(MK
Individual string-items in the sequence can be selected by means of indexing.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "For a sequence of length 
.ps 9
.ft 2
.ds 12 "N
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ", the items in the sequence have
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "indices 
.ps 9
.ft 2
.ds 12 "\f10\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 ",\ .\ .\ .\ ,\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "N\|\(mi\f11\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " respectively.
.ps \n(99
.ft \n(98
\*(11
.IP  \*(MK
An equality relation is defined on the set of string-items.
This relation extends in a natural way to the set of strings.
.LP
This definition is deliberately general and does not use any particular
property of string-items, apart from the assumption that an equality
relation is defined on the set of string-items.
It allows, for instance, strings of integers, strings of reals,
strings of strings of integers, and so on.
Most of the time, however, we shall
be dealing with strings consisting of \fBcharacters\fP,
i.e. entities corresponding to letters, digits and other symbols which can
be displayed on a printing device.
Unless otherwise stated,  all strings are assumed to consist of characters
and in the examples literal character strings will be enclosed in
single quotes (like \(fm\fI\h'-0.1m'metaphysics\fR\^\(fm).
.PP
\fBString processing\fP will be understood to encompass the totality of 
operations to synthesize and analyze (parse, recognize) strings.
.PP
The most primitive operations on strings are \fBconcatenation\fP and
\fBsubstring selection\fP.
A dyadic operator denoted by `||' will be used for string concatenation;
it `glues' two strings together.
For example,
.DS
\&\(fm\fI\h'-0.1m'meta\fR\^\(fm || \(fm\fI\h'-0.1m'physics\fR\^\(fm
.DE
has the new string \(fm\fI\h'-0.1m'metaphysics\fR\^\(fm as value.
.PP
Substring selection extracts a substring from a given string.
For example,
.DS
\fIsubstring\fR\^(\(fm\fI\h'-0.1m'metaphysics\fR\^\(fm, 7, 3)
.DE
produces the new string \(fm\fI\h'-0.1m'sic\fR\^\(fm by
extracting a substring of size 3 starting at position 7 from \(fm\fI\h'-0.1m'metaphysics\fR\^\(fm.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Remember that the characters in a string have indices 
.ps 9
.ft 2
.ds 12 "\f10\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f11\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 ",\ .\ .\ .\ ,\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "N\|\(mi\f11\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ",
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "where 
.ps 9
.ft 2
.ds 12 "N
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is the number of characters in the string.
.ps \n(99
.ft \n(98
\*(11
.PP
Less primitive recognition operations,
as can be found in \s-2SNOBOL\s04,
operate on a single common string (`the subject string')
starting at a certain index in that string
(`the cursor position').
These recognition operations appear in two varieties.
The first variety consists of operations and predicates which depend only on the
current value of the cursor.
Typical examples are:
.IP \*(MK
Increment the cursor by 7.
This operation fails if the resulting cursor
is not a legal index in the current subject string.
.IP \*(MK
Is the current value of the cursor equal to 3?
.PP
The second variety consists of operations and predicates which depend both on the
current value of the cursor and on the characters in the subject string.
Examples are:
.IP \*(MK
Does \(fm\fI\h'-0.1m'metaphysics\fR\^\(fm occur as substring in the subject string, starting at the
current cursor position?
.IP \*(MK
Can the cursor be moved to the right in such a way that it is only moved
past letters?
And if so, which letters?
.LP
These operations can either \fBsucceed\fP if their predicate is true
(and perhaps change the value of the cursor or deliver a value or both)
or \fBfail\fP if the predicate is false.
These examples show the need for failure handling
in string processing languages (see 1.3.3).
.PP
After these preparations, a list of recognition operations
follows for reference purposes.
These operations are presented in a more or less abstract form, without
commitment to specific syntactic or semantic details.
More detailed descriptions of these operations will appear in subsequent chapters.
.LP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "LEN\|\f1(\fPn\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "increments the cursor by 
.ps 9
.ft 2
.ds 12 "n
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " (see Figure 1.1)
.ps \n(99
.ft \n(98
\*(11
and fails if the new cursor falls outside the subject string.
.KS
.sp 1
.na
.nf
.in +8
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "LEN\|\f1(\fP\f12\fP\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ": \(fm\fIr\jaoute 66.\fP\(fm \(-> \(fm\fIrou\jbte 66.\fP\(fm
.ps \n(99
.ft \n(98
\*(11
\h'|\nau'\(ua\h'|\nbu'\(ua
\h'|\nau'1\h'|\nbu'3
.in -8
.sp 1
.ce 1
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\s-1\fBFigure 1.1\fP. Example of 
.ps 9
.ft 2
.ds 12 "LEN
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".\s0
.ps \n(99
.ft \n(98
\*(11
.sp 1
.ad
.fi
.KE
.LP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "TAB\|\f1(\fPn\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "moves the cursor to index 
.ps 9
.ft 2
.ds 12 "n
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
and fails if that new index falls outside the subject string
(see Figure 1.2).
Note, that this operation depends on the specific index convention chosen.
.KS
.sp 1
.na
.nf
.in +8
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "TAB\|\f1(\fP\f17\fP\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ": \(fm\fIr\jaoute 66.\fP\(fm \(-> \(fm\fIroute 6\jb6.\fP\(fm
.ps \n(99
.ft \n(98
\*(11
\h'|\nau'\(ua\h'|\nbu'\(ua
\h'|\nau'1\h'|\nbu'7
.in -8
.sp 1
.ce 1
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\s-1\fBFigure 1.2\fP. Example of 
.ps 9
.ft 2
.ds 12 "TAB
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".\s0
.ps \n(99
.ft \n(98
\*(11
.sp 1
.ad
.fi
.KE
.LP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "RTAB\|\f1(\fPn\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "moves the cursor to position 
.ps 9
.ft 2
.ds 12 "length\|\f1(\fPsub\^ject\|\f1)\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(mi
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "n
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(mi
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f11\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ",
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "where 
.ps 9
.ft 2
.ds 12 "length\|\f1(\fPsub\^ject\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " gives the number of characters in the subject string
.ps \n(99
.ft \n(98
\*(11
(see Figure 1.3).
The operation fails if the desired cursor position falls outside
the subject string.
.KS
.sp 1
.na
.nf
.in +8
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "RTAB\|\f1(\fP\f15\fP\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ": \(fm\fIr\jaoute 66.\fP\(fm \(-> \(fm\fIrou\jbte 66.\fP\(fm
.ps \n(99
.ft \n(98
\*(11
\h'|\nau'\(ua\h'|\nbu'\(ua
\h'|\nau'1\h'|\nbu'3
.in -8
.sp 1
.ce 1
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\s-1\fBFigure 1.3\fP. Example of 
.ps 9
.ft 2
.ds 12 "RTAB
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".\s0
.ps \n(99
.ft \n(98
\*(11
.sp 1
.ad
.fi
.KE
.LP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "POS\|\f1(\fPn\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "succeeds if the value of the cursor is equal to 
.ps 9
.ft 2
.ds 12 "n
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and fails otherwise (see Figure 1.4).
.ps \n(99
.ft \n(98
\*(11
.KS
.sp 1
.na
.nf
.in +8
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "POS\|\f1(\fP\f11\fP\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ": \(fm\fIr\jaoute 66.\fP\(fm \(-> \(fm\fIr\jboute 66.\fP\(fm
.ps \n(99
.ft \n(98
\*(11
\h'|\nau'\(ua\h'|\nbu'\(ua
\h'|\nau'1\h'|\nbu'1
.in -8
.sp 1
.ce 1
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\s-1\fBFigure 1.4\fP. Example of 
.ps 9
.ft 2
.ds 12 "POS
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".\s0
.ps \n(99
.ft \n(98
\*(11
.sp 1
.ad
.fi
.KE
.LP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "RPOS\|\f1(\fPn\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "succeeds if the value of the cursor is equal to 
.ps 9
.ft 2
.ds 12 "length\|\f1(\fPsub\^ject\|\f1)\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(mi
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "n
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(mi
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f11\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ",
.ps \n(99
.ft \n(98
\*(11
and fails otherwise.
.LP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "SPAN\|\f1(\fPS\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
moves the cursor past the largest number of characters (but at least one),
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "all of which must occur in 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
(see Figure 1.5) and fails otherwise.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Note that functions 
.ps 9
.ft 2
.ds 12 "SPAN
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "BREAK
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " (see below) use
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "their argument string 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " as a \fBset\fP of acceptable characters.
.ps \n(99
.ft \n(98
\*(11
.KS
.sp 1
.na
.nf
.in +8
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "SPAN\|\f1(\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "\(fm0123456789\(fm): \(fm\fIroute \ja66.\fP\(fm \(-> \(fm\fIr\jboute 66\jb.\fP\(fm
.ps \n(99
.ft \n(98
\*(11
\h'|\nau'\(ua\h'|\nbu'\(ua
\h'|\nau'6\h'|\nbu'8
.in -8
.sp 1
.ce 1
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\s-1\fBFigure 1.5\fP. Example of 
.ps 9
.ft 2
.ds 12 "SPAN
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".\s0
.ps \n(99
.ft \n(98
\*(11
.sp 1
.fi
.ad
.KE
.LP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "BREAK\|\f1(\fPS\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
moves the cursor (zero or more positions)
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "to the right until it points to the first character that occurs in 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
(see Figure 1.6), and fails otherwise.
.KS
.sp 1
.na
.nf
.in +8
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "BREAK\|\f1(\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "\(fm86420\(fm): \(fm\fIr\jaoute 66.\fP\(fm \(-> \(fm\fIr\jboute \jb66.\fP\(fm
.ps \n(99
.ft \n(98
\*(11
\h'|\nau'\(ua\h'|\nbu'\(ua
\h'|\nau'1\h'|\nbu'6
.in -8
.sp 1
.ce 1
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\s-1\fBFigure 1.6\fP. Example of 
.ps 9
.ft 2
.ds 12 "BREAK
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".\s0
.ps \n(99
.ft \n(98
\*(11
.ad
.fi
.sp 1
.KE
.SH 1.3. "Why are string processing languages special?"
.PP
We shall now consider
three major aspects of string processing languages in more detail:
.IP \*(MK
\fBBookkeeping\fP.
How can a record be kept of the progress of the recognition process?
.IP \*(MK
\fBRecognition strategies\fP.
What is the best method to determine the structure of a given string?
.IP \*(MK
\fBFailure handling\fP.
What should be done if a string cannot be recognized?
.SH 1.3.1. "Bookkeeping"
.PP
A general way to formulate many parsing problems
is to divide the problem into a number of \fBrecognition steps\fP of the form
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "S
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(->
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "S\f2\(fm\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "in which 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " (the string to be recognized) is mapped on a new string 
.ps 9
.ft 2
.ds 12 "S\f2\(fm\fP
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
on which the next step operates.
In other words, each step delivers a new string value
for the next step to work on, and each step begins 
its recognition task by looking at the leftmost character of its input string.
An important special case occurs if successive steps operate
strictly from left to right.
In that case, all recognition steps operate on substrings
of the original input string and each step delivers a tail of its input as
result to the next step.
In both the general and the special case, a completely \fBfunctional\fP
(e.g. \s-2LISP\s0-like)
formulation of the recognition process can be achieved.
This approach is attractive, but has several disadvantages, to wit:
.IP \*(MK
The need to explicitly mention the string on which each
step operates has an adverse effect on the size of programs.
.IP \*(MK
If one attempts to exploit the special case,
only strict left-to-right scanning can be formulated,
since the characters in the initial string
that occur left of the start of each substring are lost.
.IP \*(MK
It is not easy to implement the functional model efficiently.
.PP
Another way of looking at the recognition process is to
assume that there is one common string on which all operations work
starting at different cursor positions.
The form of a recognition step then becomes
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "<
.ds 13 "S\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "C
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.as 12 "\*(13
.ds 13 ">
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(->
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "<S\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "C
.ds 14 "\f12\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.as 12 "\*(13
.ds 13 ">
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "where 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " stands for the fixed string to be recognized and
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "C
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "C
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " stand for the cursor position
.ps \n(99
.ft \n(98
\*(11
before and after the step.
This can be expressed by introducing the notion of a \fBcurrent subject\fP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "consisting of a string 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and a cursor position 
.ps 9
.ft 2
.ds 12 "C
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " in 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "All recognition steps operate on the string 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "starting at cursor position 
.ps 9
.ft 2
.ds 12 "C
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
This approach has the advantage of obviating the need to mention the subject
string explicitly each time a new step is performed as well as of providing
cursor management.
In other words, the notation is made more concise at the expense
of introducing a global entity, which
acts as `current focus of activity'.
.PP
In order to limit the field of discussion,
we will only pursue the second approach in this monograph.
Some consequences of the functional approach can be found in [Morris80].
As to the choice made, it is interesting to note that
it is hard to find a notion of a `current focus of activity'
in any existing general purpose programming language.
.SH 1.3.2. "Recognition strategy"
.PP
Parsing a string amounts to recognizing some given structure in it.
A natural way of expressing such structures is by means of a \fBgrammar\fP.
There exist many kinds of grammar with varying descriptive power
(see for example [Aho72]).
In practice, most grammars have an associated algorithm to
recognize strings belonging to it.
In the design of a string processing language, a decision
must be made regarding the descriptive power and recognition strategy
that will be supported by the language.
One can either restrict the class of admissible grammars to those
having an efficient recognition algorithm, or one can allow arbitrary
context-free grammars and use a general, but less efficient parsing method.
The latter will be done in this monograph, since the problems involved are
interesting and have only been partially explored.
Having chosen a recognition method,
the conciseness of recognition algorithms is, in general, enhanced
by providing a shorthand notation for it.
In this way, the details of the algorithm
(like shifting to a new state or reading the next input symbol)
can be omitted for each recognition step.
.PP
\fBBacktracking\fP
will be used as the recognition method for arbitrary context-free grammars.
Backtracking [Golomb65] is a programming technique for organizing search processes that
are based on trial-and-error.
It amounts to imposing a tree-structure on the search space and traversing
the tree in a predetermined order.
Backtracking can be applied to parsing as follows.
Initially, it is \fBassumed\fP
that a given input sentence can be derived from the grammar rule
.DS
\*<s\*> ::= \*<r\*> .
.DE
where \*<s\*> is the start symbol of the grammar and \*<r\*> is
the right hand side of the grammar rule for \*<s\*>.
This assumption can either be verified in a trivial way
(if \*<r\*> is simple, e.g. a terminal symbol of the grammar)
or the recognition process must prepare itself for the verification
of a more complex assumption.
To this end, new assumptions are made that correspond to the constituents of \*<r\*>.
If all these assumptions turn out to be true, the initial assumption was true.
If an assumption turns out to be false, there are two cases:
.IP \*(MK
There exists an alternative for it.
In this case an attempt is made to verify the alternative.
For example, the assumption that an \*<addition-operator\*> will occur
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "in the input sentence may turn out to be true if either a `
.ps 9
.ft 2
.ds 12 "\(pl
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "' or `
.ps 9
.ft 2
.ds 12 "\(mi
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "' symbol
.ps \n(99
.ft \n(98
\*(11
is encountered.
.IP \*(MK
There exist no alternatives for the current assumption.
In this case, the `parent' assumption was false, but it may in its turn have
alternatives.
.PP
Several subsidiary questions must be answered when
the particular backtracking method chosen is to be specified completely.
A first question that arises concerns the \fBorder\fP in which alternatives are attempted.
A method is said to be \fBdeterministic\fP
if the order in which alternatives are attempted is reproducible.
In \fBnondeterministic\fP
methods alternatives are attempted in an arbitrary order.
Again, in order to narrow the field of discussion,
we shall restrict our attention entirely to deterministic methods.
A second question to be answered has to do with the \fBmoment\fP
at which the search space is established.
Is it fixed statically at the start of the search process or can
it be modified dynamically during the search?
We shall consider both possibilities.
A final question concerns the precise \fBstructure\fP of the search space.
Does it have the structure of a tree, a directed acyclic graph or perhaps
even an arbitrary graph?
We shall mostly encounter tree-like structures.
.PP
Further aspects of backtracking
(as used in \s-2SNOBOL\s04) are discussed in Section 1.4.
.SH 1.3.3. "Failure handling"
.PP
The outcome of the entire recognition process is dependent on the
outcome of each individual recognition step.
Since each step may discover the subject string to have an unexpected
form, failure handling is an important issue.
For each step there are two possibilities:
.IP \*(MK
The step succeeds and this fact together with more detailed information
(the recognized part of the subject string, the new cursor value)
have to be made available to subsequent steps.
.IP \*(MK
The step fails and the kind of failure has to be indicated.
.LP
How the success or failure of an individual step affects the
overall recognition process, depends on the particular recognition strategy chosen.
.PP
A short remark on failure handling is appropriate
in anticipation of discussions on this topic
in Chapters 2 and 3.
When considering the combinations of language features dealing
with failure handling and flow of control,
one has the following choices:
.IP "\ \ 1)"
Include `Boolean' values in the language, which
can be used to remember the outcome of logical operations,
and let the flow of control constructs be dependent on these Boolean values.
All recognition functions should then be Boolean functions;
success or failure of each function is delivered as the result of
its invocation and
subsidiary results (such as the new cursor value)
can then be delivered using call-by-reference parameters.
.IP "\ \ 2)"
Let all `values' in the language consist of (value, signal)-pairs;
the flow of control constructs use the signal-part of each value
and all other constructs use the value-part.
The signal-part of a value can thus be inspected at any moment after the
value has been computed.
Since it may be desirable for the evaluation of an expression to terminate
as soon as one of its subexpressions fails,
all operations in the language should be defined in such a way that
they immediately terminate when one of their arguments is a value containing
a signal-part indicating previous failure.
.IP "\ \ 3)"
All operations generate a `failure signal', which is used to
drive the flow of control constructs.
In contrast to the previous case,
where failure signals can be remembered for later use,
in this case they are transient entities:
failure signals are not part of a value and should be immediately intercepted
when they are generated.
.IP "\ \ 4)"
Include both Boolean values and a general exception handling
mechanism in the language.
The flow of control constructs can then operate on Boolean
values and all other `abnormal' conditions can be taken care of
by the exception handling mechanism.
.LP
Alternative 1) is the obvious choice if recognition functions have
to be embedded in a conventional programming language.
It has the disadvantage that many additional if-statements are
required to test the outcome of each recognition function.
Alternative 2) is interesting since it allows differentiation between
sources of failure (by specifying different values in the signal-part)
without introducing complicated flow of control primitives
needed for general exception handling.
Alternative 3) is a compromise between expressive power and simplicity:
it incorporates exception handling for one kind of exception
(failure signals) but does not require complicated flow of control
primitives in the language.
This alternative will play an important role in our studies.
Alternative 4) is the most general, but at the same time the most
complicated form of expression evaluation.
It will not be considered here to avoid the many unsolved problems
associated with general exception handling.
See, for instance, [Goodenough75] or [Luckham80] for a discussion of this issue.
.SH 1.3.4. "Existing languages and string processing"
.PP
By combining the language requirements encountered in Section 1.1 with
the more detailed characteristics of string processing given above, we arrive
at the following list of language requirements for string processing:
.IP R1.
Recognition power at the syntactic level.
If recognition of arbitrary context-free grammars is desired, then
some form of backtracking should be available in the language.
The notion of a `subject string' should be available.
.IP R2.
Failure handling, i.e. language constructs for
(restricted) exception handling.
.IP R3.
Data structures that can be allocated dynamically and that may grow dynamically.
.LP
Other obvious requirements that apply to \fBall\fP
kinds of programming languages, such as modularity and adequate control structures,
are taken for granted and
will not be considered here.
.PP
Two general observations will place these requirements in perspective.
First of all, it should be noted that \fBall\fP envisaged applications
\fBcould\fP be implemented using \s-2FORTRAN\s0, assembly language, etc.
However, the introduction of special language features for string processing
can result in a programming language that is much more suited to
string processing applications than other languages that are
not `optimized' for this particular application.
.PP
Secondly, one should bear in mind that we have chosen to investigate
problems related to backtracking.
Backtracking is just another programming technique,
but manifests itself differently when integrated with
other constructs in a programming language.
This becomes particularly clear if side-effects are taken into account.
The incorporation of backtracking facilities into a programming language
makes it possible to
define explicitly the interaction between backtracking and the operations
that may cause side-effects (e.g. assignment statements).
This cannot be achieved if backtracking is added on top of
an existing programming language by, for example, procedural extension.
.PP
There are also more specific reasons for designing a new language instead
of choosing an existing one.
Only the chief shortcomings of \s-2PASCAL\s0 [Wirth71] and \s-2ALGOL\s068
[VanWijngaarden76] will be discussed here;
a discussion of \s-2SNOBOL\s04 is postponed to Section 1.4.
.PP
There are five major obstacles to using \s-2PASCAL\s0 for string processing.
First, the size of \s-2PASCAL\s0 data structures is fixed statically and this
conflicts with requirement R3.
Secondly, the programmer has to be aware of the life-time of some data structures;
these must allocated and de-allocated explicitly.
Thirdly, the size of strings is part of their type, i.e.
two strings of different length have different type and cannot, for example,
be assigned to the same variable.
Several attempts (see for instance [Sale79])
have been made to eliminate this problem, but none seems successful.
Fourthly, it is not easy to incorporate any form of failure or
exception handling into the language.
Finally, backtracking and more specifically the control of side-effects
during backtracking are difficult, if not impossible, to implement in \s-2PASCAL\s0.
.PP
There are three major obstacles if one tries to use
\s-2ALGOL\s068 for string processing.
First, the programmer is responsible for the allocation of objects
on the heap.
This is a nuisance since, typically, procedures deliver objects that
have a longer life-time than the procedure itself and such objects must
therefore be explicitly allocated on the heap.
The other two obstacles are the same as the ones mentioned for \s-2PASCAL\s0:
the difficulty of implementing failure handling and backtracking.
.SH 1.4. "Problems in string processing languages"
.PP
There are several problems in existing string processing languages
and most of them are a consequence of side-effects
occurring during the recognition process.
These problems will now be illustrated by introducing an absolute minimum
of \s-2SNOBOL\s04 [Griswold71]
(being the best known string processing language)
and by giving some \s-2SNOBOL\s04 examples that exhibit these problems.
.SH 1.4.1. "A short introduction to \s-2SNOBOL\s04"
.PP
In \s-2SNOBOL\s04 the recognition steps are described by a \fBpattern\fP
and the recognition process is called \fBpattern matching\fP.
A pattern defines a set of acceptable strings and acts as a predicate that
succeeds or fails when it is presented with a string that is or is not
in the set of acceptable strings.
A pattern may also perform arbitrary computations while deciding
whether a given string is acceptable or not.
The general form of a \s-2SNOBOL\s04 statement is:
.DS
\*<label\*> \*<subject\*> \*<pattern\*> \(fm\fI=\fR\^\(fm \*<replacement\*> \*<goto\*>
.DE
A \*<label\*> identifies a statement and allows other statements to `jump'
to that statement.
A \*<subject\*> followed by a \*<pattern\*> indicates the beginning of a pattern match
to determine whether the subject string contains a substring
that is in the set of acceptable strings defined by the pattern.
If so, the matched substring is replaced by
the \*<replacement\*> string and execution proceeds at the statement
associated with success.
Otherwise, no replacement takes place and
execution proceeds at the statement associated with failure.
The labels of the successor statements for success and failure are given in
the \*<goto\*> field.
Most parts of a \s-2SNOBOL\s04 statement are optional.
Apart from the two examples that follow, we shall only consider
statements in which all fields
except the subject and pattern field are empty.
.DS
Example 1:

 \fIL\fR  \jg\fIX\fR  \jh\fISPAN\fR\^(\(fm\fI0123456789\fR\^\(fm\^)  \ji:\fIS\fR\^(\fIP\fR)\fIF\fR\^(\fIQ\fR)
.DE
.LP
Here, \fIL\fR is the \*<label\*>,
\fIX\fR is the \*<subject\*>,
\fISPAN\fR\^(\(fm\fI0123456789\fR\^\(fm\^) is the \*<pattern\*> and
:\fIS\fR\^(\fIP\fR)\fIF\fR\^(\fIQ\fR) is the \*<goto\*>.
The result of executing the above statement is a
jump to label \fIP\fR if the subject string \fIX\fR contains a span of digits
or a jump to label \fIQ\fR otherwise.
.DS
Example 2:

\fIL\fR  \jg\fIPACT\fR  \jh\(fm\fI\h'-0.1m'multi-lateral\^\fR\^\(fm = \(fm\fI\h'-0.1m'impossible\fR\^\(fm
.DE
.LP
Replaces the first occurrence of the string \(fm\fI\h'-0.1m'multi-lateral\^\fR\^\(fm in \fIPACT\fR by
the string \(fm\fI\h'-0.1m'impossible\fR\^\(fm.
Does nothing if the pattern fails, since no `failure' label was given in the \*<goto\*> field.
.PP
All these pattern matches are \fBunanchored,\fP
i.e. the pattern as a whole is attempted at all cursor positions in the subject string.
.SH 1.4.2. "Compound patterns"
.PP
Compound patterns are constructed from primitive ones
(i.e. the literal string, \fISPAN\fR, \fIBREAK\fR, etc.)
by means of \fBpattern concatenation\fP and \fBpattern alternation\fP.
The construction of compound patterns is performed
\fBbefore\fP the pattern match is started.
This leads to two evaluation moments:
\fBpattern construction time\fP and \fBpattern matching time\fP.
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The concatenation of two patterns 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is written as
.ps \n(99
.ft \n(98
\*(11
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "P
.ds 14 "\f12\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "(i.e. 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " followed by 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " separated by one or more space characters)
.ps \n(99
.ft \n(98
\*(11
This constructs a new pattern that will apply
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " followed by 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
For example,
.DS
\fIYEAR\fR  \jg\(fm\fI\h'-0.1m'AD\fR\^\(fm \fISPAN\fR\^(\(fm\fI0123456789\fR\^\(fm\^)
.DE
succeeds if \fIYEAR\fR contains the string \(fm\fI\h'-0.1m'AD\fR\^\(fm followed by digits.
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The alternation of two patterns 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is written as
.ps \n(99
.ft \n(98
\*(11
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\|\f1|\fP\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "P
.ds 14 "\f12\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.DE
and constructs a new pattern that will succeed
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "if either 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " succeeds, or
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " fails but 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " succeeds.
.ps \n(99
.ft \n(98
\*(11
For example,
.DS
\fIYEAR\fR  \jg\(fm\fI\h'-0.1m'UNKNOWN\^\fR\^\(fm | \fISPAN\fR\^(\(fm\fI0123456789\fR\^\(fm\^)
.DE
succeeds if \fIYEAR\fR contains \fBeither\fP the string \(fm\fI\h'-0.1m'UNKNOWN\^\fR\^\(fm \fBor\fP
a span of digits and
.DS
\fIX\fR  \jg(\(fm\fI\h'-0.1m'd\^\fR\^\(fm | \(fm\fI\h'-0.1m'b\fR\^\(fm\^) \(fm\fI\h'-0.1m'ea\fR\^\(fm (\(fm\fI\h'-0.1m'n\fR\^\(fm | \(fm\fI\h'-0.1m'r\fR\^\(fm | \(fm\fI\h'-0.1m'd\^\fR\^\(fm\^)
.DE
will succeed if \fIX\fR contains \(fm\fI\h'-0.1m'dean\fR\^\(fm, \(fm\fI\h'-0.1m'dear\fR\^\(fm,
\&\(fm\fI\h'-0.1m'dead\^\fR\^\(fm, \(fm\fI\h'-0.1m'bean\fR\^\(fm, \(fm\fI\h'-0.1m'bear\fR\^\(fm, or \(fm\fI\h'-0.1m'bead\^\fR\^\(fm
as substring.
.PP
In fact, compound patterns represent \fBand/or goal-trees\fP
(see [Nilsson71]) and a pattern match
succeeds if (part of) the tree has been `traversed successfully'.
Figure 1.7 shows the and/or tree corresponding to the last example.
.KF
... -1.5 -2 2 0.25 0 0 4096 4096
... 0u 972u 1512u 0u 648u 108u 1770120u -1769361u
.PS 972 1512 
.br
.nf
\h'756u'\v'108u'\h'-0.0m'\v'0.2m'\h'-\w'and'u/2u'and\h'-\w'and'u/2u'
.sp -1
.nr .. \n(.s/2
.ps \n(..
\h'648u'\v'108u'\&\v'-3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.
.sp -1
\&\h'864u'\v'111u'\z.\v'-3u'\z.\v'-3u'\z.\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.
.sp -1
\&\h'648u'\v'99u'\z.\v'3u'\z.\v'3u'\z.
.ps
.sp -1
\h'324u'\v'540u'\h'-0.0m'\v'0.2m'\h'-\w'or'u/2u'or\h'-\w'or'u/2u'
.sp -1
.nr .. \n(.s/2
.ps \n(..
\h'216u'\v'540u'\&\v'-3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.
.sp -1
\&\h'432u'\v'549u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.
.sp -1
\&\h'219u'\v'525u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.
.ps
.sp -1
\h'756u'\v'540u'\h'-0.0m'\v'0.2m'\h'-\w'\(fm\fIea\(fm\fP'u/2u'\(fm\fIea\(fm\fP\h'-\w'\(fm\fIea\(fm\fP'u/2u'
.sp -1
\h'1188u'\v'540u'\h'-0.0m'\v'0.2m'\h'-\w'or'u/2u'or\h'-\w'or'u/2u'
.sp -1
.nr .. \n(.s/2
.ps \n(..
\h'1080u'\v'540u'\&\v'-3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'3u'\v'-3u'\z.\v'-3u'\z.
.sp -1
\&\h'1296u'\v'555u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.
.sp -1
\&\h'1083u'\v'519u'\z.\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.
.ps
.sp -1
.nr .. \n(.s/2
.ps \n(..
\h'681u'\v'186u'\&\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.
.sp -1
\&\h'396u'\v'381u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\z.
.ps
.sp -1
\v'972u'\h'-0.0m'\v'0.2m'\h'-\w'\(fm\fId\(fm\fP'u/2u'\(fm\fId\(fm\fP\h'-\w'\(fm\fId\(fm\fP'u/2u'
.sp -1
\h'648u'\v'972u'\h'-0.0m'\v'0.2m'\h'-\w'\(fm\fIb\(fm\fP'u/2u'\(fm\fIb\(fm\fP\h'-\w'\(fm\fIb\(fm\fP'u/2u'
.sp -1
.nr .. \n(.s/2
.ps \n(..
\h'261u'\v'627u'\&\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.
.sp -1
\&\h'90u'\v'858u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.
.ps
.sp -1
.nr .. \n(.s/2
.ps \n(..
\h'390u'\v'627u'\&\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.
.ps
.sp -1
.nr .. \n(.s/2
.ps \n(..
\h'756u'\v'216u'\v'-.25m'\L'324u\(br'\v'.25m'
.ps
.sp -1
.nr .. \n(.s/2
.ps \n(..
\h'834u'\v'186u'\&\z.\h'3u'\z.\h'3u'\v'3u'\z.
.sp -1
\&\h'843u'\v'192u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.
.sp -1
\&\h'1149u'\v'402u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\z.
.ps
.sp -1
\h'864u'\v'972u'\h'-0.0m'\v'0.2m'\h'-\w'\(fm\fIn\(fm\fP'u/2u'\(fm\fIn\(fm\fP\h'-\w'\(fm\fIn\(fm\fP'u/2u'
.sp -1
\h'1188u'\v'972u'\h'-0.0m'\v'0.2m'\h'-\w'\(fm\fIr\(fm\fP'u/2u'\(fm\fIr\(fm\fP\h'-\w'\(fm\fIr\(fm\fP'u/2u'
.sp -1
\h'1512u'\v'972u'\h'-0.0m'\v'0.2m'\h'-\w'\(fm\fId\(fm\fP'u/2u'\(fm\fId\(fm\fP\h'-\w'\(fm\fId\(fm\fP'u/2u'
.sp -1
.nr .. \n(.s/2
.ps \n(..
\h'1125u'\v'627u'\&\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.\h'-3u'\v'3u'\z.
.ps
.sp -1
.nr .. \n(.s/2
.ps \n(..
\h'1188u'\v'648u'\&
.sp -1
\&\h'1188u'\v'648u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.\v'3u'\z.
.ps
.sp -1
.nr .. \n(.s/2
.ps \n(..
\h'1254u'\v'627u'\&\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.
.sp -1
\&\h'1317u'\v'714u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.\h'3u'\v'3u'\z.
.ps
.sp -1
.fi
.sp 1+972u
.PE
.sp 1
.ce
\s-1\fBFigure 1.7\fP. And/or goal tree.\s0
.sp 1
.KE
.PP
If the root of the tree is an `and' node (representing pattern concatenation),
\fBall\fP immediate subtrees of the root must have been traversed successfully
before the pattern match succeeds.
If the root of the tree is an `or' node (representing pattern alternation), only
\fBone\fP
immediate subtree of the root must have been traversed successfully before
the pattern match succeeds.
In the last case the pattern may have untried alternatives,
i.e. unattempted immediate subtrees of the root.
All subtrees of an alternative node are always attempted starting at the same
cursor position.
.PP
The tree is traversed by means of \fBbacktracking\fP;
this is a structured form of trial-and-error (see 1.3.2).
When one attempt to traverse a subtree fails,
the aforementioned untried alternatives may lead to a different,
but successful traversal of the tree.
.SH 1.4.3. "Side-effects during pattern matching"
.PP
The \s-2SNOBOL\s04 patterns introduced so far cannot
have side-effects:
the values of variables in the program cannot be modified during the traversal
of the tree if only pattern concatenation and pattern alternation are used.
However, several other operations are available in \s-2SNOBOL\s04
and these can have side-effects.
Three of them are:
\fBimmediate value assignment\fP, \fBconditional value assignment\fP
and
\fBunevaluated expressions\fP.
.br
.ne 4
.PP
\fBImmediate value assignment\fP
is written as
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\ 
.as 12 "\|\*(13
.ft 1
.ds 13 "$
.ds 13 \f1\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "V
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "and constructs a new pattern that will assign to variable 
.ps 9
.ft 2
.ds 12 "V
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "the part of the subject string that is recognized by pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
This assignment is performed immediately, i.e. at the moment that the
immediate value assignment operation is encountered in the pattern tree.
For example
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\&\(fm\fI\h'-0.1m'AD 1984\fR\^\(fm  \jg\fISPAN\fR\^(\(fm\fI0123456789\fR\^\(fm\^) 
.ps 9
.ft 2
.ft 1
.ds 12 "$
.ds 12 \f1\*(12\f2
.ft 2
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " \fIYEAR\fR
.ps \n(99
.ft \n(98
\*(11
.DE
assigns the string \(fm\fI1984\fR\^\(fm to the variable \fIYEAR\fR, and
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\&\(fm\fI1984 BC\fR\^\(fm  \jg(\fISPAN\fR\^(\(fm\fI0123456789\fR\^\(fm\^) 
.ps 9
.ft 2
.ft 1
.ds 12 "$
.ds 12 \f1\*(12\f2
.ft 2
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " \fIYEAR\fR) \(fm\fI AC\fR\^\(fm
.ps \n(99
.ft \n(98
\*(11
.DE
fails, but also assigns \(fm\fI1984\fR\^\(fm to \fIYEAR\fR.
.PP
\fBConditional value assignment\fP is written as
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 ".
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "V
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "and constructs a new pattern that will assign to variable 
.ps 9
.ft 2
.ds 12 "V
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "the part of the subject string that is recognized by pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
Assignment is \fBonly\fP performed at the end of a successful pattern match.
For example,
.DS
\&\(fm\fI1984\fR\^\(fm  \jg\fISPAN\fR\^(\(fm\fI0123456789\fR\^\(fm\^) . \fIYEAR\fR
.DE
assigns \(fm\fI1984\fR\^\(fm to \fIYEAR\fR, but
.DS
\&\(fm\fI1984  BC\fR\^\(fm (\fISPAN\fR\^(\(fm\fI0123456789\fR\^\(fm\^) . \fIYEAR\fR) \(fm\fI\h'-0.1m'AC\fR\^\(fm
.DE
fails and does \fBnot\fP assign a new value to \fIYEAR\fR.
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Finally, let 
.ps 9
.ft 2
.ds 12 "E
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " be an arbitrary \s-2SNOBOL\s04 expression.
.ps \n(99
.ft \n(98
\*(11
\fBUnevaluated expressions\fP,
written as
.DS
\v'0.25m'*\v'-0.25m'\fIE\fR
.DE
construct a new pattern that will evaluate
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "the expression 
.ps 9
.ft 2
.ds 12 "E
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " at the moment
.ps \n(99
.ft \n(98
\*(11
the new pattern is encountered during the match.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The value of 
.ps 9
.ft 2
.ds 12 "E
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is then used as the pattern to be recognized.
.ps \n(99
.ft \n(98
\*(11
For example,
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\fIX\fR  \jg(\fISPAN\fR\^(\(fm\fI0123456789\fR\^\(fm\^) 
.ps 9
.ft 2
.ft 1
.ds 12 "$
.ds 12 \f1\*(12\f2
.ft 2
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " \fIY\fR) \(fm\fI\h'-0.1m'AA\fR\^\(fm \v'0.25m'*\v'-0.25m'\fIY\fR
.ps \n(99
.ft \n(98
\*(11
.DE
succeeds if \fIX\fR contains two identical spans of digits separated by the
string \(fm\fI\h'-0.1m'AA\fR\^\(fm.
Note that, in this example, side-effects are used that were the result of
previous operations in the pattern match, namely the immediate value
assignment to the variable \fIY\fR.
In general, the evaluation of an unevaluated expression may itself cause
side-effects.
.PP
With the introduction of these operations,
the program state can be influenced during a pattern match by:
.IP \*(MK
immediate value assignments
.IP \*(MK
cursor movements caused by recognition operations
.IP \*(MK
side-effects caused by the evaluation of unevaluated expressions.
.LP
Note that conditional value assignment can only affect the state
at the completion of a successful pattern match.
.SH 1.4.4. "Problems with the \s-2SNOBOL\s04 approach"
.PP
A more elaborate example will give the reader some feeling for the
complexity that can result from the application of
\s-2SNOBOL\s04 pattern matching operations.
Let \fIP\fR be the pattern defined by
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\z( \jg(\fILEN\fR\^(2) 
.ps 9
.ft 2
.ft 1
.ds 12 "$
.ds 12 \f1\*(12\f2
.ft 2
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " \fIX\fR) (\(fm\fI\h'-0.1m'CD\fR\^\(fm | \(fm\fI\h'-0.1m'EF\fR\^\(fm\^) . \fIY\fR \v'0.25m'*\v'-0.25m'\fIX\fR \v'0.25m'*\v'-0.25m'\fIY\fR) | (\fILEN\fR\^(3) . \fIY\fR)
.ps \n(99
.ft \n(98
\*(11
.DE
and assume that the variables \fIX\fR and \fIY\fR
both have initial value \(fm\fI\h'-0.1m'ZZZ\fR\^\(fm.
Considering the pattern match
.DS
\&\(fm\fI\h'-0.1m'ABCDABZZZ\fR\^\(fm  \jg\fIP\fR  ,
.DE
which values will be assigned to \fIX\fR and \fIY\fR after execution it?
The following intermediate steps provide the answer.
.IP \ \ 1)
\fILEN\fR\^(2) immediately assigns \(fm\fI\h'-0.1m'AB\fR\^\(fm to \fIX\fR.
.IP \ \ 2)
\z( \jg\(fm\fI\h'-0.1m'CD\fR\^\(fm | \(fm\fI\h'-0.1m'EF\fR\^\(fm\^) conditionally assigns \(fm\fI\h'-0.1m'CD\fR\^\(fm to \fIY\fR,
i.e. assignment is not performed but remembered.
.IP \ \ 3)
\v'0.25m'*\v'-0.25m'\fIX\fR evaluates to \(fm\fI\h'-0.1m'AB\fR\^\(fm, and this pattern succeeds.
.IP \ \ 4)
\v'0.25m'*\v'-0.25m'\fIY\fR evaluates to \(fm\fI\h'-0.1m'ZZZ\fR\^\(fm (the initial value of \fIY\fR!), and this pattern succeeds.
.IP \ \ 5)
The pattern match succeeds and the conditional value assignment to \fIY\fR
(which was remembered in step 2, above) is performed.
.IP \ \ 6)
At the completion of the pattern match,
\fIX\fR has value \(fm\fI\h'-0.1m'AB\fR\^\(fm and \fIY\fR has value \(fm\fI\h'-0.1m'CD\fR\^\(fm.
.LP
The problems with the \s-2SNOBOL\s04 approach can now be summarized as follows:
.IP \*(MK
Side-effects during the pattern match in combination with
immediate/conditional value assignment lead to opaque programs in which
left-to-right textual order
of the program source text need not correspond to the actual order of evaluation.
.IP \*(MK
Backtracking is completely automatic and cannot be controlled by the
programmer.
This may either lead to gross inefficiencies or to undesired or unexpected
behavior of programs.
.IP \*(MK
There are two different vocabularies in the language.
One for expression evaluation and another for pattern matching
(see [Griswold80]).
.SH 1.5. "A checklist for string processing languages"
.PP
After this inventory of string processing operations and associated problems
in string processing languages one can compose a list
of questions that can serve as a basis for the characterization of
string processing languages.
As with any questionnaire, the questions asked largely determine the answers
one gets.
The list of questions given here is based on a particular view of the way in
which string processing languages should develop.
This point of view will be explained in more detail in Chapter 2.
.SH 1.5.1. "Treatment of the subject"
.IP \*(MK
Can the subject be defined explicitly?
.IP \*(MK
What is the scope of the subject?
Is it the whole program, one procedure or one statement?
.IP \*(MK
Can more than one subject be defined?
And if so, are subjects defined consecutively
or simultaneously?
.IP \*(MK
Which data types can the subject have?
Possibilities are character string, character file, integer array
and perhaps others.
.SH 1.5.2. "Recognition strategy"
.PP
One can distinguish several recognition strategies, such as
the ones used for the recognition of regular expressions and
LL(k) or LR(k) languages,
and the techniques used for
recursive descent and backtrack parsing.
Only recursive descent parsing and backtrack parsing will be considered
in this monograph.
There are two reasons for making this restriction.
The first reason is historical, since initially \s-2SNOBOL\s04 was taken
as a starting point and backtrack parsing is the only recognition
strategy available in that language.
The second reason is that backtrack parsing allows the recognition
of a wider class of languages than is possible with, for example,
LR(1) parsers.
In general, it might be a better idea to
make the recognition strategy invisible at the programming language level
and to let the implementation choose the best
strategy for a given problem.
This line of development is interesting but falls outside the scope
of the current work.
.PP
With respect to backtrack parsers, the following questions can be asked:
.IP \*(MK
Are side-effects possible during the recognition process?
.IP \*(MK
How are side-effects treated in case of failure?
See the last point below.
.IP \*(MK
How is flow of control backtracking organized, i.e.
how is the next alternative selected?
One can distinguish between \fIad hoc\fP and systematic flow of control backtracking.
In the former case, the programmer has to indicate each alternative explicitly
while in the latter case, alternatives are determined in some systematic, implicit
manner.
Systematic backtracking may either be completely automatic or the
programmer may have the possibility
of exercising more detailed control over the backtracking process.
.IP \*(MK
How is data backtracking organized, i.e.
how is determined which values program variables should have
after an attempt failed?
Here one can distinguish \fIad hoc\fP and systematic backtracking in the same
way as above.
.SH 1.6. "References for Chapter 1"
.so refs/Aho72
.so refs/Golomb65
.so refs/Goodenough75
.so refs/Griswold80
.so refs/Griswold71
.so refs/Luckham80
.so refs/Morris80
.so refs/Mowshowitz81
.so refs/Nilsson71
.so refs/Sale79
.so refs/VanWijngaarden76
.so refs/Weizenbaum76
.so refs/Wirth71

.EC
.NC 2 "DESIGN CONSIDERATIONS FOR" "STRING PROCESSING LANGUAGES"
.ds LH "DESIGN CONSIDERATIONS FOR STRING PROCESSING
.SH 2.1. "Introduction"
.PP
The application of backtracking in pattern matching and the integration of
pattern matching operations into string processing languages form
the central themes of this chapter.
.PP
Backtracking can be used to solve
certain classes of pattern matching problems elegantly.
However, the effects of backtracking on the global program state are
often difficult to understand.
Are side-effects postponed until the
backtracking process as a whole has succeeded
(which restricts the class of problems that can be solved),
or are such modifications performed
immediately and undone on failure?
Several methods are being used to control the interaction between
the backtracking process and its side-effects.
Most methods have defects.
In this chapter an attempt will be made to improve on this state of affairs.
.PP
The analysis of backtracking will proceed in three stages.
First, in Section 2.2 some representative pattern matching functions and operators are defined.
These functions are sufficiently powerful that they exhibit the same problems
with regard to side-effects and backtracking as occur in, for example, \s-2SNOBOL\s04.
They are, at the same time, sufficiently simple to
allow a concise formal definition of their semantics and an analysis
of the problems at hand.
In other words, these functions are used to \fBmodel\fP
(i.e. imitate on a smaller scale) certain features of existing
programming languages.
.PP
Secondly, we have to choose a
method for describing the semantics of backtracking processes.
After comparing several methods found in the literature,
an improved description method is introduced, which is
based on operational semantics.
This is the subject of Section 2.3.
.PP
Thirdly, the description method is used to compare
two different pattern matching models.
In Section 2.4.2 the
\fBimmediate/conditional model\fP is described.
This is a generalization of the \s-2SNOBOL\s04 model [Griswold71].
In Section 2.4.3 the \fBrecovery model\fP is introduced.
This new model is based on the recovery block concept 
[Randell75]
which has been used for the construction of fault-tolerant software.
It is an attractive alternative to existing backtracking models,
since it combines simplicity and consistency with adequate expressive
power and ease of implementation.
.PP
Finally, Section 2.5 is devoted to the question of how pattern matching
and normal expression evaluation can be integrated and how
the domain of pattern matching can be extended beyond the domain of strings.
In the following chapters these ideas will be explored further.
.SH 2.2. "Some representative pattern matching functions and operators"
.PP
We first introduce a uniform terminology with the aid of which the
problems inherent in the two pattern matching models can be discussed.
A \fBpattern\fP defines a set of \fBacceptable\fP strings.
It is a predicate which
succeeds or fails when presented with a string that is or is not
an element of the set of acceptable strings.
Arbitrary (terminating) computations may be performed while determining
whether a given string is acceptable or not.
A \fBpattern match\fP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "is the process of deciding whether a given string 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is acceptable to
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "a given pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " or not.
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The notation 
.ps 9
.ft 2
.ds 12 "S
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "?
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "P
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " will be used to denote a pattern match.
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "All (sub)patterns in 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " will operate on the same subject string 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
An implicit index (the \fBcursor\fP)
holds the position in the subject string where each subpattern
should start its recognition task.
.PP
Three types of primitive patterns will be used:
\fBstring literals\fP, \fBunevaluated expressions\fP and \fBactions\fP.
These are informally defined as follows:
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 ".IP "String literal: 
.ps 9
.ft 2
.ds 12 "T
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ""
.ps \n(99
.ft \n(98
\*(11
.br
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Try to match a given string value 
.ps 9
.ft 2
.ds 12 "T
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
in the subject string starting at the current cursor position.
.IP "Unevaluated\ expression: \v'0.25m'*\v'-0.25m'\fIE\fR"
.br
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Evaluate expression 
.ps 9
.ft 2
.ds 12 "E
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and use the result as a pattern.
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 ".IP "Action: 
.ps 9
.ft 2
.ds 12 "act\|\f1(\fPE\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ""
.ps \n(99
.ft \n(98
\*(11
.br
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Evaluate expression 
.ps 9
.ft 2
.ds 12 "E
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " for its side-effects.
.ps \n(99
.ft \n(98
\*(11
This primitive pattern always succeeds and does not cause any movement of
the cursor (i.e. it matches the empty string).
.PP
These primitive patterns can be combined to form more
complicated patterns by means of the pattern construction functions
\fBalternation\fP, \fBsubsequentiation\fP and \fBsubject assignment\fP.
Note that we will attach different meanings to alternation and subsequentiation 
in the two pattern matching models to be considered.
Here, their meaning is the one used in the immediate/conditional model.
Their meaning in the recovery model is given in Section 2.4.3.
The pattern construction functions are informally defined as follows:
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 ".IP "Alternation: 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\|\f1|\fP\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "Q
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ""
.ps \n(99
.ft \n(98
\*(11
.br
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "If pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " fails, attempt pattern 
.ps 9
.ft 2
.ds 12 "Q
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "; if 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " succeeds, remember 
.ps 9
.ft 2
.ds 12 "Q
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
in case failure occurs later on
(this can only happen if the alternation is part of a larger pattern).
.IP "Subsequentiation:\ \fIP\fR \(mi\h'-0.2m'\(mi \fIQ\fR"
.br
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Attempt pattern 
.ps 9
.ft 2
.ds 12 "Q
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " after a successful match of pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 ".IP "Subject\ assignment:\ 
.ps 9
.ft 2
.ds 12 "sbas\|\f1(\fPP\|\f1,\fPV\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ""
.ps \n(99
.ft \n(98
\*(11
.br
The part of the subject string
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "successfully matched by pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "is assigned to variable 
.ps 9
.ft 2
.ds 12 "V
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "(This resembles the `.' and `
.ps 9
.ft 2
.ft 1
.ds 12 "$
.ds 12 \f1\*(12\f2
.ft 2
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "' operators in \s-2SNOBOL\s04.)
.ps \n(99
.ft \n(98
\*(11
Note that subject assignments are more restricted than primitive action patterns:
the latter may contain assignments of any value to any variable,
but the former only allow assignment of a matched part
of the subject string to an explicitly mentioned variable.
.PP
This collection of functions and operators
exhibits most features found in pattern matching languages.
Later on, some additional functions that are typical for each
individual model will be introduced.
.SH 2.3. "Description methods for pattern matching"
.PP
Before we embark on our attempt to compare both models, 
it is necessary to select appropriate semantic description tools.
Four methods are discussed:
.IP SET: 6
patterns are characterized by the (possibly infinite)
set of strings recognized by them.
.IP ALG: 6
patterns are described by algebraic transformations on (subject, cursor) values.
.IP COR: 6
patterns are described by collections of recursive coroutines
.IP OPS: 6
patterns are described by operational semantics.
.SH 2.3.1. "Patterns defined by sets of strings"
.PP
SET is the oldest method for describing patterns and
was used during the design of \s-2SNOBOL\s03
[Farber64].
It is possible to view patterns as generative grammars and
to associate a set of strings with every pattern constructed
from simple strings by sequentiation and alternation.
This method has several disadvantages.
A first difficulty stems from the fact that
alternation is not commutative, i.e. it applies its left and right
operands in left-to-right order.
(This could be repaired by using \fBordered\fP sets of string.)
.PP
More severe difficulties arise, however, with several primitive patterns.
It is extremely difficult, if not impossible, to associate a unique set of
strings with patterns containing
primitives like \fIPOS\fR\^(\fIn\fR), \fITAB\fR\^(\fIn\fR) or \fIBREAK\fR\^(\fIs\fR), since the strings
that are matched by such primitives depend on the patterns in which they occur.
.SH 2.3.2. "Patterns defined by algebraic transformations"
.PP
This method (based on [Gimpel73] and [Stewart75])
describes the meaning of a pattern as an algebraic transformation
of (subject string, cursor) values.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The meaning 
.ps 9
.ft 2
.ds 12 "M
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " of a pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is defined by a function 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPP\|\f1)\fP
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "c\|\f1)\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ",
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "where 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is the subject string and 
.ps 9
.ft 2
.ds 12 "c
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is an integer indexing 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "c
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is called the \fBpre-cursor\fP position.
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The value of 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPP\|\f1)\fP
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fPc\|\f1)\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is an ordered sequence of integers, indexing 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ",
.ps \n(99
.ft \n(98
\*(11
which are called the respective \fBpost-cursor positions\fP.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Cursor positions can take on the values 
.ps 9
.ft 2
.ds 12 "\f10\fP\f1,\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f11\fP
.as 12 "\*(13
.ds 13 ",\ .\ .\ .\ ,\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "length\|\f1(\fPS\|\f1)\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ",
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "where 
.ps 9
.ft 2
.ds 12 "length\|\f1(\fPS\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " denotes the length of the subject string 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
As soon as the meaning of the elementary scanning functions has been
expressed in terms of transformations on sequences of pre-cursor values
to sequences of post-cursor values, one can simply use composition of
cursor sequences to define the meaning of arbitrary patterns.
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "For instance, the meaning of a string literal 
.ps 9
.ft 2
.ds 12 "T
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " can be described by
.ps \n(99
.ft \n(98
\*(11
.DS
.{{
\fIM\fR\^(\fIT\fR\|)\^(\fIS\fR,\fIc\fR) =  \jg\fBif\fR \jh\fIsubstring\fR\^(\fIS\fR,\fIc\fR,\fIlength\fR\^(\fIT\fR\|)) = \fIT\fR
\h'|\ngu'\fBthen\fR
\h'|\nhu'{\fIc\fR+\fIlength\fR\^(\fIT\fR\|)}
\h'|\ngu'\fBelse\fR
\h'|\nhu'{}
\h'|\ngu'\fBfi\fR \jh.
.}}
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "In other words, take a substring from 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ", starting at cursor position 
.ps 9
.ft 2
.ds 12 "c
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ",
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "that has the same length as 
.ps 9
.ft 2
.ds 12 "T
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "If such a substring exists and it is equal to 
.ps 9
.ft 2
.ds 12 "T
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ",
.ps \n(99
.ft \n(98
\*(11
the string literal is said to match and the result is the
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "post-cursor sequence 
.ps 9
.ft 2
.ds 12 "{
.ds 13 "c\|\(pllength\|\f1(\fPT\|\f1)\fP
.as 12 "\*(13
.ds 13 "}
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ", i.e. the cursor moved past string 
.ps 9
.ft 2
.ds 12 "T
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
Otherwise the match fails and this is indicated by the empty
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "post-cursor sequence 
.ps 9
.ft 2
.ds 12 "{}
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Alternation of patterns 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " can be described by
.ps \n(99
.ft \n(98
\*(11
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPP
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\|\f1|\fP\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "P
.ds 14 "\f12\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.as 12 "\*(13
.ds 13 "\f1)\fP
.as 12 "\*(13
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fPc\|\f1)\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "M\|\f1(\fPP
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.as 12 "\*(13
.ds 13 "\f1)\fP
.as 12 "\*(13
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fPc\|\f1)\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\*(sc
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "M\|\f1(\fPP
.ds 14 "\f12\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.as 12 "\*(13
.ds 13 "\f1)\fP
.as 12 "\*(13
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fPc\|\f1)\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.DE
where \*(sc denotes the concatenation of two sequences.
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Subsequentiation of patterns 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " can be described by
.ps \n(99
.ft \n(98
\*(11
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPP
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 13 "\ 
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "\(mi\h'-0.2m'\(mi
.ps 9
.ft 2
.ds 12 "\ 
.ds 13 "P
.ds 14 "\f12\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.as 12 "\*(13
.ds 13 "\f1)\fP
.as 12 "\*(13
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fPc\|\f1)\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "M\|\f1(\fPP
.ds 14 "\f12\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.as 12 "\*(13
.ds 13 "\f1)\fP
.as 12 "\*(13
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "M\|\f1(\fPP
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.as 12 "\*(13
.ds 13 "\f1)\fP
.as 12 "\*(13
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "c\|\f1)\fP\f1)\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " .
.ps \n(99
.ft \n(98
\*(11
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "It is tacitly assumed here that 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPP\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " has been generalized so as to
.ps \n(99
.ft \n(98
\*(11
operate on cursor sequences, i.e.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "the function 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPP\|\f1)\fP\f1:\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "S
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(mu
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "N
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(->
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f12\fP
.ds 14 "N
.as 13 \v'-21u'\s-3\*(14\s+3\|\v'21u'
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " has been generalized
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "to 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPP\|\f1)\fP\f1:\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "S
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(mu
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f12\fP
.ds 14 "N
.as 13 \v'-21u'\s-3\*(14\s+3\|\v'21u'
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(->
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f12\fP
.ds 14 "N
.as 13 \v'-21u'\s-3\*(14\s+3\|\v'21u'
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ",
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "where 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " denotes the set of subject strings and 
.ps 9
.ft 2
.ds 12 "N
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " denotes the natural numbers.
.ps \n(99
.ft \n(98
\*(11
.PP
We now apply these definitions in an example.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "If 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " are defined by
.ps \n(99
.ft \n(98
\*(11
.DS
\fIP\fR = \(fm\fI\h'-0.1m'ab\fR\^\(fm | \(fm\fI\h'-0.1m'aab\fR\^\(fm | \(fm\fI\h'-0.1m'a\fR\^\(fm
\fIS\fR = \(fm\fI\h'-0.1m'aab\fR\^\(fm
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "then the application of pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " to the string 
.ps 9
.ft 2
.ds 12 "S
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " can be characterized by
.ps \n(99
.ft \n(98
\*(11
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPP\|\f1)\fP
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f10\fP\f1)\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{
.as 12 "\*(13
.ds 13 "\f13\fP\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f11\fP
.as 12 "\*(13
.ds 13 "}
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPP\|\f1)\fP
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f11\fP\f1)\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{
.as 12 "\*(13
.ds 13 "\f13\fP\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f12\fP
.as 12 "\*(13
.ds 13 "}
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPP\|\f1)\fP
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f12\fP\f1)\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{}
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPP\|\f1)\fP
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f13\fP\f1)\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{}
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.DE
Continuing in the same spirit, one can give concise definitions for
the elementary scanning functions as defined in Chapter 1:
.DS L
.ta 22n 25n
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPLEN\|\f1(\fPn\|\f1)\fP\f1)\fP
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "c\|\f1)\fP
.as 12 "\*(13
.ds 13 "\t
.as 12 "\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\t
.as 12 "\*(13
.ft 3
.ds 13 "if
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "c
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(pl
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "n
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(<=
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "length\|\f1(\fPS\|\f1)\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ft 3
.ds 13 "then
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{
.as 12 "\*(13
.ds 13 "c
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(pl
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "n
.as 12 "\*(13
.ds 13 "}
.as 12 "\|\*(13
.ds 13 "\ 
.as 12 "\*(13
.ft 3
.ds 13 "else
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{}
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ft 3
.ds 13 "fi
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPPOS\|\f1(\fPn\|\f1)\fP\f1)\fP
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "c\|\f1)\fP
.as 12 "\*(13
.ds 13 "\t
.as 12 "\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\t
.as 12 "\*(13
.ft 3
.ds 13 "if
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "c
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "n
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ft 3
.ds 13 "then
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{
.as 12 "\*(13
.ds 13 "c
.as 12 "\*(13
.ds 13 "}
.as 12 "\|\*(13
.ds 13 "\ 
.as 12 "\*(13
.ft 3
.ds 13 "else
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{
.as 12 "\*(13
.ds 13 "}
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ft 3
.ds 13 "fi
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPRPOS\|\f1(\fPn\|\f1)\fP\f1)\fP
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "c\|\f1)\fP
.as 12 "\*(13
.ds 13 "\t
.as 12 "\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\t
.as 12 "\*(13
.ft 3
.ds 13 "if
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "n
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "length\|\f1(\fPS\|\f1)\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(mi
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "c
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ft 3
.ds 13 "then
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{
.as 12 "\*(13
.ds 13 "c
.as 12 "\*(13
.ds 13 "}
.as 12 "\|\*(13
.ds 13 "\ 
.as 12 "\*(13
.ft 3
.ds 13 "else
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{
.as 12 "\*(13
.ds 13 "}
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ft 3
.ds 13 "fi
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPTAB\|\f1(\fPn\|\f1)\fP\f1)\fP
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "c\|\f1)\fP
.as 12 "\*(13
.ds 13 "\t
.as 12 "\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\t
.as 12 "\*(13
.ft 3
.ds 13 "if
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "n
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(>=
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "c
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\*(an
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "n
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(<=
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "length\|\f1(\fPS\|\f1)\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ft 3
.ds 13 "then
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{
.as 12 "\*(13
.ds 13 "n
.as 12 "\*(13
.ds 13 "}
.as 12 "\|\*(13
.ds 13 "\ 
.as 12 "\*(13
.ft 3
.ds 13 "else
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{
.as 12 "\*(13
.ds 13 "}
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ft 3
.ds 13 "fi
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "M\|\f1(\fPRTAB\|\f1(\fPn\|\f1)\fP\f1)\fP
.ds 13 "\|
.as 12 "\*(13
.ds 13 "\f1(\fPS\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "c\|\f1)\fP
.as 12 "\*(13
.ds 13 "\t
.as 12 "\*(13
.ds 13 "\(eq
.as 12 "\*(13
.ds 13 "\t
.as 12 "\*(13
.ft 3
.ds 13 "if
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "length\|\f1(\fPS\|\f1)\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(mi
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "n
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(>=
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "c
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\*(an
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "n
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(<=
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "length\|\f1(\fPS\|\f1)\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "\t
.ds 13 "\t
.as 12 "\*(13
.ft 3
.ds 13 "then
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{
.as 12 "\*(13
.ds 13 "length\|\f1(\fPS\|\f1)\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(mi
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "n
.as 12 "\*(13
.ds 13 "}
.as 12 "\|\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "\t
.ds 13 "\t
.as 12 "\*(13
.ft 3
.ds 13 "else
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{
.as 12 "\*(13
.ds 13 "}
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "\t
.ds 13 "\t
.as 12 "\*(13
.ft 3
.ds 13 "fi
.ds 13 \f3\*(13\f2
.ft 2
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.DE
.PP
This method is suited to the description of the
recognition properties of patterns but it does not lend itself to the
description of side-effects occurring during a pattern match.
.SH 2.3.3. "Patterns defined by recursive coroutines"
.PP
SL5 is a language that provides programmable backtracking based on recursive coroutines.
For a description of this method the reader is referred to
[Doyle75],
[Druseikis75]
or [Griswold76].
The latter reference also contains an overview of SL5.
There is a straightforward relationship between SL5 coroutines and
the more familiar detach/resume operations in \s-2SIMULA\s0 [Dahl70].
SL5 has been used to describe patterns:
a separate coroutine is associated with each component in the pattern
and signaling between coroutines is used to
control the pattern matching process.
.PP
The recursive coroutine method is powerful in that it allows the
description of both the recognition process itself as well as the side-effects
caused by it.
Although the primitives used are powerful, they are not generally known
and rather complex,
and this would lead us to the undesirable situation
that a complex problem would have to be described
using complex primitives.
We therefore explore a much simpler description method.
.SH 2.3.4. "Patterns defined by operational semantics"
.PP
The previous methods are either based on high-level
concepts (coroutines) or do not address the problems of environment
modification during a pattern match.
In this section we shall develop a description technique
based on an operational method for defining the semantics of programming languages.
In this way we obtain a precise, operational definition of
pattern matching semantics
which is not based on complex primitives but nevertheless
completely describes all aspects of pattern matching.
.PP
To describe a pattern matching model completely
two entities must be specified:
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 ".IP 
.ps 9
.ft 2
.ds 12 "PAT
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " 6
.ps \n(99
.ft \n(98
\*(11
A grammar describing all patterns.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 ".IP 
.ps 9
.ft 2
.ds 12 "match
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " 6
.ps \n(99
.ft \n(98
\*(11
A function describing the meaning of those patterns.
.LP
To structure the following discussion we further identify:
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 ".IP 
.ps 9
.ft 2
.ds 12 "EXP
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " 6
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "A subset of 
.ps 9
.ft 2
.ds 12 "PAT
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " containing
.ps \n(99
.ft \n(98
\*(11
the syntax rules that describe the expressions that may occur in a pattern.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 ".IP 
.ps 9
.ft 2
.ds 12 "eval
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " 6
.ps \n(99
.ft \n(98
\*(11
A function describing the meaning of expressions.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Obviously, 
.ps 9
.ft 2
.ds 12 "eval
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " may be considered as an auxiliary function of 
.ps 9
.ft 2
.ds 12 "match
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.LP
In the next section
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "the functions 
.ps 9
.ft 2
.ds 12 "match
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "eval
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " will be described in a simple, but powerful
.ps \n(99
.ft \n(98
\*(11
programming language.
.SH 2.4. "A comparison of two backtracking models"
.SH 2.4.1 "Common definitions for the two models"
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Some global variables are shared by 
.ps 9
.ft 2
.ds 12 "PAT
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ", 
.ps 9
.ft 2
.ds 12 "match
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ", 
.ps 9
.ft 2
.ds 12 "EXP
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "eval
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
It is not essential to do so, but it makes the resulting descriptions more concise.
This global information consists of:
.IP \fIsubject\*_string\fR: 6
.br
the current subject string for each pattern matching process being described.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "For convenience, we introduce the set 
.ps 9
.ft 2
.ds 12 "CURS
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
of legal indices (i.e. cursor positions) in the current subject string.
.IP \fIINITIAL\*_ENV\fR: 6
.br
the program environment (i.e. the values of variables)
at the start of the pattern matching process.
.IP \fICURRENT\*_ENV\fR: 6
.br
the initial environment modified by expressions evaluated during the
pattern match.
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Environments consist of 
.ps 9
.ft 2
.ds 12 "\f1(\fPname\|\f1,\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "value\|\f1)\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " pairs and for reasons of simplicity
.ps \n(99
.ft \n(98
\*(11
we assume here that all names are global.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "An identifier 
.ps 9
.ft 2
.ds 12 "id
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " with value 
.ps 9
.ft 2
.ds 12 "val
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is added to environment 
.ps 9
.ft 2
.ds 12 "ENV
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " by the operation:
.ps \n(99
.ft \n(98
\*(11
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "ENV.bind\|\f1(\fPid\|\f1,\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "val\|\f1)\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " .
.ps \n(99
.ft \n(98
\*(11
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "If 
.ps 9
.ft 2
.ds 12 "id
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " occurred already as the name-part in some pair
.ps \n(99
.ft \n(98
\*(11
in that environment, only the value-part of that pair is modified.
The value associated with an identifier \fIid\fR in the environment \fIENV\fR
is retrieved by:
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "ENV.binding\|\f1(\fPid\|\f1)\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " .
.ps \n(99
.ft \n(98
\*(11
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "We require 
.ps 9
.ft 2
.ds 12 "id
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " to be the name-part of some pair in 
.ps 9
.ft 2
.ds 12 "ENV
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
Finally, complete environments can be copied by the operation
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "ENV
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f1:\fP\(eq
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "copy\|\f1(\fPENV
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.as 12 "\*(13
.ds 13 "\f1)\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "which assigns a copy of environment 
.ps 9
.ft 2
.ds 12 "ENV
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " to 
.ps 9
.ft 2
.ds 12 "ENV
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Another aspect common to both models is the expression language 
.ps 9
.ft 2
.ds 12 "EXP
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "In the remainder of this paragraph, 
.ps 9
.ft 2
.ds 12 "EXP
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
and its formal definition will be explained.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The syntax
.ps 9
.ft 2
.ds 12 "
.ds 13 "\f11\fP
.as 12 \v'-21u'\s-3\*(13\s+3\v'21u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.FS
1) See 6.1 for a definition of the syntax notation used.
.FE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "of 
.ps 9
.ft 2
.ds 12 "EXP
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is given by:
.ps \n(99
.ft \n(98
\*(11
.DS L
.<<
\*<expression\*>       \jg::= { \*<assignment\*> \(fm\fI;\fR\^\(fm }\v'0.25m'*\v'-0.25m' .
.\fIsp\fR 0.5
\*<assignment\*>\h'|\ngu'::= \*<identifier\*> \(fm\fI:=\fR\^\(fm \*<right-hand-side\*> .
.\fIsp\fR 0.5
\*<right-hand-side\*>\h'|\ngu'::= \*<string-literal\*> | \*<identifier\*> [ \(fm\fI+\fR\^\(fm  \jh\*<string-literal\*> ] .
.>>
.DE
An \*<expression\*> thus consists of zero or more \*<assignment\*>s \fBseparated\fP by semicolons.
Each \*<assignment\*> consists of an \*<identifier\*> followed by
an assignment operator (`:=') and a \*<right-hand-side\*>.
A \*<right-hand-side\*> consists either of a \*<string-literal\*>, an \*<identifier\*>,
or an \*<identifier\*> followed by a plus sign followed by a \*<string-literal\*>.
.PP
The semantics of \*<expression\*>s is as follows.
The \*<assignment\*>s in an \*<expression\*> are treated from left to right.
An \*<assignment\*> can have
three different kinds of \*<right-hand-side\*>:
.sp 0.5
.IP "Case 1:" 12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\*<identifier\*>
.ps 9
.ft 2
.ds 12 "
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " := \*<identifier\*>
.ps 9
.ft 2
.ds 12 "
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ":
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\&`Bind' the value of \*<identifier\*>
.ps 9
.ft 2
.ds 12 "
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " to \*<identifier\*>
.ps 9
.ft 2
.ds 12 "
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
in the current environment.
.IP "Case 2:" 12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "\*<identifier\*>
.ps 9
.ft 2
.ds 12 "
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " := \*<identifier\*>
.ps 9
.ft 2
.ds 12 "
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " + \*<string-literal\*>:
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Concatenate the (string) value of \*<identifier\*>
.ps 9
.ft 2
.ds 12 "
.ds 13 "\f12\fP
.as 12 \v'9u'\s-3\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and
.ps \n(99
.ft \n(98
\*(11
the \*<string-literal\*> to obtain a new string value.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "This new string value is bound to \*<identifier\*>
.ps 9
.ft 2
.ds 12 "
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\*(13\s+3\v'-9u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " in the current environment.
.ps \n(99
.ft \n(98
\*(11
.IP "Case 3:" 12
\*<identifier\*> := \*<string-literal\*>:
The \*<string-literal\*> is bound to \*<identifier\*> in the current environment.
.sp 0.5
.LP
For instance, the evaluation of the expression
.DS
.{{
\fIx\fR:=\(fm\fI\h'-0.1m'abc\fR\^\(fm;\fIy\fR:=\fIx\fR;\fIz\fR:=\fIy\fR+\(fm\fI\h'-0.1m'def\^\fR\^\(fm
.}}
.DE
will add the pairs \z( \jg\fIx\fR,\(fm\fI\h'-0.1m'abc\fR\^\(fm\^), \z( \jg\fIy\fR,\(fm\fI\h'-0.1m'abc\fR\^\(fm\^) and \z( \jg\fIz\fR,\(fm\fI\h'-0.1m'abcdef\^\fR\^\(fm\^) to
the current environment (provided that no previous bindings
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "existed for the variables 
.ps 9
.ft 2
.ds 12 "x
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ", 
.ps 9
.ft 2
.ds 12 "y
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "z
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ").
.ps \n(99
.ft \n(98
\*(11
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The formal definition of the semantics of 
.ps 9
.ft 2
.ds 12 "EXP
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is given
.ps \n(99
.ft \n(98
\*(11
in Figure 2.1.
The notation for formal definitions as used there will be used throughout.
Its most unusual feature are the
\fBparse expression\fPs of the form
.DS
\&\(fm\fI{{\fR\^\(fm \*<identifier\*> \*`=\h'-0.3m'=\*' \*<syntax-rule\*> \(fm\fI}}\fR\^\(fm .
.DE
These parse the string value of a given identifier
and at the same time extract substrings from it.
To this end, parts of the \*<syntax-rule\*> can be labelled with tags.
Each tag corresponds to a variable declared elsewhere in the program
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "(such as 
.ps 9
.ft 2
.ds 12 "exprs
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "id\|\f11\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " in the above definition)
.ps \n(99
.ft \n(98
\*(11
and upon a successful parse of the string value,
each such variable receives, as value,
the substring recognized by the part of the syntax rule following the tag.
If the tag labels a repetitive syntax construct
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "(as with 
.ps 9
.ft 2
.ds 12 "exprs
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " above), the corresponding variable
.ps \n(99
.ft \n(98
\*(11
receives an array of strings (one string for each repetition of the construct)
as value.
Obviously, parse expressions can succeed or fail.
If it is known in advance that a parse expression will always succeed
(as is the case in the lines marked with \*#a\*# and \*#b\*#
in Figure 2.1),
the expression need not be
contained in an if-statement and can be used for the sole
purpose of extracting substrings.
.PP
Our notation is fully described in part II of this monograph and
an informal description can be found in Chapter 4.
In the following sections we assume it to be self-explanatory.
.KF
.sp 2
.D{
.so match/match1.so
.D}
.ce 1
\s-1\fBFigure 2.1\fP. Formal definition of \fIeval\fP.\s0
.sp 2
.KE
.br
.ne 8
.SH 2.4.2. "The immediate/conditional model"
.SH 2.4.2.1. "Overview" -
.PP
In this model (a generalization of the \s-2SNOBOL\s04 model) the moment at
which operations are performed can be controlled
at the programming language level.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The meaning of the functions 
.ps 9
.ft 2
.ds 12 "act
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " (action)
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "and 
.ps 9
.ft 2
.ds 12 "sbas
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " (subject assignment) may depend on the moment they are carried out.
.ps \n(99
.ft \n(98
\*(11
There are two versions of these functions.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The \fBimmediate\fP versions 
.ps 9
.ft 2
.ds 12 "imact
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "imsbas
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
are performed at the moment they are encountered during the pattern match;
the global environment is neither saved nor restored on failure.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The \fBconditional\fP versions 
.ps 9
.ft 2
.ds 12 "cdact
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "cdsbas
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
are remembered when they are encountered during the pattern match
but are performed only after the successful completion of
the complete pattern match.
Remembered conditional functions are forgotten if the pattern match fails.
.PP
Conditional functions do not
add recognition power, because only immediate modifications of the environment 
can influence the direction in which the recognition process proceeds.
The recognition power of pattern matching is thus based on 
the existence and power of immediate functions.
One can, for instance, build context dependent patterns
by combining (immediate) subject assignment and unevaluated expressions.
.PP
An example may illustrate why it is, in principle, desirable to use
such a powerful model.
.PP
Suppose pattern matching is used to parse a program.
Parsing of certain constructs in the program, like variable declarations,
must have an immediate effect on the parsing of the remainder of the program.
Later occurrences of variables can then be compared with their declaration.
.PP
Immediate operations allow the recognition of context-sensitive languages.
One way of recognizing the (context-sensitive) language
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "A
.ds 13 "n
.as 12 \v'-21u'\s-3\|\*(13\s+3\|\v'21u'
.ds 13 "B
.ds 14 "n
.as 13 \v'-21u'\s-3\|\*(14\s+3\|\v'21u'
.as 12 "\*(13
.ds 13 "C
.ds 14 "n
.as 13 \v'-21u'\s-3\|\*(14\s+3\|\v'21u'
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is:
.ps 9
.ft 2
.ds 12 "
.ds 13 "\f12\fP
.as 12 \v'-21u'\s-3\*(13\s+3\v'21u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.FS
2) In order to present a non-trivial example,
we have taken the liberty of using a slightly more
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "powerful 
.ps 9
.ft 2
.ds 12 "EXP
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " language than defined in 2.4.1;
.ps \n(99
.ft \n(98
\*(11
\*<right-hand-side\*>s consisting of function calls and
functions (like \fIlength\fR and \fIreplicate\fR) were not defined
there but have an obvious meaning.
.FE
.DS L
.{{
\fIrow\*_of\*_A\fR  \jg:=  \jh\(fm\fI\h'-0.1m'A\fR\^\(fm \(mi\h'-0.2m'\(mi \v'0.25m'*\v'-0.25m'\fIrow\*_of\*_A\fR | \(fm\fI\fR\^\(fm ;
.br
\fIabc\fR\h'|\ngu':=\h'|\nhu'\fIimsbas\fR\^(\fIrow\*_of\*_A\fR,\fIas\fR) \(mi\h'-0.2m'\(mi \fIimact\fR\^(\fIn\fR:=\fIlength\fR\^(\fIas\fR)) \(mi\h'-0.2m'\(mi
.br
\h'|\nhu'\v'0.25m'*\v'-0.25m'\fIreplicate\fR\^(\(fm\fI\h'-0.1m'B\fR\^\(fm,\fIn\fR) \(mi\h'-0.2m'\(mi \v'0.25m'*\v'-0.25m'\fIreplicate\fR\^(\(fm\fI\h'-0.1m'C\fR\^\(fm,\fIn\fR) ;
.}}
.DE
Here, \fIrow\*_of\*_A\fR recognizes arbitrarily long sequences
of \(fm\fI\h'-0.1m'A\fR\^\(fms.
Pattern \fIabc\fR first attempts to recognize a row of \(fm\fI\h'-0.1m'A\fR\^\(fms which
is immediately assigned to variable \fIas\fR.
Next, the length of \fIas\fR is computed and assigned to variable \fIn\fR.
Finally, two new patterns are constructed (and attempted) consisting
of \fIn\fR \(fm\fI\h'-0.1m'B\fR\^\(fms and \fIn\fR \(fm\fI\h'-0.1m'C\fR\^\(fms respectively.
.PP
The above example illustrates the usefulness of immediate operations.
But under which circumstances is it desirable to perform operations conditionally?
An extreme example is in the code generation phase of a compiler:
all code generation operations would be remembered until the whole program
had been parsed.
After the program was found to be syntactically correct, the code generation
operations would be carried out.
If, on the other hand, syntax errors were detected, all
code generation operations would be discarded.
A less extreme example is the parsing of (locally) ambiguous
or non-LL(1) languages.
If a construct can be identified only after having
been parsed in its entirety, it may be necessary to postpone
all operations associated with it until that time.
This may, for instance, arise in a language allowing multiply labelled statements:
in that case an identifier is either the next label or the beginning of the
actual statement.
The same phenomenon also occurs for case statements allowing
an arbitrary number of expressions to be associated with each case.
.PP
We now list some advantages and disadvantages of the immediate/conditional model.
The advantages are:
.IP \*(MK
Information about failure can be passed to higher levels;
it is thus possible to construct patterns that do not require rescanning
of the subject string.
.IP \*(MK
The programmer has explicit control over the moment operations are performed.
This is also a disadvantage however, since it complicates the model.
.IP \*(MK
The model can be implemented efficiently.
.LP
Disadvantages of the immediate/conditional model are:
.IP \*(MK
Mixing of conditional and immediate operations is problematical.
First, the program text no longer reflects the order of events, which
greatly reduces its readability.
Secondly (and worse), conditional operations are performed in the
environment as it exists at the end of the successful pattern match in
which they occur.
This is the price paid for an efficient implementation: the environment is
not saved when a conditional operation is encountered during the pattern match.
Consider, for example:
.DS L
.{{
\fIP\fR := \(fm\fI\h'-0.1m'ab\fR\^\(fm\(mi\h'-0.2m'\(mi\fIimact\fR\^(\fIn\fR:=\(fm\fI\h'-0.1m'X\fR\^\(fm\^)\(mi\h'-0.2m'\(mi\(fm\fI\h'-0.1m'c\fR\^\(fm\(mi\h'-0.2m'\(mi\fIcdact\fR\^(\fIres\fR:=\fIn\fR)\(mi\h'-0.2m'\(mi\fIimact\fR\^(\fIn\fR:=\fIn\fR+\(fm\fI\h'-0.1m'Y\fR\^\(fm\^);
.}}
.DE
During the pattern match \(fm\fI\h'-0.1m'abc\fR\^\(fm ? \fIP\fR the following steps are performed:
.RS
.IP 1)
The string \(fm\fI\h'-0.1m'ab\fR\^\(fm is recognized.
.IP 2)
The operation \fIn\fR:=\(fm\fI\h'-0.1m'X\fR\^\(fm is performed.
.IP 3)
The string \(fm\fI\h'-0.1m'c\fR\^\(fm is matched.
.IP 4)
The operation \fIres\fR:=\fIn\fR is remembered.
.IP 5)
The operation \fIn\fR:=\fIn\fR+\(fm\fI\h'-0.1m'Y\fR\^\(fm is performed.
This amounts to assigning the string \(fm\fI\h'-0.1m'XY\fR\^\(fm to variable \fIn\fR.
.IP 6)
The pattern match succeeds and all remembered operations
(in this example only \fIres\fR:=\fIn\fR)
are performed in left to right order.
.LP
Variable \fIres\fR thus receives \(fm\fI\h'-0.1m'XY\fR\^\(fm as final value, but \(fm\fI\h'-0.1m'X\fR\^\(fm instead
of \(fm\fI\h'-0.1m'XY\fR\^\(fm would in many respects have been a more reasonable outcome.
.RE
.IP \*(MK
Each implementation of the immediate/conditional model
has to solve the non-trivial problem of not imposing
restrictions on the number of simultaneously remembered conditional operations.
If an implementation does impose such restrictions,
it may not be possible to perform pattern matches in which large numbers
of conditional operations occur
(such as compiling a whole program in one pattern match).
In practice, this would have the highly undesirable effect of forcing
the programmer to use immediate operations exclusively and of
seriously limiting the usefulness of the backtracking facility.
.IP \*(MK
It is not visible whether a pattern
modifies the global environment on failure or not.
.PP
A final illustration of the intricacies
of the immediate/conditional model follows.
Considering
.DS
.{{
\fIx\fR   \jg:= \(fm\fI\h'-0.1m'A\fR\^\(fm; \fIy\fR := \(fm\fI\h'-0.1m'B\fR\^\(fm;
\fIp1\fR\h'|\ngu':= \(fm\fI\h'-0.1m'a\fR\^\(fm\(mi\h'-0.2m'\(mi\fIimact\fR\^(\fIx\fR:=\fIx\fR+\(fm\fI\h'-0.1m'X\fR\^\(fm\^) | \(fm\fI\h'-0.1m'ab\fR\^\(fm\(mi\h'-0.2m'\(mi\fIcdact\fR\^(\fIx\fR:=\fIx\fR+\fIy\fR);
\fIp2\fR\h'|\ngu':= \fIimact\fR\^(\^\fIy\fR:=\fIy\fR+\(fm\fI\h'-0.1m'Y\fR\^\(fm\^)\(mi\h'-0.2m'\(mi\(fm\fI\h'-0.1m'c\fR\^\(fm;
\fIp\fR\h'|\ngu':= \fIp1\fR \(mi\h'-0.2m'\(mi \fIp2\fR;
.}}
.DE
the match \(fm\fI\h'-0.1m'abc\fR\^\(fm ? \fIp\fR
succeeds and results in \fIx\fR = \(fm\fI\h'-0.1m'AXBYY\fR\^\(fm, \fIy\fR = \(fm\fI\h'-0.1m'BYY\fR\^\(fm,
while \(fm\fI\h'-0.1m'aef\^\fR\^\(fm ? \fIp\fR
fails and results in \fIx\fR = \(fm\fI\h'-0.1m'AX\fR\^\(fm, \fIy\fR = \(fm\fI\h'-0.1m'BY\fR\^\(fm.
These results are baroque, to say the least.
.SH 2.4.2.2. "Formal description" -
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "In the immediate/conditional model, the grammar 
.ps 9
.ft 2
.ds 12 "PAT
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is described by
.ps \n(99
.ft \n(98
\*(11
the syntax rules:
.sp 1
.<<
\*<pattern\*> ::= \*<pattern-primary\*> [ ( \(fm\fI|\fR\^\(fm | \(fm\fI\(mi\h'-0.2m'\(mi\fR\^\(fm ) \*<pattern-primary\*> ] .
.\fIsp\fR 0.5
\*<pattern-primary\*> ::=
        \jg\(fm\fI\z( \jh\fR\^\(fm \*<pattern\*> \(fm\fI)\fR\^\(fm |
\h'|\ngu'\*<string-literal\*> |
\h'|\ngu'\*<identifier\*> |
\h'|\ngu'\(fm\fI\v'0.25m'*\v'-0.25m'\fR\^\(fm \*<identifier\*> |
\h'|\ngu'\*<compound\*> |
\h'|\ngu'\s-2IMSBAS\s0 \ji\(fm\fI\z( \jh\fR\^\(fm \*<pattern-primary\*> \(fm\fI,\fR\^\(fm \*<identifier\*> \(fm\fI)\fR\^\(fm |
\h'|\ngu'\s-2CDSBAS\s0 \ji\(fm\fI\z( \jh\fR\^\(fm \*<pattern-primary\*> \(fm\fI,\fR\^\(fm \*<identifier\*> \(fm\fI)\fR\^\(fm |
\h'|\ngu'\s-2IMACT\s0 \jj\(fm\fI\z( \jh\fR\^\(fm \*<expression\*> \(fm\fI)\fR\^\(fm |
\h'|\ngu'\s-2CDACT\s0 \jj\(fm\fI\z( \jh\fR\^\(fm \*<expression\*> \(fm\fI)\fR\^\(fm .
.\fIsp\fR 0.5
\*<compound\*> ::= \(fm\fI<\fR\^\(fm \*<integer-constant\*> \(fm\fI,\fR\^\(fm \*<expression\*> \(fm\fI,\fR\^\(fm \*<pattern\*> \(fm\fI>\fR\^\(fm.
.>>
.sp 1
In order to simplify the formal definition, we assume
without loss of generality, that all syntactic ambiguities are eliminated
by the proper use of parentheses,
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "e.g. 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\|\f1|\fP\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\f1(\fP\f1(\fPQ\|\(mi\(miR\|\f1)\fP\(mi\(miS\|\f1)\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " should be used instead of 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\|\f1|\fP\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "Q\|\(mi\(miR\|\(mi\(miS
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
In the examples, the non-parenthesized version will be used
(for better readability) and the operator `\(mi\h'-0.2m'\(mi' is assumed to have higher
priority than the operator `|'.
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Roughly speaking, the state a pattern match is in is fully
.ps 9
.ft 2
.ds 12 "
.ds 13 "\f13\fP
.as 12 \v'-21u'\s-3\*(13\s+3\v'21u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.FS
3) The existence of the global variables \fIsubject\*_string\fR,
\fIINITIAL\*_ENV\fR and \fICURRENT\*_ENV\fR is not considered here.
.FE
specified by the following three parameters:
.IP \*(MK
The pattern that has to match in order
to complete the pattern match successfully.
.IP \*(MK
The cursor position in the subject string where the above
pattern should match.
.IP \*(MK
An expression that is equivalent to all remembered conditional operations.
Evaluating this expression has the same effect as evaluating
all remembered conditional operations in left to right order.
.LP
The meaning of a pattern can now be expressed in terms of its effects
on the above three entities.
.br
.ne 5
.PP
More formally, the semantics of patterns is given by the function
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "match\|\f1:\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "CURS
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(mu
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "EXP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(mu
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "PAT
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(->
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "CURS
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(mu
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "EXP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(mu
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "PAT
.ds 14 "\f10\fP
.as 13 \v'-21u'\s-3\|\*(14\s+3\v'21u'
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\(cu
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "FAIL
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "where 
.ps 9
.ft 2
.ds 12 "PAT
.ds 13 "\f10\fP
.as 12 \v'-21u'\s-3\|\*(13\s+3\v'21u'
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is equal to 
.ps 9
.ft 2
.ds 12 "PAT
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\(cu
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "{
.as 12 "\*(13
.ds 13 "null
.as 12 "\*(13
.ds 13 "}
.as 12 "\|\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " and 
.ps 9
.ft 2
.ds 12 "null
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is the
.ps \n(99
.ft \n(98
\*(11
pattern that always fails.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Note that 
.ps 9
.ft 2
.ds 12 "null
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " can only come into existence as the result of applying 
.ps 9
.ft 2
.ds 12 "match
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ",
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "but that 
.ps 9
.ft 2
.ds 12 "match
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is not defined on it.
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "match
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " attempts to transform the (cursor, expression, pattern)
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "triple 
.ps 9
.ft 2
.ds 12 "\f1(\fPC\|\f1,\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "E\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "P\|\f1)\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " into a new triple 
.ps 9
.ft 2
.ds 12 "\f1(\fPC\f2\(fm\fP\|\f1,\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "E\f2\(fm\fP\|\f1,\fP
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "P\f2\(fm\fP\|\f1)\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " as follows.
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "If pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " matches successfully, the cursor is moved to 
.ps 9
.ft 2
.ds 12 "C\f2\(fm\fP
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ",
.ps \n(99
.ft \n(98
\*(11
all conditional operations performed during this part of the match are
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "appended to expression 
.ps 9
.ft 2
.ds 12 "E
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " (resulting in 
.ps 9
.ft 2
.ds 12 "E\f2\(fm\fP
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "), and 
.ps 9
.ft 2
.ds 12 "P\f2\(fm\fP
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is a pattern
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "consisting of all untried alternatives of 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "If 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " fails, 
.ps 9
.ft 2
.ds 12 "match
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " should deliver the value 
.ps 9
.ft 2
.ds 12 "FAIL
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The function 
.ps 9
.ft 2
.ds 12 "match
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " to be described below achieves this by
.ps \n(99
.ft \n(98
\*(11
performing an \fIfreturn\fR (failure return) operation.
This is equivalent to returning the Boolean value \fIfalse\fR which can
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "subsequently be tested for by the caller of 
.ps 9
.ft 2
.ds 12 "match
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.PP
Apart from \*<compound\*>s,
all notions in the grammar given above correspond to some primitive pattern.
An implicit semantic property of the immediate/conditional model made
it, however, necessary to add a new type of pattern:
As was illustrated previously,
attempting `untried alternatives' of a pattern requires a mechanism
to restore a previous state of the pattern match.
To achieve this, \*<compound\*>s have been introduced
as explicit representations of the pattern matching state.
.PP
The formal definition uses several auxiliary functions.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Functions like \fImk\*_alt\fR and \fImk\*_comp\fR construct new elements of 
.ps 9
.ft 2
.ds 12 "PAT
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
from given components.
For example, let \fIsubject\*_string\fR have \(fm\fI\h'-0.1m'abcdef\^\fR\^\(fm as value, then
.DS
.{{
\fIp\fR := \fImk\*_string\fR\^(0,3);
\fIq\fR := \fImk\*_string\fR\^(3,6);
\fIa\fR := \fImk\*_alt\fR\^(\^\fIp\fR, \fIq\fR);
.}}
.DE
will assign the pattern \(fm\fI\h'-0.1m'abc\fR\^\(fm|\(fm\fI\h'-0.1m'def\^\fR\^\(fm to \fIa\fR.
The correspondence between such functions and the alternatives in the grammar
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 9
.ft 2
.ds 12 "PAT
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is:
.ps \n(99
.ft \n(98
\*(11
.DS
.{{
\fImk\*_alt\fR\^(\^\fIp\fR,\fIq\fR)             \jg\(->   \jh\fIp\fR | \fIq\fR
\fImk\*_subs\fR\^(\^\fIp\fR,\fIq\fR)\h'|\ngu'\(->\h'|\nhu'\fIp\fR \(mi\h'-0.2m'\(mi \fIq\fR
\fImk\*_comp\fR\^(\fIc\fR,\fIe\fR,\fIp\fR)\h'|\ngu'\(->\h'|\nhu'<\fIc\fR,\fIe\fR,\fIp\fR>
\fImk\*_string\fR\^(\|\|\fIfrom\fR,\fIto\fR)\h'|\ngu'\(->\h'|\nhu'\*<string-literal\*>
\fImk\*_cdsbas\fR\^(\^\fIp\fR,\fIid\fR\|)\h'|\ngu'\(->\h'|\nhu'\fIcdsbas\fR\^(\^\fIp\fR,\fIid\fR\|)
\fImk\*_imsbas\fR\^(\^\fIp\fR,\fIid\fR\|)\h'|\ngu'\(->\h'|\nhu'\fIimsbas\fR\^(\^\fIp\fR,\fIid\fR\|)
.}}
.DE
Note that \fImk\*_string\fR constructs a new string
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "by extracting the characters with indices 
.ps 9
.ft 2
.ds 12 "\^f\|rom\|\f1,\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\^f\|rom\|\(pl\f11\fP
.as 12 "\*(13
.ds 13 ",\ .\ .\ .\ ,\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "to\|\(mi\f11\fP
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
from the global \fIsubject\*_string\fR.
Also note that \fImk\*_alt\fR,
\fImk\*_subs\fR, \fImk\*_comp\fR, \fImk\*_imsbas\fR and \fImk\*_cdsbas\fR
do not construct a new pattern if one
of their arguments is \fInull\fR, e.g.
.DS
.{{
\fImk\*_alt\fR\^(\^\fIp\fR,\fInull\fR\|)          \jg\(->   \jh\fIp\fR
\fImk\*_alt\fR\^(\fInull\fR,\fIq\fR)\h'|\ngu'\(->\h'|\nhu'\fIq\fR
\fImk\*_subs\fR\^(\^\fIp\fR,\fInull\fR\|)\h'|\ngu'\(->\h'|\nhu'\fInull\fR
\fImk\*_subs\fR\^(\fInull\fR,\fIq\fR)\h'|\ngu'\(->\h'|\nhu'\fInull\fR
\fImk\*_comp\fR\^(\fIc\fR,\fIe\fR,\fInull\fR\|)\h'|\ngu'\(->\h'|\nhu'\fInull\fR
\fImk\*_imsbas\fR\^(\fInull\fR,\fIid\fR\|)\h'|\ngu'\(->\h'|\nhu'\fInull\fR
\fImk\*_cdsbas\fR\^(\fInull\fR,\fIid\fR\|)\h'|\ngu'\(->\h'|\nhu'\fInull\fR
.}}
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "Similar functions exist for the grammar 
.ps 9
.ft 2
.ds 12 "EXP
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ":
.ps \n(99
.ft \n(98
\*(11
.DS
.{{
\fImk\*_assign\fR\^(\fIid\fR,\fIv\fR)         \jg\(->   \jh\fIid\fR := \fIv\fR
\fImk\*_expr\fR\^(\fIe1\fR,\fIe2\fR)\h'|\ngu'\(->\h'|\nhu'\fIe1\fR ; \fIe2\fR
.}}
.DE
These functions are used to construct `remembered expressions'
as required for the modeling of conditional subject assignment (see below).
.PP
We now present the formal definition followed by a detailed explanation.
.sp 1
.D{
.so match/pat-ic1.so
.D}
.sp 1
The cases \*#a\*# to \*#l\*# correspond to the various alternatives
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "in the grammar 
.ps 9
.ft 2
.ds 12 "PAT
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
Each case will now be discussed in more detail:
.LP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "a)\ If the pattern is an alternation of the form 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\|\f1|\fP\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "Q
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ",
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "an attempt is first made to match the pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
If successful, it delivers a new cursor, expression and pattern.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The new cursor value corresponds to the point to which the pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
has proceeded in the subject string.
The new expression consists of the old expression augmented by
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "the conditional operations encountered during the evaluation of 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The new pattern (
.ps 9
.ft 2
.ds 12 "P\|\f11\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ") corresponds to the remaining (untried) alternatives of 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "The pattern 
.ps 9
.ft 2
.ds 12 "P\|\f11\fP
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "\|\f1|\fP\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "Q
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is delivered by the evaluation of 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\|\f1|\fP\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "Q
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "If the match of 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " fails, an attempt is made to match 
.ps 9
.ft 2
.ds 12 "Q
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "If the latter fails, 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\|\f1|\fP\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "Q
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " fails.
.ps \n(99
.ft \n(98
\*(11
If it succeeds, again, a new cursor, expression and pattern are delivered.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "In this case the pattern 
.ps 9
.ft 2
.ds 12 "Q\|\f11\fP
.ds 12 \x'0'\f2\s9\*(12\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is delivered by the evaluation of 
.ps 9
.ft 2
.ds 12 "P
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\|\f1|\fP\|
.as 12 "\*(13
.ds 13 "\ 
.as 12 "\*(13
.ds 13 "Q
.as 12 "\*(13
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
.LP
b)\ If the pattern is a subsequentiation of the form \fIP\fR \(mi\h'-0.2m'\(mi \fIQ\fR,
the operations performed are of a similar nature
as the ones performed for alternation.
.LP
c)\ If the pattern consists of a pattern enclosed in parentheses,
the enclosed pattern is attempted.
.LP
d)\ If the pattern is a \*<string-literal\*>, it should
occur in the subject string, starting at the current cursor position.
This is taken care of by the function \fIlitmatch\fR\^(\fIs\fR).
If, for example, the subject string is \(fm\fI\h'-0.1m'abcd\^\fR\^\(fm,
then \fIlitmatch\fR\^(1,\(fm\fI\h'-0.1m'bc\fR\^\(fm\^)
will deliver the value 3, while \fIlitmatch\fR\^(2,\(fm\fI\h'-0.1m'bc\fR\^\(fm\^) will fail.
.LP
e)\ If the pattern is an \*<identifier\*>, the corresponding value in the
\fBinitial environment\fP is used as pattern.
In this way the notion of \fBpattern construction\fP,
as it exists, for example, in \s-2SNOBOL\s04 is modeled.
Before a pattern match starts, the expression describing the pattern
is used to build a data structure which is subsequently used
to control the recognition process.
In the formal description, this is reflected by the use of the initial
values of the variables occurring in the pattern.
.LP
f)\ If the pattern is an unevaluated expression of the form \v'0.25m'*\v'-0.25m'\fIx\fR,
the value of \fIx\fR in the current environment is used as pattern.
This introduces the possibility of context sensitive patterns,
that are modified dynamically during the pattern match.
.LP
g)\ It was already explained above that
\*<compound-pattern\*>s are a way of representing the pattern matching state.
They consist of a cursor value, an expression
describing remembered conditional operations, and a pattern.
Evaluation of a \*<compound-pattern\*> amounts to evaluating
its pattern component, starting at its cursor value.
The role of the expression component is further explained
in points i) and k) below.
.LP
h)\ If the pattern is an immediate subject assignment of the form \fIimsbas\fR\^(\fIP\fR,\fIx\fR),
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "an attempt is made to match pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
If this is successful, the part of the subject
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "recognized by 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " is immediately assigned to variable \fIx\fR.
.ps \n(99
.ft \n(98
\*(11
.LP
i)\ If the pattern is a conditional subject assignment of the form \fIcdsbas\fR\^(\fIP\fR,\fIx\fR),
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "an attempt is made to match pattern 
.ps 9
.ft 2
.ds 12 "P
.ds 12 \x'0'\f2\s9\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 ".
.ps \n(99
.ft \n(98
\*(11
If this is successful, an assignment statement is constructed
that will eventually (i.e. at the end of the pattern match)
assign the recognized part of the subject string to variable \fIx\fR.
.LP
j)\ If the pattern is an immediate action, it is evaluated.
.LP
k)\ If the pattern is a conditional action, it is appended
to the current list of conditional operations.
.LP
l)\ In all other cases the pattern is syntactically incorrect.
.PP
It is instructive to trace the series of events taking place
during a simple pattern match (see Figure 2.2).
For reasons of readability, arguments and results that are equal to the empty string
are denoted by a single space character.
.KF
.sp 2
.DS I 4c
.so match/examp.so
.DE
.ce 1
\s-1\fBFigure 2.2\fP. Trace of pattern match \(fm\fI\h'-0.1m'abe\fR\^\(fm ? (\(fm\fI\h'-0.1m'a\fR\^\(fm|\(fm\fI\h'-0.1m'ab\fR\^\(fm\^)\(mi\h'-0.2m'\(mi\(fm\fI\h'-0.1m'e\fR\^\(fm.\s0
.sp 2
.KE
.SH 2.4.3. "The recovery model"
.SH 2.4.3.1. "Overview" -
.PP
This new model was inspired by the concept of recovery blocks.
In [Randell75] it is shown how
the reliability of a program can be increased by inserting
\fBacceptance tests\fP at appropriate places in the program.
Whenever such a test fails, the program state is restored to a state
at a previous well-defined point, and an attempt is
made to perform the same computation using an alternative algorithm.
This process is repeated until either the result
satisfies the acceptance test or no more alternative algorithms are available.
In the latter case, the failure has to be handled at a higher, more global,
level in the program.
To this end the program is split up into (nested) recovery blocks.
Each recovery block starts with a `begin of recovery block' statement
indicating that a roll-back to this point may take place,
and ends with an acceptance test.
The body of the recovery block consists of the various alternative algorithms
to be tried.
.PP
This approach clearly bears a certain resemblance to backtracking.
Given the problems with the immediate/conditional model,
two further observations led to the idea that backtracking could be
completely replaced by the recovery block method:
.IP \*(MK
It is desirable for the programmer to have complete control over the scope of backtracking.
.IP \*(MK
A failing pattern component should only be allowed to change the local
(innermost) but not the global environment.
In this way, the side-effects of failing patterns can be localized.
.LP
It is possible to interpret the recovery model in such a way that the
above two requirements are satisfied and that the disadvantages of the
immediate/conditional model disappear.
First, alternation and subsequentiation are stripped of their capability
to remember untried alternatives.
Secondly, a single operation is defined for the control of both
backtracking and environment modification.
For this purpose the construction:
.EQ I
.nr 99 \n(.s
.nr 98 \n(.f
.ps 9
.ft 2
.ft 3
.ds 11 "try
.ds 11 \f3\*(11\f2
.ft 2
.ds 12 "\ 
.as 11 "\*(12
.ds 12 "<id
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.as 11 "\*(12
.ds 12 "\ 
.as 11 "\*(12
.ds 12 ",\ .\ .\ .\ ,\|
.as 11 "\*(12
.ds 12 "\ 
.as 11 "\*(12
.ds 12 "id
.ds 13 "n
.as 12 \v'9u'\s-3\*(13\s+3\|\v'-9u'
.as 11 "\*(12
.ds 12 ">
.as 11 "\*(12
.ds 12 "\ 
.as 11 "\*(12
.ds 12 "p
.ds 13 "\f11\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.as 11 "\*(12
.ds 12 "\ 
.as 11 "\*(12
.ds 12 ",\ .\ .\ .\ ,\|
.as 11 "\*(12
.ds 12 "\ 
.as 11 "\*(12
.ds 12 "p
.ds 13 "m
.as 12 \v'9u'\s-3\*(13\s+3\|\v'-9u'
.as 11 "\*(12
.ds 12 "\ 
.as 11 "\*(12
.ft 3
.ds 12 "until
.ds 12 \f3\*(12\f2
.ft 2
.as 11 "\*(12
.ds 12 "\ 
.as 11 "\*(12
.ds 12 "p
.ds 13 "\f10\fP
.as 12 \v'9u'\s-3\|\*(13\s+3\v'-9u'
.as 11 "\*(12
.ds 12 "\ 
.as 11 "\*(12
.ft 3
.ds 12 "yrt
.ds 12 \f3\*(12\f2
.ft 2
.as 11 "\*(12
.ds 11 \x'0'\f2\s9\*(11\s\n(99\f\n(98
.nr 11 \w'\*(11'
.nr MK 0
.if 63>\n(.v .ne 63u
.rn 11 10
\*(10
.ps \n(99
.ft \n(98
.EN
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "is introduced, where 
.ps 9
.ft 2
.ds 13 "p
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "p
.ds 15 "m
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " are patterns to be tried successively
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "and 
.ps 9
.ft 2
.ds 13 "p
.ds 14 "\f10\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is a pattern to be applied after the successful matching of
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "one of the patterns 
.ps 9
.ft 2
.ds 13 "p
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "p
.ds 15 "m
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ".
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "If 
.ps 9
.ft 2
.ds 13 "p
.ds 14 "\f10\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\f1,\fP
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "p
.ds 15 "\f11\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "p
.ds 15 "m
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " fail, the environment is restored to the state it was in
.ps \n(99
.ft \n(98
\*(12
at the moment the \fBtry\fR construction was entered,
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "\fBexcept for the values of the variables\fP 
.ps 9
.ft 2
.ds 13 "id
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "id
.ds 15 "n
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ".
.ps \n(99
.ft \n(98
\*(12
These variables can be used as a communication channel or
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "\fBwindow\fP between the patterns 
.ps 9
.ft 2
.ds 13 "p
.ds 14 "\f10\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\f1,\fP
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "p
.ds 15 "\f11\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "p
.ds 15 "m
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ".
.ps \n(99
.ft \n(98
\*(12
In this way, each alternative can inspect
information supplied by previous (necessarily unsuccessful) attempts.
Note, that the variables in the window have to be declared elsewhere;
the occurrence of a variable in a window only establishes the fact that
its value will not be recovered.
.PP
Since all language aspects related to backtracking have been
concentrated in the try construct, the
alternation and subsequentiation of patterns
(represented by `|' and `\(mi\h'-0.2m'\(mi' in the immediate/conditional model)
can now be expressed by the ordinary Boolean operators \fIand\fP and \fIor\fP.
We shall, however, continue to use the same notation
in order to make the comparison between the two models easier.
.PP
The recovery model is superior to the immediate/conditional model
in several respects:
.IP \*(MK
It is possible to save information gathered during a failing pattern match
in a way which is more structured than in the immediate/conditional model.
.IP \*(MK
It is much simpler than the immediate/conditional model:
the number of operators is smaller and no unexpected effects can occur by
mixing immediate and conditional operations.
In the immediate/conditional model the programmer has to be aware of
unwanted `backing into previous alternatives'.
Consider the pattern:
.DS L
.{{
  \jg\(fm\fI[\fR\^\(fm \(mi\h'-0.2m'\(mi
      \jh( \fIexpr\fR |
        \ji\fIimact\fR\^(\fIerror\fR:=\(fm\fI\h'-0.1m'invalid index\fR\^\(fm\^)
\h'|\nhu') \(mi\h'-0.2m'\(mi
\h'|\ngu'\(fm\fI]\fR\^\(fm
.}}
.DE
applied to the string \(fm\fI[a+b}\fR\^\(fm.
On encountering the invalid symbol `}', automatic backtracking
causes the (inappropriate) error message to be assigned to
the variable \fIerror\fR.
This cannot occur in the recovery model, since the programmer has
to ask for backtracking explicitly.
In the recovery model, one can formulate the above problem in two ways.
The error message alternative can either be discarded, leading to
.DS L
.{{
  \jg\(fm\fI[\fR\^\(fm \(mi\h'-0.2m'\(mi
      \jh( \fIexpr\fR |
        \ji\fIact\fR\^(\fIerror\fR:=\(fm\fI\h'-0.1m'invalid index\fR\^\(fm\^)
\h'|\nhu') \(mi\h'-0.2m'\(mi
\h'|\ngu'\(fm\fI]\fR\^\(fm
.}}
.DE
(where `|' is used as the ordinary Boolean \fIor\fR operator
and the action is only evaluated if \fIexpr\fR fails),
or it can be remembered explicitly
.DS L
.{{
  \jg\(fm\fI[\fR\^\(fm \(mi\h'-0.2m'\(mi
      \jh\fBtry\fR \ji\fIexpr\fR,
\h'|\niu'\fIact\fR\^(\fIerror\fR:=\(fm\fI\h'-0.1m'invalid index\fR\^\(fm\^)
\h'|\nhu'\fBuntil\fR \jj\(fm\fI]\fR\^\(fm
\h'|\nhu'\fByrt\fR
.}}
.DE
.IP \*(MK
A reasonably efficient implementation is possible
using a \fBcache\fP containing the modifications to the
enclosing environment.
Such a cache mechanism evenly distributes the work of saving
and restoring the program state, i.e.
the amount of work increases in proportion to
the number of modifications to the original state.
The absence of automatic backtracking renders this implementation method feasible.
It is crucial that the beginning and end of a try construct are known
so that the period during which modifications
have to be remembered is well-defined.
.PP
An example will illustrate the main properties of the recovery model.
Consider
.DS
.{{
\fIp\fR := (\(fm\fI\h'-0.1m'a\fR\^\(fm | \(fm\fI\h'-0.1m'ab\fR\^\(fm\^) \(mi\h'-0.2m'\(mi \(fm\fI\h'-0.1m'c\fR\^\(fm .
.}}
.DE
Both \(fm\fI\h'-0.1m'abc\fR\^\(fm ? \fIp\fR and \(fm\fI\h'-0.1m'abd\^\fR\^\(fm ? \fIp\fR fail, since backtracking is not automatic.
If, on the other hand, \fIp\fR is defined by
.DS
.{{
\fIp\fR := \fBtry\fR \jg<> \(fm\fI\h'-0.1m'a\fR\^\(fm, \(fm\fI\h'-0.1m'ab\fR\^\(fm \fBuntil\fR \jh\(fm\fI\h'-0.1m'c\fR\^\(fm \fByrt\fR
.}}
.DE
then \(fm\fI\h'-0.1m'abc\fR\^\(fm ? \fIp\fR will succeed.
.SH 2.4.3.2. "Formal description" -
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "In the recovery model, the pattern language 
.ps 9
.ft 2
.ds 13 "PAT
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is described by
.ps \n(99
.ft \n(98
\*(12
the following syntax rules
.sp 0.5
.<<
\*<pattern\*> ::= \*<pattern-primary\*> [ ( \(fm\fI|\fR\^\(fm | \(fm\fI\(mi\h'-0.2m'\(mi\fR\^\(fm ) \*<pattern-primary\*> ] .
.\fIsp\fR 0.5
\*<pattern-primary\*> ::=
        \jg\(fm\fI\z( \jh\fR\^\(fm \*<pattern\*> \(fm\fI)\fR\^\(fm |
\h'|\ngu'\*<string-literal\*> |
\h'|\ngu'\*<identifier\*> |
\h'|\ngu'\(fm\fI\v'0.25m'*\v'-0.25m'\fR\^\(fm \*<identifier\*> |
\h'|\ngu'\s-2SBAS\s0 \ji\(fm\fI\z( \jh\fR\^\(fm \*<pattern-primary\*> \(fm\fI,\fR\^\(fm \*<identifier\*> \(fm\fI)\fR\^\(fm |
\h'|\ngu'\s-2ACT\s0  \ji\(fm\fI\z( \jh\fR\^\(fm \*<expression\*> \(fm\fI)\fR\^\(fm |
\h'|\ngu'\s-2TRY\s0 \jj\*<window\*> {\*<pattern\*> \(fm\fI,\fR\^\(fm}+ \s-2UNTIL\s0 \jk\*<pattern\*> \s-2YRT\s0 \jl.
.\fIsp\fR 0.5
\*<window\*> ::=  \jm\(fm\fI<\fR\^\(fm { \*<identifier\*> \(fm\fI,\fR\^\(fm }\v'0.25m'*\v'-0.25m' \(fm\fI>\fR\^\(fm .
.>>
.sp 0.5
The syntax rules for \*<expression\*>s and their meaning have already been
described in Section 2.4.1.
The semantics of patterns is described by the function
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "match\|\f1:\fP
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "CURS
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(mu
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "PAT
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(->
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "CURS
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(cu
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "FAIL
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ".
.ps \n(99
.ft \n(98
\*(12
.DE
This function attempts to match a given pattern starting at a given
cursor position and delivers a new cursor position.
In contrast to the immediate/conditional model,
it is not necessary to accumulate expressions describing conditional
operations, nor to remember untried alternatives.
We now present the semantics of pattern matching in the recovery model.
.sp 1
.D{
.so match/pat-rc1.so
.D}
.sp 1
Cases \*#c\*#, \*#d\*#, \*#e\*#, \*#f\*#, \*#g\*#, \*#h\*# and \*#j\*#
have direct counterparts in
the immediate/conditional model
and need no further explanation.
Only the remaining cases will be discussed.
.LP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "a)\ If the pattern is an alternation of the form 
.ps 9
.ft 2
.ds 13 "P
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\|\f1|\fP\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "Q
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ",
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "P
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is attempted first.
.ps \n(99
.ft \n(98
\*(12
If successful, the new cursor value is returned.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "If not successful, 
.ps 9
.ft 2
.ds 13 "Q
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is attempted.
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "Again, if 
.ps 9
.ft 2
.ds 13 "Q
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is successful, the cursor delivered by 
.ps 9
.ft 2
.ds 13 "Q
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is returned.
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "In all other cases 
.ps 9
.ft 2
.ds 13 "P
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\|\f1|\fP\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "Q
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " fails.
.ps \n(99
.ft \n(98
\*(12
It is interesting to compare the simplicity of this alternation
operator with the much more complex alternation operator in the
immediate/conditional model.
.LP
b)\ If the pattern is a subsequentiation, it is handled in a similar fashion.
Again, compare this operator with its counterpart in the immediate/conditional model.
.LP
i)\ If the pattern is a \fBtry\fR construct of the form
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ft 3
.ds 13 "try
.ds 13 \f3\*(13\f2
.ft 2
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "<id
.ds 15 "\f11\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "id
.ds 15 "n
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 14 ">
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "p
.ds 15 "\f11\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "p
.ds 15 "m
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ft 3
.ds 14 "until
.ds 14 \f3\*(14\f2
.ft 2
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "p
.ds 15 "\f10\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ft 3
.ds 14 "yrt
.ds 14 \f3\*(14\f2
.ft 2
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.DE
the current environment is copied first.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "The patterns 
.ps 9
.ft 2
.ds 13 "p
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "p
.ds 15 "m
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " are attempted next from left to right.
.ps \n(99
.ft \n(98
\*(12
If one of them matches \fBand\fP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "p
.ds 14 "\f10\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " matches, the try construct as a whole succeeds.
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "When either one of 
.ps 9
.ft 2
.ds 13 "p
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "p
.ds 15 "m
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " fails or 
.ps 9
.ft 2
.ds 13 "p
.ds 14 "\f10\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " fails, the environment
.ps \n(99
.ft \n(98
\*(12
is restored \fBexcept\fP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "for the variables 
.ps 9
.ft 2
.ds 13 "id
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "id
.ds 15 "n
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " whose values are retained.
.ps \n(99
.ft \n(98
\*(12
It is assumed here that all variables in the window have a well-defined
value at the moment the try construct is entered.
.SH 2.5. "Unification of pattern and expression language"
.PP
In the preceding sections a careful analysis was made of two backtracking models.
By choosing the right primitive operations we were able to develop a simple,
but powerful backtracking method.
Is it possible to introduce further simplifications?
To do this, we first explicitly formulate our basic assumptions:
.IP \*(MK
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "A pattern matching model is characterized by a language 
.ps 9
.ft 2
.ds 13 "PAT
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " of patterns
.ps \n(99
.ft \n(98
\*(12
(with associated definition function \fImatch\fR)
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "and a language 
.ps 9
.ft 2
.ds 13 "EXP
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " of expressions (with associated definition function \fIeval\fR).
.ps \n(99
.ft \n(98
\*(12
.IP \*(MK
The definition function \fImatch\fR assumes the existence of a subject string
and keeps track of the progress of the match by means of an integer-valued cursor.
The only assumption regarding the data type of the subject string is made
by the function \fIlitmatch\fR that does the actual string matching.
.LP
These assumptions immediately lead to two guidelines for making
further simplifications:
.IP \*(MK
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "Unify the languages 
.ps 9
.ft 2
.ds 13 "EXP
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and 
.ps 9
.ft 2
.ds 13 "PAT
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ".
.ps \n(99
.ft \n(98
\*(12
.IP \*(MK
Remove all dependencies on strings as the domain of pattern matching.
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "The unification of the languages 
.ps 9
.ft 2
.ds 13 "EXP
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and 
.ps 9
.ft 2
.ds 13 "PAT
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " amounts to removing the
.ps \n(99
.ft \n(98
\*(12
\fBlinguistic dichotomy\fP
in pattern matching languages, so eloquently described in [Griswold80].
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "This unification can be achieved by eliminating the language 
.ps 9
.ft 2
.ds 13 "PAT
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " completely.
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "This is done by modeling all operations in 
.ps 9
.ft 2
.ds 13 "PAT
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " by operations in 
.ps 9
.ft 2
.ds 13 "EXP
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "and by extending 
.ps 9
.ft 2
.ds 13 "EXP
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " when necessary in the process.
.ps \n(99
.ft \n(98
\*(12
Typical examples of this modeling are:
.DS I
.ta 4c 5c
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "Operation in 
.ps 9
.ft 2
.ds 13 "PAT
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ":		Modeled in 
.ps 9
.ft 2
.ds 13 "EXP
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " by:
.ps \n(99
.ft \n(98
\*(12

pattern match fails	\(->	add success/fail
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "or succeeds		mechanism to 
.ps 9
.ft 2
.ds 13 "EXP
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ".
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "string-literal	\(->	
.ps 9
.ft 2
.ds 13 "lit
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "(string-literal),
.ps \n(99
.ft \n(98
\*(12
		where \fIlit\fR is a built-in string
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "		matching procedure defined in 
.ps 9
.ft 2
.ds 13 "EXP
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ".
.ps \n(99
.ft \n(98
\*(12
alternation	\(->	Boolean \fIor\fR.
subsequentiation	\(->	Boolean \fIand\fR.
action	\(->	expression.
unevaluated expression	\(->	procedure call.
subject assignment	\(->	ordinary assignment.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "try construct	\(->	add try construct to 
.ps 9
.ft 2
.ds 13 "EXP
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ".
.ps \n(99
.ft \n(98
\*(12
.DE
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "It is surprising that this redefinition of 
.ps 9
.ft 2
.ds 13 "EXP
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " also
.ps \n(99
.ft \n(98
\*(12
eliminates all dependencies on string pattern matching:
the special role played by the subject string and cursor is no longer cared for
and the recovery mechanism (embodied in the try construct)
is sufficiently powerful that it permits
the saving and restoring of variables with arbitrary values.
Such variables could be used to describe the progress
of a pattern match in some arbitrary, user-defined, domain.
.PP
These ideas form the conceptual basis for subsequent chapters.
.SH 2.6. "References for Chapter 2"
.so refs/Dahl70
.so refs/Druseikis75
.so refs/Doyle75
.so refs/Farber64
.so refs/Gimpel73
.so refs/Griswold71
.so refs/Griswold76
.so refs/Griswold80
.so refs/Randell75
.so refs/Stewart75

.EC

.NC 3 "AN OVERVIEW OF THE" "SUMMER PROGRAMMING LANGUAGE"
.ds LH "OVERVIEW OF SUMMER
.SH 3.1. Introduction
.PP
The language \s-2SUMMER\s0 has been designed for the solution of problems
in text processing and string manipulation.
It consists of a relatively small kernel
which has been extended in several directions.
The kernel supports:
.IP \*(MK
integers
.IP \*(MK
strings
.IP \*(MK
classes
.IP \*(MK
procedure and operator definitions
.IP \*(MK
success-directed evaluation
.IP \*(MK
control structures
.IP \*(MK
recovery of side-effects.
.LP
It has been extended with:
.IP \*(MK
reals
.IP \*(MK
files
.IP \*(MK
arrays (sequences of values)
.IP \*(MK
tables (associative memories)
.IP \*(MK
pattern matching
.IP \*(MK
string synthesis.
.PP
Pattern matching has been completely integrated
with the success-directed expression evaluation mechanism.
It will be shown that the operations in the kernel are sufficient to allow
generalization of pattern matching in two directions:
.IP \*(MK
Simultaneous pattern matches can be expressed, which mutually
affect each other.
.IP \*(MK
Pattern matching can be generalized to domains other than strings.
.PP
In the following sections the novel
features of \s-2SUMMER\s0 and the motivation for their inclusion in the language
will be discussed.
Furthermore, a simplified version of the pattern matching extension is
described in some detail.
.SH 3.2. "Success-directed evaluation and control structures"
.PP
The expression evaluation mechanism of \s-2SUMMER\s0 is somewhat unusual and merits
special attention.
Expressions consist of a juxtaposition of operators
(like the addition operator: `+' or the string concatenation operator: `||')
and operands (like the numeric constant 10,
the string constant \(fm\fI\h'-0.1m'abc\fR\^\(fm,
the identifier \fIx\fR or the procedure call \fIp\fR\^(10,\fIx\fR)).
Some operations can deliver only a value, but others can potentially \fBfail\fP.
The syntactic form of an expression completely determines the steps to be
taken when an operation in a subexpression fails.
The evaluation of simple expressions like
.DS
.{{
\fIa\fR + \fIfibonacci\fR\^(7)
\fIx\fR := \fIduplicate\fR\^(\fIc\fR, 3) || \(fm\fI times\fR\^\(fm
\fIx\fR > \fIy\fR
\fIx\fR := \fIduplicate\fR\^(\fIan\*_identifier\fR\^(\fIs\fR), 5)
.}}
.DE
is aborted immediately when an operation in a subexpression fails
and failure is signalled to constructs surrounding the expression.
In the last example, failure of the expression \fIan\*_identifier\fR\^(\fIs\fR)
may abort evaluation of the whole expression before \fIduplicate\fR
even gets called.
Note that failure is a transient entity and must be captured at the moment
it occurs.
The evaluation of more complex constructs in the case of a failing subexpression
depends again completely on the syntactic form of each construct.
There are three cases:
.IP 1)
The construct is capable of handling the failure itself.
This is the case if the failing expression \fIE\fR occurs in contexts like:
.DS I
.ta 4c
\fBif\fR \jg\fIE\fR \fBthen\fR \jh.\ .\ . \fBelse\fR \ji.\ .\ . \fBfi\fR
\fBwhile\fR \jg\fIE\fR \fBdo\fR \jh.\ .\ . \fBod\fR
\fIE\fR | .\ .\ .	{Boolean (McCarthy) \fIor\fP operator}
.DE
.IP 2)
The construct is not capable of handling the failure itself, but
is (perhaps dynamically) enclosed in a construct with that capability, like:
.DS I
.ta 4c
\fIE\fR & .\ .\ .	{Boolean (McCarthy) \fIand\fP operator}
\fIreturn\fR\^(\fIE\fR)	{return value from a procedure}
.DE
In this way failure can be passed to the caller of the procedure
in which the failing expression occurs (see below).
.IP 3)
Neither of the above two cases applies.
This results in abnormal program termination with
the error message `Unanticipated failure'.
In
.DS I
.{{
\fIx\fR := \fIread\fR\^(\fIinput\fR); \fIprint\fR\^(\fIx\fR);
.}}
.DE
the call to the read procedure may fail (on end of file).
This failure will not be detected by the program itself and hence
execution of the program will be aborted.
.PP
This expression evaluation scheme was designed to be
concise and powerful, but at the same time an attempt was made to
protect the programmer against unanticipated or unwanted failure.
.PP
\fBConciseness\fP is obtained in two ways.
.PP
In the first place, by computing a value and a failure signal in the same expression.
This allows, for example
.DS I
.{{
\fBwhile\fR \jg\fIline\fR := \fIread\fR\^(\fIinput\fR) \fBdo\fR \jh.\ .\ . \fBod\fR
.}}
.DE
instead of
.DS I
.{{
\fBwhile\fR \jg\(ap\fIeof\fR\|\|(\fIinput\fR)
\fBdo\fR \jh\fIline\fR := \fIread\fR\^(\fIinput\fR);
\h'|\nhu'\fBif\fR \jg\fIio\*_errors\fR\^(\fIinput\fR) \fBthen\fR \ji.\ .\ . \fBfi\fR;
\h'|\nhu'.\ .\ .
\fBod\fR;
.}}
.DE
.PP
Secondly, by disregarding the \fBsource of failure\fP and focusing attention
on the \fBabsence of failure\fP (i.e. success)
during the evaluation of the expression.
From now on we will use `succeeds' as a synonym for `does not fail and delivers
a value'.
Consider:
.DS I
.{{
\fBif\fR \jg(\fIread\fR\^(\fIinput\fR) || \fIread\fR\^(\fIinput\fR)) \(ap\h'-0.2m'= \fIexpected\fR
\fBthen\fR
\h'|\ngu'\fIerror\fR\^(\(fm\fI\h'-0.1m'Bad input\fR\^\(fm\^)
\fBfi\fR
.}}
.DE
where `\(ap\h'-0.2m'=' denotes the inequality comparison between strings and
\fIexpected\fR has the expected input string as value.
Three sources of failure can be identified here:
the two read operations and the inequality test can fail.
The programmer, however, is in most cases interested only in the fact
that the input file does not conform to his expectations.
This is more manifest in the above formulation than in:
.DS I
.{{
\fIl1\fR := \fIread\fR\^(\fIinput\fR);
\fBif\fR \jg\fIeof\fR\|\|(\fIinput\fR)
\fBthen\fR
\h'|\ngu'\fIerror\fR\^(\(fm\fI\h'-0.1m'Bad input\fR\^\(fm\^)
\fBelse\fR
\h'|\ngu'\fIl2\fR := \fIread\fR\^(\fIinput\fR);
\h'|\ngu'\fBif\fR \jh\fIeof\fR\|\|(\fIinput\fR) | (\fIl1\fR || \fIl2\fR \(ap\h'-0.2m'= \fIexpected\fR\|)
\h'|\ngu'\fBthen\fR
\h'|\nhu'\fIerror\fR\^(\(fm\fI\h'-0.1m'Bad input\fR\^\(fm\^)
\h'|\ngu'\fBfi\fR
\fBfi\fR
.}}
.DE
In principle, this argument works in two directions:
since the source of failure may be lost, the programmer
may be misled about the \fBactual\fP source of failure.
It is our experience that this seldom happens, and in all cases where the
distinction \fBis\fP important, it can be expressed easily.
.PP
\fBProtection\fP is achieved by prohibiting unanticipated failure.
This turns out to be a frequent source of run-time errors,
which always correspond to `forgotten' or `impossible' failure conditions.
A direct consequence of this protection scheme is that one can write
\fBassertions\fP (i.e. expressions which should never fail) in a program.
A run-time error occurs if such an assertion is false.
.PP
Another noteworthy consequence of this evaluation mechanism is its
ability to let a procedure report failure to any procedure which
called it (in)directly.
This effect is obtained by adhering to the programming convention
that procedure bodies have the form
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "E
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "&
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\v'-.3m'\ .\ .\ .\ \v'.3m'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "&
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "E
.ds 15 "n
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ".
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "If one of the expressions 
.ps 9
.ft 2
.ds 13 "E
.ds 14 "i
.as 13 \v'9u'\s-3\*(14\s+3\|\v'-9u'
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " fails, this failure is passed to
.ps \n(99
.ft \n(98
\*(12
the caller of the current procedure.
If that calling procedure has the same form,
it will not itself handle the failure but pass it on to its caller.
In this way, low-level procedures need not be aware of failure at all
and high-level procedures can detect the failure and take
appropriate measures.
Some programming languages (e.g. \s-2ADA\s0, \s-2CLU\s0)
have special facilities for handling
exceptions of this kind;
in \s-2SUMMER\s0 they can be handled by the standard expression evaluation
mechanism.
.SH 3.3. "Recovery of side-effects"
.PP
For the solution of problems such as heuristic searching, or parsing
languages with context-sensitive or non-LL(1) grammars,
it is often necessary to \fBattempt\fP
a solution and to recover from its side-effects
if that attempt is not successful.
Many schemes have been proposed for the formulation of such \fBbacktracking\fP
algorithms, but most involve either opaque control structures or
allow unsatisfactory control over modifications of the program
state (i.e. global variables).
.PP
S\s-2UMMER\s0 provides a special language construct for recovering from the side-effects
caused by the evaluation of a failing expression.
This construct has the form
.DS I
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ft 3
.ds 13 "try
.ds 13 \f3\*(13\f2
.ft 2
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "E
.ds 15 "\f11\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\f1,\fP
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "E
.ds 15 "\f12\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "E
.ds 15 "n
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ft 3
.ds 14 "until
.ds 14 \f3\*(14\f2
.ft 2
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "E
.ds 15 "\f10\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ft 3
.ds 14 "yrt
.ds 14 \f3\*(14\f2
.ft 2
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.DE
and is, to a first approximation, equivalent to
.DS I
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "\f1(\fPE
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "&
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "E
.ds 15 "\f10\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\f1)\fP
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\|\f1|\fP\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\v'-.3m'\ .\ .\ .\ \v'.3m'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\|\f1|\fP\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\f1(\fPE
.ds 15 "n
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "&
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "E
.ds 15 "\f10\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\f1)\fP
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "Before the evaluation of each 
.ps 9
.ft 2
.ds 13 "\f1(\fPE
.ds 14 "i
.as 13 \v'9u'\s-3\*(14\s+3\|\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "&
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "E
.ds 15 "\f10\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\f1)\fP
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " starts,
.ps \n(99
.ft \n(98
\*(12
the complete program state (values of all variables,
status of all input/output operations) is saved.
If the evaluation of the subexpression succeeds, the saved program state
is discarded and the try construct as a whole succeeds.
If the evaluation fails, the saved program state is restored
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "and evaluation of 
.ps 9
.ft 2
.ds 13 "\f1(\fPE
.ds 14 "i\|\(pl\f11\fP
.as 13 \v'9u'\s-3\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "&
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "E
.ds 15 "\f10\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\f1)\fP
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is attempted in a similar manner.
.ps \n(99
.ft \n(98
\*(12
The try construct fails if none of the subexpressions succeeds.
Completely automatic backtracking can be achieved by nesting try constructs.
This simple scheme is well suited to the formulation of
problems occurring in pattern matching applications
as will be seen in 3.5.2.
.PP
There are two exceptions to the rule that the whole program state
is restored when an expression contained in a try construct fails:
.IP \*(MK
Operations on an input/output stream
that corresponds to an interactive terminal
are not recovered.
In many situations it is not desirable to recover these streams,
and in some cases the meaning of such a recovery may be non-obvious
or confusing.
In \s-2SUMMER\s0 these streams can be used
to interactively control and monitor the backtracking process.
.IP \*(MK
The local variables of the procedures in which the try construct occurs
are not recovered.
In this way information about the reason for failure
can survive the failure itself.
In Sction 2.4.3 a similar effect was achieved using
a `window' of variables whose values were never recovered.
.PP
It is obvious that saving and restoring complete program states would lead to
intolerable inefficiencies when implemented naively.
Fortunately, there exists an implementation technique that eliminates
most of the run-time overhead involved.
The \fBrecovery cache\fP,
which was originally invented to increase software reliability
[Randell75],
has been adapted to act as a device for monitoring program state
modifications in those situations where it may be necessary
to restore a previous program state
(i.e. while evaluating expressions contained in a try construct).
A recovery cache consists of (name, value) pairs.
The name part may refer to simple variables, array elements,
class components or input/output streams.
A new cache is created when the evaluation of a try construct begins, and
from that moment, all assignments to variables are monitored.
Whenever an assignment is about to be made to a variable whose name does
not yet occur in the cache, its name and its old value \fBbefore\fP
the assignment are entered into the cache.
Assignments to components of structured objects (arrays, class instances) and
modifications of input/output streams are registered in a similar way.
The recovery cache is discarded completely
if the evaluation of the try construct succeeds,
but in the case of failure, the information in the cache is used to
restore the program to its state at the moment that the cache
was created (i.e. the try construct was entered).
Since recovery caches may be nested, `discarding' may mean:
merging the information in the current cache with that in the previous one.
In this manner, the information in the previous cache is still
sufficient to describe all modifications which have been made since
that cache was created.
.SH 3.4. "Procedures, operators and classes"
.PP
In this section the remaining features of the \s-2SUMMER\s0 kernel
are summarized.
.PP
\fBProcedures\fP
have a fixed number of parameters, which are, in principle, passed by value.
Procedures may either return zero or more values, or they may fail.
The former is achieved by a return-expression of the form
\fIreturn\fR or \fIreturn\fR\^(\fIexpression\fR).
The latter is achieved by a return-expression of the form \fIfreturn\fR
(failure return).
Returning a failing expression is equivalent to a failure return
(e.g. \fIreturn\fR\^(3 > 4) is equivalent to \fIfreturn\fR).
.PP
An \fBoperator\fP is defined by associating a user-defined operator symbol
with a procedure which has one or two parameters.
.PP
\fBClasses\fP are the only available data structuring mechanism
and have been inspired by the class concept in \s-2SIMULA\s0 [Dahl70].
A class declaration describes the properties of a group of related entities.
One particular entity is described by \fBinstantiating\fP
(i.e. making an \fBinstance\fP of) the class
declaration and filling in the specific properties of that entity.
For example, all entities of the class \fIperson\fP may have
a \fIname\fP and an \fIage\fP.
An individual person can be described by an instance of the class \fIperson\fP
with the appropriate details (e.g. `John', 36) filled in.
This scheme equally applies to built-in classes like \fIinteger\fR and
\fIstring\fR, as well as to user-defined classes like the class \fIperson\fR
just described.
\fBAll values in \s-2SUMMER\s0 are thus instances of some class\fP.
.PP
Nothing has so far been gained when comparing classes with, for example,
records in \s-2PASCAL\s0.
The major difference between the two stems from the fact that \s-2PASCAL\s0 records
are \fBpassive\fP
(i.e. a record resembles a variable and is only a container of values)
and \fBunprotected\fP
(i.e. all components of a record are freely accessible)
while classes are not.
A class can be considered to be \fBactive\fP, since it may contain locally
declared procedures to manipulate the information in each instance
of that class (e.g. increment a person's age)
or to perform computations based on that information.
A class is \fBprotected\fP since the access to the individual information
in the class instance is completely controlled by its class definition.
A simple definition of \fIperson\fP might be:
.DS I
.{{
\fBclass\fR \jg\fIperson\fR\^(\fIname\fR, \fIage\fR)
\fBbegin\fR \jg\fBfetch\fR \jh\fIname\fR, \fIage\fR;
\h'|\ngu'\fBstore\fR \jh\fIage\fR;
\fBend\fR \ji\fIperson\fR;
.}}
.DE
Here \fIname\fR and \fIage\fR may be used from the outside of the class instance,
but only \fIage\fR may be modified, i.e. may occur on the left hand side
of an assignment.
Some examples of the use of this class are:
.DS I
.{{
\fIfriend\fR := \fIperson\fR\^(\(fm\fI\h'-0.1m'John\fR\^\(fm, 36);
\fIprint\fR\^(\|\|\fIfriend\fR.\fIname\fR);
\fIfriend\fR.\fIage\fR := \fIfriend\fR.\fIage\fR + 1;
.}}
.DE
A more restrictive version of \fIperson\fR might be:
.DS I
.{{
\fBclass\fR \jg\fIperson\fR\^(\fIname\fR, \fIage\fR)
\fBbegin\fR \jg\fBfetch\fR \jh\fIname\fR, \fIage\fR;
\h'|\ngu'\fBstore\fR \jh\fIage\fR : \fIgrow\*_older\fR;
\h'|\ngu'\fBproc\fR \ji\fIgrow\*_older\fR\^(\fInew\*_age\fR)
\h'|\ngu'(  \jj\fBif\fR \jh\fInew\*_age\fR >= \fIage\fR
\h'|\nju'\fBthen\fR
\h'|\nhu'\fIage\fR := \fInew\*_age\fR
\h'|\nju'\fBelse\fR
\h'|\nhu'\fIprint\fR\^(\(fm\fI\h'-0.1m'Did you find the elixir of life?\fR\^\(fm\^)
\h'|\nju'\fBfi\fR
\h'|\ngu');
\fBend\fR \jk\fIperson\fR;
.}}
.DE
This definition prescribes that all assignments to \fIage\fR
are channeled through the procedure \fIgrow\*_older\fR which
ensures the monotonicity of age.
Instances of this class are used in precisely the same 
manner as in the examples given previously.
.PP
A second example of class declarations has to do with the generation 
of unique labels of the form `L1', `L2' and so on.
This might, for example, be used in a compiler.
A declaration for \fIUniqueLabel\fRs looks like:
.DS I
.{{
\fBclass\fR \jg\fIUniqueLabel\fR\^(\^\fIprefix\fR, \fIstart\fR)
\fBbegin\fR \jg\fBfetch\fR \jh\fIgenerate\fR, \fIreset\fR;
\h'|\ngu'\fBvar\fR \ji\fIprogress\fR;
\h'|\ngu'\fBproc\fR \jj\fIgenerate\fR\^(\^)
\h'|\ngu'(  \jk\fIprogress\fR := \fIprogress\fR + 1;
\h'|\nku'\fIreturn\fR\^(\^\fIprefix\fR || \fIstring\fR\^(\^\fIprogress\fR))
\h'|\ngu');
\h'|\ngu'\fBproc\fR \jj\fIreset\fR\^(\^) ( \fIprogress\fR := \fIstart\fR );
.sp 0.5
\fBinit\fR:  \jl\fIprogress\fR := \fIstart\fR
\fBend\fR \jm\fIUniqueLabel\fR;
.}}
.DE
Some applications of this class are:
.DS I
.{{
\fIL\fR := \fIUniqueLabel\fR\^(\(fm\fI\h'-0.1m'L000\fR\^\(fm, \(mi1);
\fIM\fR := \fIUniqueLabel\fR\^(\(fm\fI\h'-0.1m'M\fR\^\(fm, 10);
\fIprint\fR\^(\fIM\fR.\fIgenerate\fR);	\*# prints `M11' \jg\*#
\fIprint\fR\^(\fIL\fR.\fIgenerate\fR);	\*# prints `L0000' \jh\*#
\fIprint\fR\^(\fIM\fR.\fIgenerate\fR);	\*# prints `M12' \jg\*#
\fIM\fR.\fIreset\fR;
\fIprint\fR\^(\fIM\fR.\fIgenerate\fR);	\*# prints `M11' \jg\*#
.}}
.DE
.br
.ne 5
.LP
Summarizing, a class declaration consists of:
.IP \*(MK
A class name and a list of formal parameters.
The class name is used as name for the creation procedure
for instances of the class.
The actual parameters are used to provide initial values for that instance.
.IP \*(MK
Fields, which are used either to contain information related to the instance
(e.g. the \fIname\fR and \fIage\fR fields in
an instance of the class \fIperson\fR),
or to hold information local to the class instance
(the variable \fIprogress\fR in an instance of \fIUniqueLabel\fR).
Permissions for accessing and/or modifying the fields of a class instance
from the outside have to be stated explicitly by using \fBfetch\fR and \fBstore\fR.
.LP
The fields of a class are accessed by means of the `dot' notation.
The type of the left operand in a field selection is used to
disambiguate `overloaded' fields, for which definitions occur in
more than one class.
.PP
Some additional features exist in the language to accommodate the use of classes.
In sequences like
.DS I
.{{
\fIa\fR := \fIS\fR.\fIx\fR; \fIb\fR := \fIS\fR.\fIy\fR; \fIc\fR := \fIS\fR.\fIz\fR\^(10)
.}}
.DE
it is convenient if the prefix `\fIS\fR.' can be factored out.
P\s-2ASCAL\s0 uses the construct
.DS I
\fBwith\fP \fIrecord\*_variable\fR \fBdo\fR \jg\fBbegin\fR \jh.\ .\ . \fBend\fR
.DE
for this purpose.
All field references that occur inside `\fBbegin\fR \jg.\ .\ . \fBend\fR'
are automatically prefixed with \fIrecord\*_variable\fR.
In this notation the above example would become:
.DS I
\fBwith\fP \fIS\fP \fBdo\fP \fBbegin\fR \jg\fIa\fR := \fIx\fR; \fIb\fR := \fIy\fR; \fIc\fR := \fIz\fR\^(10) \fBend\fR
.DE
Unfortunately, this is not sufficient for the applications we have in mind,
where it is not unusual for many procedures to operate on the same class
instance.
This is illustrated by a set of parsing procedures that operate
on one subject string.
The \s-2PASCAL\s0 approach has the disadvantage that this common class instance
must either be passed as an argument to all procedures involved or must be assigned to
a global variable;
all procedure bodies must in that case be enclosed
in a \fBwith\fP construct.
This problem can be circumvented as follows.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "The \s-2SUMMER\s0 construct
.ps 9
.ft 2
.ds 13 "
.ds 14 "\f12\fP
.as 13 \v'-21u'\s-3\*(14\s+3\v'21u'
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.FS
2) Inspired by the `scan S using E' construct in Icon
[Griswold79].
.FE
.DS I
.{{
\fBscan\fR \jg\fIS\fR \fBfor\fR \jh\fIE\fR \fBrof\fR
.}}
.DE
introduces a new incarnation of a common variable (`\fIsubject\fR')
each time the construct
is encountered at run-time and assigns the class instance \fIS\fR to it.
All occurrences of fields from the class to which \fIS\fR belongs are
now prefixed with the common global variable
in the same way as is done in \s-2PASCAL\s0.
The \fBscan\fP construct is more general, however, in the sense that it
not only affects \fIE\fR itself,
but also all procedures called directly or indirectly
as a result of the evaluation of \fIE\fR, while
in \s-2PASCAL\s0 the effect is restricted to the expressions which are
statically enclosed in the body of the \fBwith\fP construct.
If the scan construct is used in a nested fashion, the previous
value of the common global variable is saved and restored properly on exit from
the current scan construct.
This also applies to the case when the scan construct is left
prematurely by means of a return statement.
In summary,
the scan construct introduces a restricted form of \fBdynamic binding\fP.
.SH 3.5. "A pattern matching extension"
.SH 3.5.1. "String Pattern Matching"
.PP
We will now show how a string pattern matching system
can be build on top of the \s-2SUMMER\s0 kernel.
Pattern matching is done on a string
\fItext\fR which is indexed by an integer \fIcursor\fR.
For the sake of this discussion a very simple system will be defined,
which only supports the following operations:
.IP "\fItext\fR:" 12
Gives the value of \fItext\fR.
.IP "\fIcursor\fR:" 12
Gives the current value of \fIcursor\fR.
.IP "\fIlit\fR\^(\fIS\fR):" 12
Literally recognize the string \fIS\fR.
If \fIS\fR occurs as substring in \fItext\fR at the current cursor
position, deliver \fIS\fR as value and move the cursor beyond \fIS\fR.
Otherwise report failure.
.IP "\fIbreak\fR\^(\fIS\fR):" 12
Recognize a substring of \fItext\fR that starts
at the current cursor position and consists entirely of
characters not occurring in \fIS\fR and is followed by a
terminating character which does occur in \fIS\fR.
If such a substring exists,
return it (without the terminating character) and
move the cursor to the terminating character.
Fail if such a substring does not exist.
.IP "\fIspan\fR\^(\fIS\fR):" 12
Recognize the longest non-empty substring of \fItext\fR that starts
at the current cursor position and consists entirely of characters
which occur in \fIS\fR.
If such a substring exists, then return it as value and move the cursor
beyond it.
Fail if such a substring does not exist.
.br
.ne 8
.LP
The following class definition implements this pattern matcher:
.sp 1
.D{
.{{
\fBclass\fR \jg\fIscan\*_string\fR\^(\fItext\fR)
\fBbegin\fR \jg\fBfetch\fR \jh\fIlit\fR, \fIbreak\fR, \fIspan\fR, \fItext\fR, \fIcursor\fR;
\h'|\ngu'\fBvar\fR \ji\fIcursor\fR;
\h'|\ngu'\fBproc\fR \jj\fIlit\fR\^(\fIs\fR)
\h'|\ngu'(  \jk\fBif\fR \jh\fIcursor\fR + \fIs\fR.\fIsize\fR <= \fItext\fR.\fIsize\fR & \fItext\fR.\fIsubstr\fR\^(\fIcursor\fR, \fIs\fR.\fIsize\fR) = \fIs\fR
\h'|\nku'\fBthen\fR
\h'|\nhu'\fIcursor\fR := \fIcursor\fR + \fIs\fR.\fIsize\fR ;
\h'|\nhu'\fIreturn\fR\^(\fIs\fR)
\h'|\nku'\fBelse\fR
\h'|\nhu'\fIfreturn\fR
\h'|\nku'\fBfi\fR
\h'|\ngu');
.br
.ne 10
\h'|\ngu'\fBproc\fR \jj\fIbreak\fR\^(\fIs\fR)
\h'|\ngu'(\h'|\nku'\fBvar\fR \jl\fInewcursor\fR := \fIcursor\fR;
\h'|\nku'\fBwhile\fR \jm\fInewcursor\fR < \fItext\fR.\fIsize\fR 
\h'|\nku'\fBdo\fR \jh\fBif\fR \jm\fIcontains\fR\^(\fIs\fR, \fItext\fR\^[\fInewcursor\fR]\^)
\h'|\nhu'\fBthen\fR
\h'|\nmu'\fBvar\fR \jn\fIresult\fR := \fItext\fR.\fIsubstr\fR\^(\fIcursor\fR, \fInewcursor\fR \(mi \fIcursor\fR);
\h'|\nmu'\fIcursor\fR := \fInewcursor\fR;
\h'|\nmu'\fIreturn\fR\^(\fIresult\fR)
\h'|\nhu'\fBfi\fR;
\h'|\nhu'\fInewcursor\fR := \fInewcursor\fR + 1
\h'|\nku'\fBod\fR;
\h'|\nku'\fIfreturn\fR
\h'|\ngu');
.br
.ne 10
.sp 0.5
\h'|\ngu'\fBproc\fR \jj\fIspan\fR\^(\fIs\fR)
\h'|\ngu'(\h'|\nku'\fBvar\fR \jl\fInewcursor\fR := \fIcursor\fR;
\h'|\nku'\fBwhile\fR \jm\fInewcursor\fR < \fItext\fR.\fIsize\fR & \fIcontains\fR\^(\fIs\fR, \fItext\fR\^[\fInewcursor\fR]\^)
\h'|\nku'\fBdo\fR
\h'|\nhu'\fInewcursor\fR := \fInewcursor\fR + 1
\h'|\nku'\fBod\fR;
\h'|\nku'\fBif\fR \jh\fInewcursor\fR > \fIcursor\fR
\h'|\nku'\fBthen\fR
\h'|\nhu'\fBvar\fR \jo\fIresult\fR := \fItext\fR.\fIsubstr\fR\^(\fIcursor\fR, \fInewcursor\fR \(mi \fIcursor\fR);
\h'|\nhu'\fIcursor\fR := \fInewcursor\fR;
\h'|\nhu'\fIreturn\fR\^(\fIresult\fR)
\h'|\nku'\fBelse\fR
\h'|\nhu'\fIfreturn\fR
\h'|\nku'\fBfi\fR
\h'|\ngu');
.br
.sp 0.5
.ne 10
\h'|\ngu'\fBproc\fR \jj\fIcontains\fR\^(\fIs\fR, \fIc\fR)
\h'|\ngu'(\h'|\nku'\fBvar\fR \jl\fIc1\fR;
\h'|\nku'\fBfor\fR \jl\fIc1\fR \fBin\fR \jn\fIs\fR
\h'|\nku'\fBdo\fR
\h'|\nhu'\fBif\fR \jm\fIc1\fR = \fIc\fR \fBthen\fR \jp\fIreturn\fR \fBfi\fR;
\h'|\nku'\fBod\fR;
\h'|\nku'\fIfreturn\fR;
\h'|\ngu');
\fBinit\fR:  \jq\fIcursor\fR := 0;
\fBend\fR \jr\fIscan\*_string\fR;
.}}
.D}
.sp 0.5
The following example illustrates how identifiers starting with
the letter `\fIX\fR' can be recognized:
.sp 0.5
.D{
.{{
\fBproc\fR \jg\fIidentifier\fR\^(\fIs\fR)
\z(  \jh\fBvar\fR \ji\fIt\fR := \fIscan\*_string\fR\^(\fIs\fR);
\h'|\nhu'\fIreturn\fR\^(\fIt\fR.\fIlit\fR\^(\(fm\fI\h'-0.1m'X\fR\^\(fm\^) & (\fIt\fR.\fIspan\fR\^(\fIletter\*_or\*_digit\fR) | \fIt\fR.\fIlit\fR\^(\(fm\fI\fR\^\(fm\^)))
)
.}}
.D}
.sp 0.5
In these examples we assume
\fIletter\fR = \(fm\fI\h'-0.1m'abcdefghijklmnopqrstuvwxyz\fR\^\(fm,
\fIdigit\fR = \(fm\fI0123456789\fR\^\(fm and
\fIletter\*_or\*_digit\fR = \fIletter\fR || \fIdigit\fR.
Note that the normal Boolean operators \fIand\fP (`&') and
\fIor\fP (`|') are used
for combination.
Hence there will be no backtracking or reversal of effects if the match fails.
The expression \fIt\fR.\fIlit\fR\^(\(fm\fI\fR\^\(fm\^) always succeeds and covers the case
when the identifier consists of a single \(fm\fI\h'-0.1m'X\fR\^\(fm.
This example can be rewritten in a more concise form if we use
the scan construct:
.sp 0.5
.D{
.{{
\fBproc\fR \jg\fIidentifier\fR\^(\fIs\fR)
\z(  \jh\fBscan\fR \ji\fIscan\*_string\fR\^(\fIs\fR)
\h'|\nhu'\fBfor\fR
    \jj\fIreturn\fR\^(\fIlit\fR\^(\(fm\fI\h'-0.1m'X\fR\^\(fm\^) & (\fIspan\fR\^(\fIletter\*_or\*_digit\fR) | \fIlit\fR\^(\(fm\fI\fR\^\(fm\^)))
\h'|\nhu'\fBrof\fR
)
.}}
.D}
.sp 0.5
.PP
A final example may illustrate the use of the value returned by
pattern matching procedures.
The problem is to extract all letters from a given string.
For example \(fm\fI\h'-0.1m'a,b,c\fR\^\(fm gives \(fm\fI\h'-0.1m'abc\fR\^\(fm.
A procedure to achieve this can be defined as follows:
.sp 0.5
.D{
.{{
\fBproc\fR \jg\fIextract\*_letter\fR\^(\fIs\fR)
\z(  \jh\fBvar\fR \ji\fIresult\fR := \(fm\fI\fR\^\(fm;
\h'|\nhu'\fBscan\fR \jj\fIscan\*_string\fR\^(\fIs\fR)
\h'|\nhu'\fBfor\fR
    \jk\fBwhile\fR \jl\fIbreak\fR\^(\fIletter\fR) 
\h'|\nku'\fBdo\fR \jj\fIresult\fR := \fIresult\fR || \fIspan\fR\^(\fIletter\fR) \fBod\fR
\h'|\nhu'\fBrof\fR;
\h'|\nhu'\fIreturn\fR\^(\fIresult\fR)
)
.}}
.D}
.sp 0.5
.PP
In \s-2SUMMER\s0, pattern matching and backtracking have been completely separated.
\fBIt came as a shock to us to discover that the majority of pattern matching
problems which we had solved previously by means of implicit backtracking,
could be solved without any backtracking at all!\fP
Many problems of practical importance can be solved using LL(k) or LR(k)
techniques and are at worst only locally ambiguous.
Using completely automatic backtracking as a parsing technique
is rather wasteful under such circumstances and
this suggests that the close interaction between pattern matching
and backtracking, which can be found in several languages, should be
reconsidered.
See Chapter 2 for an extensive discussion
of this topic.
.PP
How can pattern matching with automatic backtracking be obtained?
Consider the expression:
.DS I
.{{
\z( \jg\fIlit\fR\^(\(fm\fI\h'-0.1m'ab\fR\^\(fm\^) | \fIlit\fR\^(\(fm\fI\h'-0.1m'a\fR\^\(fm\^)) & \fIlit\fR\^(\(fm\fI\h'-0.1m'bc\fR\^\(fm\^)
.}}
.DE
In the pattern matcher developed above, the alternative \fIlit\fR\^(\(fm\fI\h'-0.1m'a\fR\^\(fm\^)
is discarded as soon as a substring starting with \(fm\fI\h'-0.1m'ab\fR\^\(fm is encountered,
since we are using McCarthy \fIand\fP and \fIor\fP operations {3.2}.
The string \(fm\fI\h'-0.1m'abc\fR\^\(fm cannot be recognized in this way.
But if we rewrite the expression as
.DS I
.{{
\fBtry\fR \jg\fIlit\fR\^(\(fm\fI\h'-0.1m'ab\fR\^\(fm\^), \fIlit\fR\^(\(fm\fI\h'-0.1m'a\fR\^\(fm\^)
\h'|\ngu'\fBuntil\fR \jh\fIlit\fR\^(\(fm\fI\h'-0.1m'bc\fR\^\(fm\^)
\fByrt\fR
.}}
.DE
then the side-effect recovery mechanism implicit in the try construct
automatically restores the initial cursor value 
and attempts the second alternative if \fIlit\fR\^(\(fm\fI\h'-0.1m'bc\fR\^\(fm\^) fails the first time.
No special attention need be paid to the cursor:
it is an ordinary variable which is saved and restored automatically by the
try construct just as any other variable.
.SH 3.5.2. "Generalized pattern matching"
.PP
In most pattern matching systems there is only one subject string
involved in the pattern match.
In our scheme, this restriction can be removed without introducing
any new concepts as an example will show.
The following (rather artificial) problem is to ensure that
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "two strings 
.ps 9
.ft 2
.ds 13 "S\|\f11\fP
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and 
.ps 9
.ft 2
.ds 13 "S\|\f12\fP
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " conform to the following rules:
.ps \n(99
.ft \n(98
\*(12
.IP \*(MK
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "S\|\f11\fP
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is of the form 
.ps 9
.ft 2
.ds 13 "c
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\f1;\fP
.as 13 "\*(14
.ds 14 "c
.ds 15 "\f12\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\f1;\fP
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\v'-.3m'\ .\ .\ .\ \v'.3m'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\f1;\fPc
.ds 15 "n
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 14 "\f1;\fP
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "where 
.ps 9
.ft 2
.ds 13 "c
.ds 14 "i
.as 13 \v'9u'\s-3\*(14\s+3\|\v'-9u'
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is a (perhaps empty) sequence of arbitrary characters
.ps \n(99
.ft \n(98
\*(12
except for the character `;'.
.IP \*(MK
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "For a given 
.ps 9
.ft 2
.ds 13 "S\|\f11\fP
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ", 
.ps 9
.ft 2
.ds 13 "S\|\f12\fP
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " has the form 
.ps 9
.ft 2
.ds 13 "d
.ds 14 "\f11\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "d
.ds 15 "\f12\fP
.as 14 \v'9u'\s-3\|\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\v'-.3m'\ .\ .\ .\ \v'.3m'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "d
.ds 15 "n
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ",
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "and either 
.ps 9
.ft 2
.ds 13 "d
.ds 14 "i
.as 13 \v'9u'\s-3\*(14\s+3\|\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\(eq
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "c
.ds 15 "i
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " or 
.ps 9
.ft 2
.ds 13 "d
.ds 14 "i
.as 13 \v'9u'\s-3\*(14\s+3\|\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\(eq
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "reverse\|\f1(\fPc
.ds 15 "i
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 14 "\f1)\fP
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " holds.
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "Acceptable values for 
.ps 9
.ft 2
.ds 13 "S\|\f12\fP
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " with 
.ps 9
.ft 2
.ds 13 "S\|\f11\fP
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " equal to \(fm\fI\h'-0.1m'ab;cde;f;\fR\^\(fm
.ps \n(99
.ft \n(98
\*(12
are \(fm\fI\h'-0.1m'abcdef\^\fR\^\(fm, \(fm\fI\h'-0.1m'abedcf\^\fR\^\(fm, \(fm\fI\h'-0.1m'bacdef\^\fR\^\(fm and \(fm\fI\h'-0.1m'baedcf\^\fR\^\(fm.
.br
.ne 4
.LP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "The following program checks whether a given 
.ps 9
.ft 2
.ds 13 "S\|\f11\fP
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and 
.ps 9
.ft 2
.ds 13 "S\|\f12\fP
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " satisfy this relation:
.ps \n(99
.ft \n(98
\*(12
.D{
.{{
\fIs1\fR := \fIscan\*_string\fR\^(\fIS1\fR);
\fIs2\fR := \fIscan\*_string\fR\^(\fIS2\fR);
\fBscan\fR \jg\fIs1\fR
\fBfor\fR
   \jh\fBwhile\fR \ji(\fIn\fR := \fIbreak\fR\^(\(fm\fI;\fR\^\(fm\^)) & \fIlit\fR\^(\(fm\fI;\fR\^\(fm\^)
\h'|\nhu'\fBdo\fR
      \jj\fBif\fR \ji\(ap \fBscan\fR \jk\fIs2\fR \fBfor\fR \jl\fIlit\fR\^(\fIn\fR) | \fIlit\fR\^(\fIreverse\fR\^(\fIn\fR)) \fBrof\fR
\h'|\nju'\fBthen\fR
            \jm\fIerror\fR\^(\(fm\fI\h'-0.1m'check fails\fR\^\(fm\^)
\h'|\nju'\fBfi\fR
\h'|\nhu'\fBod\fR
\fBrof\fR;
\fBif\fR \jh\fIs1\fR.\fIcursor\fR = \fIS1\fR.\fIsize\fR & \fIs2\fR.\fIcursor\fR = \fIS2\fR.\fIsize\fR
\fBthen\fR
\h'|\nhu'\fIprint\fR\^(\(fm\fI\h'-0.1m'check succeeds\fR\^\(fm\^)
\fBelse\fR
\h'|\nhu'\fIerror\fR\^(\(fm\fI\h'-0.1m'check fails\fR\^\(fm\^)
\fBfi\fR
.}}
.D}
.PP
Each \fIscan\*_string\fR object maintains its own cursor.
The innermost scan construct operates each time on the same
\fIscan\*_string\fR instance \fIs2\fR whose cursor value gets modified.
This allows the innermost pattern match to continue
where it left off the previous time.
.PP
From the preceding paragraphs it will be clear that pattern matching
as presented here, does not depend on the fact that strings are used
as the basic unit of recognition.
One can, for example, easily imagine pattern matching on an array of strings.
The `cursor' must then be replaced by a pair of values to maintain the
current position, and basic scanning procedures like \fIxlit\fR, \fIylit\fR,
\fIxspan\fR and \fIyspan\fR must be defined.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "It may be expected that a system like \s-2ESP\s0
.ps 9
.ft 2
.ds 13 "
.ds 14 "\f13\fP
.as 13 \v'-21u'\s-3\*(14\s+3\v'21u'
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " [Shapiro74]
.ps \n(99
.ft \n(98
\*(12
can be defined in a straightforward manner using the primitives from
the \s-2SUMMER\s0 kernel.
.SH 3.6. "Related work"
.PP
S\s-2UMMER\s0 was inspired by and profited from ideas in
\s-2SNOBOL\s04 [Griswold71]
and SL5 [Griswold76].
The method adopted for the integration of
pattern matching and expression evaluation
(see Chapter 2)
was inspired by Icon [Griswold79].
.PP
The major ideas introduced by \s-2SUMMER\s0 are
the evaluation model which prohibits unanticipated failure,
the recovery from side-effects in failing expressions,
the use of recovery caches as an implementation technique
and the separation of pattern matching and backtracking which
allows more general pattern matching in domains other than strings.
.SH 3.7. "References for Chapter 3"
.so refs/Dahl70
.so refs/Griswold71
.so refs/Griswold76
.so refs/Griswold79
.so refs/Klint80
.so refs/Randell75
.so refs/Shapiro74

.rm LH
.rm RH
.bp

.NC 4 "FORMAL LANGUAGE DEFINITIONS" "CAN BE MADE PRACTICAL"
.ds LH "FORMAL LANGUAGE DEFINITIONS
.LP
.in +2.5i
 ` . . . \fIThe metalanguage of a formal definition must not become
a language known to only the priests of the cult.
Tempering science with magic is a sure way to return to
the Dark Ages\fP.' [Marcotty76]
.in
.ls
.SH 4.1. "The problem"
.PP
Programming languages are being designed using pre-scientific methods.
There is of course no substitute for experience, taste, style and intuition,
but a scientific design methodology to support them is lacking.
Methods for describing programming languages are somewhat more
developed, but most definitions are either
ambiguous and inaccurate, or excessively formal and unreadable.
In general, a language definition method should:
.IP \*(MK
help the language \fBdesigner\fP
by giving insight into the language he or she is designing, and by exposing
interactions that might exist between language features.
The definition should at the same time be
a pilot implementation of the defined language,
or it should at least be convertible into one.
It is assumed here, that design and definition can best be carried out
simultaneously.
.IP \*(MK
help the language \fBimplementor\fP
by providing him with an unambiguous and complete definition that is capable
of `executing' small programs in cases where the implementor is not sure
about all implications of a particular language feature.
.IP \*(MK
help the \fBuser\fP
by providing him with a precise definition in a language with which he
is not too \fBun\fPfamiliar.
.LP
These three goals impose different and to a certain extent contradictory
requirements on the definition method to be used.
In particular, it seems difficult to combine precision and readability
in one method, since a precise definition has to use some
formalism into which the reader has to be initiated and such a definition
will have a tendency to become long and unreadable.
This chapter is devoted to an experiment with a language definition method that 
may be considered as a tentative step towards satisfying the above requirements.
.PP
The \fBdefined\fP language is (of course) \s-2SUMMER\s0.
The definition method is similar in spirit to the \s-2SECD\s0 method [Landin64],
i.e. it is an operational language definition method which uses
recursive functions and syntactic recognition functions that 
associate semantic actions with all constructs in the grammar of the language.
In the method presented in this chapter,
readability has been considerably enhanced by using a few
imperative constructs and by introducing a very concise notation
for parsing and decomposing the source-text of programs in the defined language.
S\s-2UMMER\s0, extended with such parsing and decomposing operations, is used as
\fBdefinition language\fP.
The definition is thus circular (see Sections 4.2.1
and 4.3).
.PP
A complete description of the definition method can be found in part II
of this monograph.
The next section gives only a birds-eye view of the description method
and shows some illustrative examples from the \s-2SUMMER\s0 definition.
In Section 4.3 the method as a whole and its application to \s-2SUMMER\s0
are assessed.
.SH 4.2. "The method"
.SH 4.2.1. "Introduction"
.PP
An \fBevaluation process\fP or \fBinterpreter\fP (with the name `\fIeval\fR\|')
will be defined that takes an arbitrary, but syntactically correct,
source text (`the source program')
as input and either computes the result of the execution of that program
(if it is a legal program in the defined language),
or detects a semantic error, or does not terminate.
In the latter two cases, no meaning is attached to the program.
The evaluation process operates directly on the text of the source program.
During this process a global \fBenvironment\fP is inspected or updated.
An environment is a mapping from identifiers in the source program
to their actual values during the evaluation process.
In this way environments determine the meaning of names in the source program
and are used to describe concepts such as variables, assignment and scope rules.
.PP
A fundamental question arises here:
in which language do we write the definition?
Several choices can be made, such as the formalism used in
.ix I "denotational semantics"
([Gordon79], which boils down to a mathematical notation for recursive functions
and domains) or the
.ix I "Vienna Definition Language"
([Wegner72], which is a programming language designed for the manipulation of trees).
This is not the right place to discuss the merits of these formalisms, but
none has the desired combination of properties described in the
previous paragraph.
Instead of designing yet another definition language,
the defined language itself (this is \s-2SUMMER\s0 in the examples given in this chapter)
will be used as definition language.
This choice has the obvious disadvantage that the definition is
circular, but it has the practical advantage that readers who have only
a moderate familiarity with the defined language will be able
to read the definition without great difficulty.
An extensive discussion of circular language definitions can be found in [Reynolds72].
It should be emphasized that there is no \fBfundamental\fP
reason for making the definition circular.
The definition method described here would also work if, for instance,
\s-2ALGOL\s068 were used as definition language.
In any case, it is essential that the definition language has powerful
string operations and allows the creation of data structures
of dynamically determined size.
This requirement, for example, makes \s-2PASCAL\s0 less suited as definition language.
Choosing \s-2SUMMER\s0 as definition language gave us the opportunity of
investigating the suitability of that language in the area of
language definition (see Section 4.3).
.PP
In the following sections the definition method and an example
of its application (in the \s-2SUMMER\s0 definition) are described simultaneously.
In Section 4.2.2
some aspects of the use of \s-2SUMMER\s0 as a metalanguage are discussed.
The definition method can be subdivided into the definition of
semantic domains (Section 4.2.3)
and of the evaluation process (Section 4.2.4).
Further detailed examples from the \s-2SUMMER\s0 definition are given
in Section 4.2.5.
.SH 4.2.2. "S\s-2UMMER\s0 as a metalanguage"
.PP
This paragraph focuses on some aspects of \s-2SUMMER\s0 that are used in
the formal definition, but were not covered in Chapter 3.
Most of the constructs to be used in the definition
have some similarity with constructs in, for instance,
\s-2PASCAL\s0 and are assumed to be self-explanatory.
Only less obvious constructs that are essential to the understanding of
the definition are mentioned here.
.PP
S\s-2UMMER\s0 is an object-oriented language with pointer semantics.
This means that an object can be modified by assignment and that
such modifications are visible through all access paths to that object.
For example,
.DS
.{{
\fIs\fR := \fIstack\fR\^(10);
\fIt\fR := \fIs\fR;
.}}
.DE
assigns one and the same \fIstack\fR object to the
variables \fIs\fR and \fIt\fR, and
.DS
.{{
\fIs\fR.\fIpush\fR\^(\fIv\fR)
.}}
.DE
pushes the value of \fIv\fR onto this stack.
As a side-effect the stack is modified in such a way that subsequent operations
on \fIs\fR or \fIt\fR may perceive the effect of that modification.
In the formal definition this is relevant to the concepts `state'
and `environment', which are modified in this way.
.PP
The language is dynamically typed, i.e. the type of variables is not fixed
statically (as in \s-2PASCAL\s0) but is only determined during the execution of
the program (as in \s-2LISP\s0 or \s-2SNOBOL\s04).
Moreover, generic operations on data structures are allowed.
If an operation is defined on several data types, then the
procedure to be executed when that operation occurs is determined
by the type of the (left) operand of that operation.
.PP
Control structures and data structures are self-explanatory
except possibly \fBarrays\fP and \fBfor-expressions\fP.
.PP
Arrays are vectors of values,
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "indexed by 
.ps 9
.ft 2
.ds 13 "\f10\fP
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "N\|\(mi\f11\fP
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ",
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "where 
.ps 9
.ft 2
.ds 13 "N
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is the number of elements in the array.
.ps \n(99
.ft \n(98
\*(12
If \fIA\fR is an array then the operation \fIA\fR.\fIsize\fR will yield the number
of elements in the array.
A new array is created by
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "\f1[\fPV
.ds 14 "\f10\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "V
.ds 15 "N\|\(mi\f11\fP
.as 14 \v'9u'\s-3\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 14 "\f1]\fP
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.DE
or
.DS
.{{
\fIarray\fR\^(\fIN\fR, \fIV\fR\|)
.}}
.DE
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "In the former case, an array of size 
.ps 9
.ft 2
.ds 13 "N
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is created and initialized to the
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "values 
.ps 9
.ft 2
.ds 13 "V
.ds 14 "\f10\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "V
.ds 15 "N\|\(mi\f11\fP
.as 14 \v'9u'\s-3\*(15\s+3\v'-9u'
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ".
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "In the latter case, an array of size 
.ps 9
.ft 2
.ds 13 "N
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is created and all elements are
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "initialized to the value 
.ps 9
.ft 2
.ds 13 "V
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ".
.ps \n(99
.ft \n(98
\*(12
Array denotations are also allowed on the left-hand side of assignments.
This provides a convenient notation for multiple assignments.
For example,
.DS
.{{
\fIx\fR := 10; \fIy\fR := 20; \fIz\fR := 30
.}}
.DE
is equivalent to
.DS
.{{
[\fIx\fR, \fIy\fR, \fIz\fR] := [10, 20, 30]
.}}
.DE
and, more generally,
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "x
.ds 14 "\f10\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\f1:\fP\(eq
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "a\|\f1[\fP\f10\fP\f1]\fP\f1;\fP
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\v'-.3m'\ .\ .\ .\ \v'.3m'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\f1;\fP
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "x
.ds 15 "k
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\f1:\fP\(eq
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "a\|\f1[\fPk\|\f1]\fP
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.DE
is equivalent to
.DS
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "\f1[\fPx
.ds 14 "\f10\fP
.as 13 \v'9u'\s-3\|\*(14\s+3\v'-9u'
.ds 14 "\ 
.as 13 "\*(14
.ds 14 ",\ .\ .\ .\ ,\|
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "x
.ds 15 "k
.as 14 \v'9u'\s-3\*(15\s+3\|\v'-9u'
.as 13 "\*(14
.ds 14 "\f1]\fP
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\f1:\fP\(eq
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "a
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.DE
The general form of a for-expression is:
.DS
.{{
\fBfor\fR \jg\fIV\fR \fBin\fR \jh\fIG\fR \fBdo\fR \ji\fIS\fR \fBod\fR
.}}
.DE
where \fIV\fR is a variable, \fIG\fR is an expression
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "capable of generating a sequence of values 
.ps 9
.ft 2
.ds 13 "VAL
.ds 14 "i
.as 13 \v'9u'\s-3\*(14\s+3\|\v'-9u'
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and where 
.ps 9
.ft 2
.ds 13 "S
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is an
.ps \n(99
.ft \n(98
\*(12
arbitrary statement.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "For each iteration the assignment 
.ps 9
.ft 2
.ds 13 "V\|\f1:\fP\(eqVAL
.ds 14 "i
.as 13 \v'9u'\s-3\*(14\s+3\|\v'-9u'
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is performed
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "and 
.ps 9
.ft 2
.ds 13 "S
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is evaluated.
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "As used in the formal definition, the value of 
.ps 9
.ft 2
.ds 13 "G
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
is either an array
(in which case consecutive array elements are generated) or
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "G
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is an array on which the operation \fIindex\fR is performed
.ps \n(99
.ft \n(98
\*(12
(in which case all indices of consecutive array elements are generated).
For example, in
.DS
.{{
\fIa\fR := [144, 13, 7];
\fBfor\fR \jg\fIx\fR \fBin\fR \jh\fIa\fR \fBdo\fR \ji\fIprint\fR\^(\fIx\fR) \fBod\fR
.}}
.DE
an array object is assigned to the variable \fIa\fR and
the values 144, 13 and 7 will be printed, while
.DS
.{{
\fBfor\fR \jg\fIi\fR \fBin\fR \jh\fIa\fR.\fIindex\fR \fBdo\fR \ji\fIprint\fR\^(\fIi\fR\|) \fBod\fR
.}}
.DE
will print the values 0, 1 and 2.
Further examples of for-expressions will be found in the
following paragraphs.
.SH 4.2.3. "Semantic domains"
.PP
A
.ix I "semantic domain"
is a set, whose elements either describe a primitive notion
in the defined language (like `variable' or `procedure declaration')
or have some common properties as far as the language definition is concerned.
The relationship between these domains is given by a series of
domain equations.
.PP
In this paragraph the domains in the \s-2SUMMER\s0 definition are briefly described.
The abstract properties of these domains are given in part II.
Here, they are only introduced informally.
First, the domain equations are given.
Next, the meaning of each domain is described.
.PP
The relationship between the domains
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "BASIC
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ", 
.ps 9
.ft 2
.ds 13 "COMPOSITE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ", 
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ",
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "STORABLE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "VALUE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ", 
.ps 9
.ft 2
.ds 13 "DENOTABLE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "VALUE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ", 
.ps 9
.ft 2
.ds 13 "PROCEDURE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ", 
.ps 9
.ft 2
.ds 13 "CLASS
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ", 
.ps 9
.ft 2
.ds 13 "LOCATION
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ",
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "STATE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and 
.ps 9
.ft 2
.ds 13 "ENVIRONMENT
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is as follows:
.ps \n(99
.ft \n(98
\*(12
.DS L
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 ".ta \w'
.ps 9
.ft 2
.ds 13 "COMPOSITE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " 'u
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "BASIC
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "	= 
.ps 9
.ft 2
.ds 13 "INTEGER
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(cu
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "STRING
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(cu
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "UNDEFINED
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "COMPOSITE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "	= 
.ps 9
.ft 2
.ds 13 "CLASS
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(mu
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "ENVIRONMENT
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "	= 
.ps 9
.ft 2
.ds 13 "BASIC
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(cu
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "COMPOSITE
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "STORABLE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "VALUE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "	= 
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "DENOTABLE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "VALUE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "	= 
.ps 9
.ft 2
.ds 13 "STORABLE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "VALUE
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(cu
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "PROCEDURE
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(cu
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "	\h'\w'= 'u'
.ps 9
.ft 2
.ds 13 "CLASS
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(cu
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "LOCATION
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "PROCEDURE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "	= 
.ps 9
.ft 2
.ds 13 "PROCEDURE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "DECLARATION
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(mu
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "	\h'\w'= 'u'
.ps 9
.ft 2
.ds 13 "ENVIRONMENT
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "CLASS
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "	= 
.ps 9
.ft 2
.ds 13 "IDENTIFIER
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(mu
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "CLASS
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "DECLARATION
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "STATE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "	= 
.ps 9
.ft 2
.ds 13 "LOCATION
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(->
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "\f1(\fPSTORABLE
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "VALUE
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(cu
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "{
.as 13 "\*(14
.ds 14 "unused
.as 13 "\*(14
.ds 14 "}
.as 13 "\|\*(14
.ds 14 "\f1)\fP
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "ENVIRONMENT
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "	= 
.ps 9
.ft 2
.ds 13 "IDENTIFIER
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "\(->
.as 13 "\*(14
.ds 14 "\ 
.as 13 "\*(14
.ds 14 "DENOTABLE
.as 13 "\*(14
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "VALUE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.DE
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "Here, 
.ps 9
.ft 2
.ds 13 "IDENTIFIER
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ", 
.ps 9
.ft 2
.ds 13 "PROCEDURE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "DECLARATION
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "CLASS
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "DECLARATION
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " are the sets of string values that can
.ps \n(99
.ft \n(98
\*(12
be derived from the syntactic notions
\*<identifier\*>,
.iy I <identifier> ,
\*<procedure-declaration\*>
.iy I <procedure-declaration>
and
\*<class-declaration\*>
.iy I <class-declaration>
in the \s-2SUMMER\s0 grammar.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "BASIC
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is the domain of primitive values in the language.
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "COMPOSITE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is the domain of user-defined values.
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "STORABLE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "VALUE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is the domain of
.ps \n(99
.ft \n(98
\*(12
values which can be assigned to variables in the source program.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "DENOTABLE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "VALUE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is the domain of
.ps \n(99
.ft \n(98
\*(12
values which can be manipulated by the evaluation process.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "The domains 
.ps 9
.ft 2
.ds 13 "PROCEDURE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and 
.ps 9
.ft 2
.ds 13 "CLASS
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " describe declarations for procedures
.ps \n(99
.ft \n(98
\*(12
an classes respectively.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "The domain 
.ps 9
.ft 2
.ds 13 "LOCATION
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is
.ps \n(99
.ft \n(98
\*(12
used to model the notion `address of a cell capable of containing a (single) value'.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "STATE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is the domain that consists of functions which map locations onto
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "actual values or `
.ps 9
.ft 2
.ds 13 "unused
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "'.
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "ENVIRONMENT
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is the domain of functions which map names onto denotable values.
.ps \n(99
.ft \n(98
\*(12
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "STRING
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ", 
.ps 9
.ft 2
.ds 13 "INTEGER
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and 
.ps 9
.ft 2
.ds 13 "UNDEFINED
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " are the domains modeling
.ps \n(99
.ft \n(98
\*(12
the values and operations for
the built-in types `string', `integer' and `undefined' respectively.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 9
.ft 2
.ds 13 "UNDEFINED
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is the domain consisting of undefined values.
.ps \n(99
.ft \n(98
\*(12
All variables are initialized to an undefined value.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "Operations are defined on elements in 
.ps 9
.ft 2
.ds 13 "STRING
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ", 
.ps 9
.ft 2
.ds 13 "INTEGER
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and 
.ps 9
.ft 2
.ds 13 "UNDEFINED
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
that model the primitive operations on the data types `string', `integer' and `undefined'.
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 ".ix I 
.ps 9
.ft 2
.ds 13 "PROCEDURE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
is the domain of procedures.
Each element of this domain describes a procedure declaration and
contains a literal copy of the text of the procedure declaration itself
and an environment that reflects all names and values available at the
point of declaration.
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 ".ix I 
.ps 9
.ft 2
.ds 13 "CLASS
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
is the domain of classes.
Each element of this domain describes one class declaration and contains
the name of the class and a literal copy of the text of the
class declaration.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 ".ix I 
.ps 9
.ft 2
.ds 13 "COMPOSITE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "-
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
is the domain of class instances.
All values that are created by a \s-2SUMMER\s0 program are instances of some class
(this has been explained informally in Section 3.4.)..
A composite instance consists of the name of the class to which it belongs,
the literal text of the declaration of that class and an environment
that has to be used to inspect or update components from the instance.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "Operations are defined on elements in 
.ps 9
.ft 2
.ds 13 "PROCEDURE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 ", 
.ps 9
.ft 2
.ds 13 "CLASS
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and 
.ps 9
.ft 2
.ds 13 "INSTANCE
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
to manipulate the components of an element in these domains.
For completeness, these domains are mentioned here, but they
will not be used in the remainder of this chapter.
A complete definition appears in Section 6.3.3.
.PP
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 ".ix I 
.ps 9
.ft 2
.ds 13 "ENVIRONMENT
.ds 13 \x'0'\f2\s9\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
is the domain of environments.
Environments take care of the binding between names and values and the
introduction of new scopes (i.e. ranges in the program where
names may be declared).
In general, operations defined on environments modify the environment
to which they are applied.
.PP
The definitions given in following sections are centered around operations
on elements of these semantic domains,
but we will see relatively few of them in the examples.
Operations will be explained only when they occur in an example.
.SH 4.2.4. "Evaluation process"
.PP
Before turning our attention to the evaluation process (which defines semantics),
a few words must be said about the definition of syntax.
In the definition method to be used the role of a syntax definition is twofold:
.IP \*(MK
to define the grammar of the defined language, and
.IP \*(MK
to unravel a source text in order to define a meaning for its constituent
parts.
.LP
These two aspects of a syntax definition are now considered in turn.
.PP
An extended form of \s-2BNF\s0 notation is used to describe the syntax
of the defined language.
The extensions aim at providing a concise notation for the description
of repeated and optional syntactic notions.
A syntactic notion suffixed with `+' means one or more repetitions of
that notion.
A notion suffixed with `\v'0.25m'*\v'-0.25m'' stands for zero or more repetitions
of that notion.
The notation
.DS
{ \fInotion separator\fP } \fIreplicator\fP
.DE
i.e. a \fInotion\fP followed by a \fIseparator\fP enclosed in braces
followed by a \fIreplicator\fP,
is used to describe a list of notions separated by the given separator.
A replicator is either `+' or `\v'0.25m'*\v'-0.25m''.
The replicator `+' indicates that the list consists of one or more notions.
The list begins and ends with a notion.
The replicator `\v'0.25m'*\v'-0.25m'' indicates that the list consists of zero or more notions.
.PP
An optional syntactic notion is indicated by
enclosing it in square brackets, e.g. `[ \fInotion\fP ]'.
The terminal symbols of the grammar are either enclosed in single
quotes (for example: \(fm\fI,\fR\^\(fm or \(fm\fI:=\fR\^\(fm) or written in upper case letters
if the terminal symbol consists solely of letters
(both `\s-2IF\s0' and `\(fm\fI\h'-0.1m'if\^\fR\^\(fm' may, for instance,
be used to denote the terminal symbol `\fBif\fR\|').
Where necessary, parentheses are used for grouping.
.PP
Some parts of a syntax rule may be labelled with a \*<tag\*>; their
meaning will become clear below.
.PP
The
.ix I "evaluation process"
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "is described in \s-2SUMMER\s0 extended with \fBparse expressions\fP
.ps 9
.ft 2
.ds 13 "
.ds 14 "\f12\fP
.as 13 \v'-21u'\s-3\*(14\s+3\v'21u'
.ds 13 \x'0'\f2\s9\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.FS
2) There is no \fBfundamental\fP reason for introducing this language extension.
However, the disadvantage of introducing such an \fIad hoc\fP extension
is more than compensated by the fact that we use a notation which is
sufficiently similar to \s-2BNF\s0 notation to be almost self-explanatory.
The effect of introducing a language extension as proposed here
is interesting in its own right but falls outside the scope of the
current discussion.
.FE
of the form
.DS
\&\(fm\fI{{\fR\^\(fm \*<identifier\*> \*`=\h'-0.3m'=\*' \*<syntax-rule\*> \(fm\fI}}\fR\^\(fm
.DE
which provide a concise notation for parsing and extracting
information from the text of the source program.
A parse expression succeeds if the identifier on the left hand side
of the `=\h'-0.3m'=' sign has
a string as value and if this string is of the form described by the
\*<syntax-rule\*> on the right hand side of the `=\h'-0.3m'=' sign.
All \*<tag\*>s occurring in the \*<syntax-rule\*> should have been declared as
variables in the program containing the parse expression,
in this case the evaluation process.
Substrings of the parsed text recognized by the syntactic categories
that are labelled with a \*<tag\*>
are assigned to the variable that corresponds to that \*<tag\*>.
Consider, for example, the following program fragment:
.DS
.{{
\fBif\fR \jg{{ \fIe\fR =\h'-0.3m'= \jh\s-2WHILE\s0 \ji\fIt\fR:\*<test\*> \s-2DO\s0 \jj\fIb\fR:\*<body\*> \s-2OD\s0 \jk}}
\fBthen\fR
\h'|\ngu'\fIput\fR\^(\(fm\fI\h'-0.1m'While expression recognized\^\fR\^\(fm\^)
\fBfi\fR
.}}
.DE
The parse expression will succeed if \fIe\fR has the form of a `while
expression'.
The literal text of the \*<test\*> is then assigned to variable \fIt\fR
and the text of the \*<body\*> is assigned to variable \fIb\fR.
.PP
If the recognized part of the text is a list or repetition,
then an array of string values is assigned to the variable.
In the case of a list of notions separated by separators, the latter are
omitted and only the notions occurring in the list are assigned to
(consecutive) elements in the array.
This is exemplified by:
.DS
.{{
\fBif\fR \jg{{ \fIe\fR =\h'-0.3m'= \jh\s-2VAR\s0 \ji\fIlist\fR:{\*<identifier\*> \(fm\fI,\fR\^\(fm}+ }}
\fBthen\fR
\h'|\ngu'\fIput\fR\^(\(fm\fI\h'-0.1m'A variable declaration containing:\fR\^\(fm\^);
\h'|\ngu'\fBfor\fR \jj\fIid\fR \fBin\fR \jk\fIlist\fR \fBdo\fR \jl\fIput\fR\^(\fIid\fR\|) \fBod\fR
\fBfi\fR
.}}
.DE
The parse expression succeeds if \fIe\fR has the form of a `variable declaration'
(i.e. the keyword `\fBvar\fR' followed by a list of \*<identifier\*>s separated
by commas)
and in that case
an array of string values corresponding to the \*<identifier\*>s occurring in
the declaration
is assigned to the variable \fIlist\fR, which is subsequently printed.
.PP
Parse expressions may be used in \fBif\fP-expressions or may stand on their own.
In the latter case, the string to be parsed \fBhas\fP to be of the form described by the parse expression.
In this way, parse expressions can be used
to decompose a string with a known form into substrings.
.PP
This concludes our digression on the definition of syntax and we turn now
our attention to the evaluation process that defines semantics.
In the case of the \s-2SUMMER\s0 definition, the overall structure of this
.ix I "evaluation process"
is:
.DS I
.{{
\fBvar\fR \jg\fIENV\fR;
\fBvar\fR \jg\fISTATE\fR;
\fBvar\fR \jg\fIvarinit\fR;
\fBproc\fR \jh\fIERROR\fR
.sp -0.1
\h'|\nhu'.\ .\ . ;
\fBproc\fR \jh\fIeval\fR\^(\fIe\fR)
\z(  \ji\fBvar\fR \jj\fIvalue\fR, \fIsignal\fR, .\ .\ . ;
\h'|\niu'\fBif\fR \jh{{ \fIe\fR =\h'-0.3m'= \jk\*<program-declaration\*> }}
\h'|\niu'\fBthen\fR
.sp -0.1
\h'|\nhu'.\ .\ .
\h'|\nhu'\fIreturn\fR\^(\^[\fIvalue\fR, \fIsignal\fR\|]\^)
\h'|\niu'\fBfi\fR;
\h'|\niu'\fBif\fR \jh{{ \fIe\fR =\h'-0.3m'= \jk\*<variable-declaration\*> }}
\h'|\niu'\fBthen\fR
.sp -0.1
\h'|\nhu'.\ .\ .
\h'|\nhu'\fIreturn\fR\^(\^[\fIvalue\fR, \fIsignal\fR\|]\^)
\h'|\niu'\fBfi\fR;
.sp -0.1
\h'|\niu'.\ .\ .
\h'|\niu'\fBif\fR \jh{{ \fIe\fR =\h'-0.3m'= \jk\*<empty\*> }}
\h'|\niu'\fBthen\fR
.sp -0.1
\h'|\nhu'.\ .\ .
\h'|\nhu'\fIreturn\fR\^(\^[\fIvalue\fR, \fIsignal\fR\|]\^)
\h'|\niu'\fBfi\fR;
);
.}}
.DE
The variable \fIENV\fR has as value the current environment, and \fISTATE\fR
has as value the current state.
The variable \fIvarinit\fR has as value a string consisting of the
text of all
\*<variable-initialization\*>s
.iy I <variable-initialization> s
in the current
\*<block\*>.
.iy I <block> .
.PP
The procedure \fIERROR\fR is called when a semantic error is
detected during evaluation.
In this case, the whole evaluation process is aborted immediately.
The main defining procedure is \fIeval\fR, which selects an appropriate case
depending onto the syntactic form of its argument \fIe\fR.
Some examples of these various cases will be given in Section 4.2.5.
Note that each of these cases involves a complete syntactic analysis
of the string \fIe\fR.
The evaluation process is initiated by creating an initial, empty
environment \fIENV\fR and by calling \fIeval\fR with the text of the
source program as argument.
If the evaluation process is not prematurely terminated
(by the detection of a semantic error)
the result of the evaluation of the source program can be obtained
by inspecting the resulting environment \fIENV\fR.
.PP
The definition of \s-2SUMMER\s0 has been profoundly influenced by the
success-directed evaluation scheme in the language:
an expression can either \fBfail\fP or \fBsucceed\fP.
The meaning of failure is that evaluation of the `current' expression
is abandoned and that evaluation is continued at a point where
a `handler' (i.e. \*<if-expression\*>, \*<while-expression\*>)
occurs to deal with the failing case.
A similar situation exists for \*<return-expression\*>s, which terminate
the evaluation of (possibly nested) expressions.
Both language features can thus essentially influence the flow-of-control
in a program.
.PP
How are these properties of \s-2SUMMER\s0 reflected in the definition?
The procedure \fIeval\fR delivers as result an array
of the form [\fIvalue\fR, \fIsignal\fR\|], where \fIvalue\fR is the actual result of the
procedure and \fIsignal\fR is a success/failure flag that indicates how \fIvalue\fR
should be interpreted.
The signal is used to describe the occurrence of
failure and/or \*<return-expression\*>s and may have the following values:
.IP \fIN\fR:
evaluation terminated normally.
.IP \fIF\fR:
evaluation failed.
.IP \fINR\fR:
normal return; a
\*<return-expression\*>
.iy I <return-expression>
was encountered during evaluation.
.IP \fIFR\fR:
failure return; a failure return was encountered during evaluation.
.LP
The signal is tested after each (recursive) invocation of \fIeval\fR.
In most cases \fIeval\fR performs an immediate return if the signal is not equal
to \fIN\fR after the evaluation of a subexpression.
Exceptions to this rule are of two kinds:
.IP \*(MK
The semantics of certain constructs is such that the flow of control
is intentionally influenced by the success or failure of expressions
(e.g. \*<test\*>s in \*<if-expression\*>s).
In \fIeval\fR this corresponds to appropriate reactions
to \fIN\fR and \fIF\fR signals.
Aborting the evaluation of the `current'
expression, which is necessary if failure occurs in a deeply nested
subexpression, can be achieved by passing an \fIF\fR signal upwards until it
reaches an incarnation of \fIeval\fR that can take appropriate measures.
.IP \*(MK
The semantics of the \*<return-expression\*> is such that the execution
of the procedure in which it occurs is terminated and that execution
is to be continued at the place of invocation.
This is reflected by the signal values \fIFR\fR and \fINR\fR, that are only
\fBgenerated\fP by \*<return-expression\*>s and are only \fBhandled\fP
by the semantic rules associated with procedure calls.
The latter rules turn \fINR\fR into \fIN\fR and \fIFR\fR into \fIF\fR before
the evaluation process
is resumed at the point where it left off to perform the (by then completed)
procedure call.
All other semantic rules return immediately when an \fINR\fR
or \fIFR\fR signal occurs.
.br
.ne 6
.SH 4.2.5. "Some examples"
.SH 4.2.5.1. "If expressions"
.PP
An \*<if-expression\*> corresponds to the if-then-else statement found
in most programming languages.
If evaluation of the \*<test\*> immediately contained in the
\*<if-expression\*> terminates successfully, the \*<block\*>
following \fBthen\fR is evaluated.
If a \*<return-expression\*> was encountered during evaluation of the \*<test\*>,
then the evaluation of the \*<if-expression\*> as a whole is terminated.
Otherwise, the \*<test\*>s following subsequent \fBelif\fRs
are evaluated until
.XP 0.5
.IP \*(MK
one such evaluation terminates successfully
(the \*<block\*> in the following \fBthen\fR-part is then evaluated), or
.IP \*(MK
a \*<return-expression\*> is encountered during evaluation of the \*<test\*>
(the evaluation of the \*<if-expression\*> as a whole is then terminated), or
.IP \*(MK
the list of \*<test\*>s is exhausted.
.XP 0.5
.LP
In the last case, the \*<if-expression\*> may contain
an \fBelse\fR-part and if so the \*<block\*> following \fBelse\fR is evaluated.
The formal definition is:
.XP 1
.sp 1
.D{
.nm 1
.{{
\fBif\fR \jg{{ \fIe\fR =\h'-0.3m'= \jh\s-2IF\s0 \ji\fIt\fR:\*<test\*> \s-2THEN\s0 \jj\fIb\fR:\*<block\*>
\h'|\nhu'\fIelifpart\fR: (\s-2ELIF\s0 \jk\*<test\*> \s-2THEN\s0 \jl\*<block\*>)\v'0.25m'*\v'-0.25m'
\h'|\nhu'\fIelsepart\fR: [\s-2ELSE\s0 \jk\*<block\*>] \s-2FI\s0 \jl}}
\fBthen\fR
\h'|\ngu'\fBvar\fR \jm\fIv\fR, \fIsig\fR;
\h'|\ngu'[\fIv\fR, \fIsig\fR] := \fIeval\fR\^(\fIt\fR);
\h'|\ngu'\fBif\fR \jn\fIsig\fR = \fIN\fR
\h'|\ngu'\fBthen\fR
\h'|\nnu'\fIreturn\fR\^(\fIeval\fR\^(\fIb\fR))
\h'|\ngu'\fBelif\fR \jo\fIsig\fR = \fIFR\fR | \fIsig\fR = \fINR\fR
\h'|\ngu'\fBthen\fR
\h'|\nnu'\fIreturn\fR\^(\^[\fIv\fR, \fIsig\fR]\^)
\h'|\ngu'\fBelse\fR
\h'|\nnu'\fBvar\fR \jp\fIoneelif\fR;
\h'|\nnu'\fBfor\fR \jp\fIoneelif\fR \fBin\fR \jq\fIelifpart\fR
\h'|\nnu'\fBdo\fR \jr{{ \fIoneelif\fR =\h'-0.3m'= \js\s-2ELIF\s0 \jj\fIt\fR:\*<test\*> \s-2THEN\s0 \jt\fIb\fR:\*<block\*> }} ;
\h'|\nru'[\fIv\fR, \fIsig\fR] := \fIeval\fR\^(\fIt\fR);
\h'|\nru'\fBif\fR \ju\fIsig\fR = \fIN\fR
\h'|\nru'\fBthen\fR
\h'|\nuu'\fIreturn\fR\^(\fIeval\fR\^(\fIb\fR))
\h'|\nru'\fBelif\fR \ji\fIsig\fR = \fIFR\fR | \fIsig\fR = \fINR\fR
\h'|\nru'\fBthen\fR
\h'|\nuu'\fIreturn\fR\^(\^[\fIv\fR, \fIsig\fR]\^)
\h'|\nru'\fBfi\fR
\h'|\nnu'\fBod\fR;
\h'|\nnu'\fBif\fR \jr{{ \fIelsepart\fR =\h'-0.3m'= \jv\s-2ELSE\s0 \jw\fIb\fR:\*<block\*> }}
\h'|\nnu'\fBthen\fR
\h'|\nru'\fIreturn\fR\^(\fIeval\fR\^(\fIb\fR))
\h'|\nnu'\fBelse\fR
\h'|\nru'\fIreturn\fR\^(\^[\fIa\*_undefined\fR, \fIN\fR\|]\^)
\h'|\nnu'\fBfi\fR
\h'|\ngu'\fBfi\fR
\fBfi\fR;
.}}
.nm
.D}
.sp 1
The parse expression in lines 1-3 decomposes the string value of \fIe\fR
into several parts.
In line 6 the \*<test\*> of the \*<if-expression\*> is evaluated.
If this evaluation produces the signal \fIN\fR, the \*<block\*>
following \fBthen\fR is evaluated.
The occurrence of the signals \fINR\fR or \fIFR\fR
(denoting the occurrence of a \*<return-expression\*>)
terminates the evaluation of the \*<if-expression\*> (lines 10, 21).
The loop in lines 15-25 iterates over the successive \*<test\*>s and
describes the semantics as explained above.
If all \*<test\*>s fail, the (optional) \fBelse\fR-part is evaluated in lines 26-31.
.PP
For a better understanding of the above definition, it may be useful to note
that parts of the source program are parsed \fBrepeatedly\fP during \fBone\fP
evaluation of a given \*<if-expression\*>.
For example, the \*<block\*> following an \fBelif\fR is parsed both
in lines 2 and 16.
(This explains, by the way, why the parse expression in line 16 need
not be contained in an if statement, see Section 4.2.4.).
In general, the source text of the \*<if-expression\*> is parsed \fBeach\fP
time that it is evaluated.
.SH 4.2.5.2. "Variable declarations"
.PP
A \*<variable-declaration\*> introduces a series of new variables into 
the current environment, i.e. names of locations whose contents
may be inspected and/or modified.
The declaration may contain \*<expression\*>s whose values are to be used
for the initialization of the declared variables.
In the formal definition, this is described by appending all
variable initializations in the current \*<block\*> to the
variable \fIvarinit\fR and by evaluating the string value of that
variable before the evaluation of the subsequent
\*<expression\*>s in the \*<block\*>.
The formal definition of \*<variable-declaration\*>s is:
.sp 1
.D{
.nm 1
.{{
\fBif\fR \jg{{ \fIe\fR =\h'-0.3m'= \jh\s-2VAR\s0 \ji\fIvarlist\fR:{\*<variable-initialization\*> \(fm\fI,\fR\^\(fm }+ \(fm\fI;\fR\^\(fm }}
\fBthen\fR
\h'|\ngu'\fBvar\fR \jj\fIname\fR, \fIonevar\fR;
\h'|\ngu'\fBfor\fR \jj\fIonevar\fR \fBin\fR \jk\fIvarlist\fR
\h'|\ngu'\fBdo\fR \jl\fBif\fR \jm{{ \fIonevar\fR =\h'-0.3m'= \jn\fIname\fR:\*<identifier\*> \(fm\fI:=\fR\^\(fm \*<expression\*> }}
\h'|\nlu'\fBthen\fR
\h'|\nmu'\fIvarinit\fR := \fIvarinit\fR || \fIv\fR || \(fm\fI;\fR\^\(fm
\h'|\nlu'\fBelse\fR
\h'|\nmu'{{ \fIonevar\fR =\h'-0.3m'= \jn\fIname\fR:\*<identifier\*> }}
\h'|\nlu'\fBfi\fR;
\h'|\nlu'\fIENV\fR.\fIbind\fR\^(\fIname\fR, \fISTATE\fR.\fIextend\fR\^(\fIa\*_undefined\fR\|))
\h'|\ngu'\fBod\fR;
\h'|\ngu'\fIreturn\fR\^(\^[\fIa\*_undefined\fR, \fIN\fR\|]\^)
\fBfi\fR;
.}}
.nm
.D}
.sp 1
In line 1, \fIe\fR is decomposed into an array of strings which have
the form of a \*<variable-initialization\*>.
These string values are considered in succession in the loop in lines 4-12.
If the \*<variable-initialization\*> contains an initializing
expression, that expression is appended to \fIvarinit\fR (line 7)
using the string concatenation operator `||'.
Finally, the state \fISTATE\fR is \fBextend\fPed with a location containing
an undefined value, and that new location is \fBbound\fP, in the current
environment \fIENV\fR, to the identifier being declared.
Note that, in line 9, \fIv\fR is known to have the form of an \*<identifier\*>.
.SH 4.2.5.3. "Blocks"
.PP
A \*<block\*> introduces a new scope to be used for the declaration of
new variables and constants.
It consists of a (perhaps empty) list of declarations followed
by a sequence of expressions separated by semicolons.
A \*<block\*> is evaluated as follows:
.IP \*(MK
Evaluate all declarations (this can never fail).
.IP \*(MK
Evaluate all variable-initializations resulting from the evaluation
of the declarations.
If this evaluation is not completed successfully, the evaluation of the \*<block\*>
is terminated.
.IP \*(MK
Evaluate the sequence of expressions in the \*<block\*>.
S\s-2UMMER\s0 forbids the failure of an expression inside
a sequence of expressions.
Only the last expression in a sequence is allowed to fail; this failure
is passed upwards to enclosing language constructs.
If a \*<return-expression\*> is encountered during evaluation of one of the
\*<expressions\*>s, the evaluation of the \*<block\*> is terminated.
.LP
The formal definition is:
.sp 1
.D{
.nm 1
.{{
\fBif\fR \jg{{ \fIe\fR =\h'-0.3m'= \jh\fIdecllist\fR:  \ji\*<variable-declaration\*>\v'0.25m'*\v'-0.25m'
\h'|\nhu'\fIexprlist\fR:\h'|\niu'{[\*<expression\*>] \(fm\fI;\fR\^\(fm}\v'0.25m'*\v'-0.25m' }}
\fBthen\fR
\h'|\ngu'\fBvar\fR \jj\fIdecl\fR, \fIexpr\fR, \fIENV1\fR, \fIi\fR, \fIvarinit1\fR, \fIsig\fR;
\h'|\ngu'\fIENV1\fR := \fIENV\fR;
\h'|\ngu'\fIENV\fR.\fInew\*_inner\*_scope\fR;
\h'|\ngu'\fIvarinit1\fR := \fIvarinit\fR;
\h'|\ngu'\fIvarinit\fR := \(fm\fI\fR\^\(fm ;
\h'|\ngu'\fBfor\fR \jj\fIdecl\fR \fBin\fR \jk\fIdecllist\fR \fBdo\fR \jl[\fIv\fR, \fIsig\fR] := \fIeval\fR\^(\fId\fR\|) \fBod\fR;
\h'|\ngu'[\fIv\fR, \fIsig\fR] := \fIeval\fR\^(\fIvarinit\fR);
\h'|\ngu'\fIvarinit\fR := \fIvarinit1\fR;
\h'|\ngu'\fBif\fR \jm\fIsig\fR \(ap\h'-0.2m'= \fIN\fR \fBthen\fR \jn\fIENV\fR := \fIENV1\fR; \fIreturn\fR\^(\^[\fIv\fR, \fIsig\fR]\^) \fBfi\fR;
\h'|\ngu'\fBfor\fR \jj\fIi\fR \fBin\fR \jo\fIexprlist\fR.\fIindex\fR
\h'|\ngu'\fBdo\fR \jm[\fIv\fR, \fIsig\fR] := \fIeval\fR\^(\fIexprlist\fR\^[\fIi\fR\|]\^);
\h'|\nmu'\fBcase\fR \jh\fIsig\fR
\h'|\nmu'\fBof\fR  \jp\fIN\fR:\h'|\nnu'\*# nothing to do \jq\*#,
\h'|\npu'\fIF\fR:\h'|\nnu'\fBif\fR \jr\fIi\fR \(ap\h'-0.2m'= \fIexprlist\fR.\fIsize\fR \(mi 1 \fBthen\fR \js\fIERROR\fR \fBfi\fR,
\h'|\npu'\fINR\fR: \fIFR\fR:\h'|\nnu'\fIENV\fR := \fIENV1\fR; \fIreturn\fR\^(\^[\fIv\fR, \fIsig\fR]\^)
\h'|\nmu'\fBesac\fR
\h'|\ngu'\fBod\fR;
\h'|\ngu'\fIENV\fR := \fIENV1\fR;
\h'|\ngu'\fIreturn\fR\^(\^[\fIv\fR, \fIsig\fR]\^)
\fBfi\fR;
.}}
.nm
.D}
.sp 1
This definition is a simplified version of the one given in part II.
In lines 5-8 local copies are made of \fIE\fR and \fIvarinit\fR
and new values are assigned to them.
In lines 9-12 the list of \*<variable-declaration\*>s in the \*<block\*>
and the resulting \*<variable-initialization\*>s are evaluated.
In lines 13-20 the list of \*<expression\*>s in the \*<block\*> is evaluated.
Note how failure of an expression in the middle of the list
is treated (line 17, see above).
.SH 4.3. "Assessment"
.PP
The formal language definition presented in the previous section will now
be assessed.
It is tempting to try to get statements like:
.sp 0.5
.IP "" 3
\fIUsers can answer 87% of their questions on language issues
within five minutes if they have access to a formal language definition
of the kind described in this chapter.\fP
.LP
or
.IP "" 3
\fI35% of all run-time errors in user programs are directly related to
anomalies in the language definition.\fP
.sp 0.5
.LP
In the absence of such results and without methods of obtaining them,
we have to live with qualitative and more or less
speculative observations.
.PP
A rough indication of the \fBconciseness\fP
of the definition can be obtained by comparing various sizes
as they apply to the \s-2SUMMER\s0 definition:
.DS I
.ta 6c
formal definition	\020 pages
reference manual	100 pages
implementation	200 pages
.DE
These figures show that the implementation is ten times larger
than the formal definition.
This is not surprising, since the implementation has
to be efficient while the formal definition does not have to be.
In this light the `a-language-is-defined-by-its-implementation' approach
can be rephrased
as: `\fBif\fP a language
is defined by its implementation,
\fBthen\fP that implementation had better be small'.
.PP
The definition is \fBprecise\fP and \fBcomplete\fP, in the sense that \fBall\fP
semantic operations associated with a particular language construct
\fBhave\fP to be specified to allow the construction of an
\fBexecutable\fP version of the definition.
The number of \fBoperational details\fP,
i.e. details in the definition which stem from the chosen definition method and
are not a reflection of details of the defined language, are surprisingly small.
This is a consequence of the choice of
the definition language (which should have powerful data types and
string manipulation operations) and the choice
of high-level environment
manipulation primitives which correspond directly to operations
in the defined language and which are not (yet)
perverted by implementational details.
S\s-2UMMER\s0, extended with parse expressions, seems a quite reasonable
vehicle for language definition.
However, it is not possible to make `continuation-style' (see [Gordon79])
definitions, since higher-order functions are lacking.
.PP
It is difficult to give an objective judgement as to the \fBreadability\fP
of the definition,
but we have observed that only a moderate effort (of a few days)
is required on the part of a programmer without any training
in formal semantics, and without any previous exposure to the
language, to learn \s-2SUMMER\s0 using only the (annotated) formal
definition.
.PP
The advantages and disadvantages of the formal definition for designer,
implementor and user
will now be discussed in some detail.
.br
.ne 4
.LP
The advantages for the \fBdesigner\fP are:
.IP \*(MK
Anomalies in the design are magnified.
It is a general rule that ill-formed entities can only be described by
ill-formed descriptions or by descriptions which list many exceptional cases.
It is easier to locate such exceptions or anomalies in a concise formal definition
than in an ambiguous natural language definition or in a bulky implementation.
In the \s-2SUMMER\s0 definition, for example, a very specific operation on
environments is needed (`partial-state-copy') to accommodate the definition
of just one language feature (`try-expression').
It turned out that
a slight modification of that feature would
at the same time simplify the definition
and improve the feature.
.IP \*(MK
Exhaustive enumeration of language features.
A formal definition method forces the designer to enumerate all
language features in the same framework and
this may help him to find omissions in the design.
.IP \*(MK
Interactions between language features can be studied.
In the \s-2SUMMER\s0 definition, for example, the designer is forced to
decide what happens when a \*<return-expression\*> is evaluated
during the evaluation of any other expression.
There is, however, no guarantee that all interactions can be found,
since the formal definition may still contain hidden interactions between
language features.
The use of auxiliary functions in the definition is an aid in making
interactions explicit.
One may even apply techniques
such as calling graph analysis and data flow analysis to the
definition to discover clusters of interacting features
and to establish certain properties of the definition.
.IP \*(MK
An executable formal definition can be tested and used.
This may help eliminate
clerical and gross errors from the definition.
An executable definition allows the designer to play with (toy) programs
written in the language he is designing.
There is, however, a problem with circular definitions:
some implementation of the defined language has to exist before
the definition itself can be made executable.
.br
.ne 6
.LP
Disadvantages for the \fBdesigner\fP are:
.IP \*(MK
A considerable effort is required to construct a formal definition.
.IP \*(MK
A general problem is that
there are no canned, satisfactory definition methods available and
that the designer has to begin with either creating a new method or adapting and
extending an existing one.
.br
.ne 6
.LP
Advantages for the \fBimplementor\fP are:
.IP \*(MK
Unambiguous language definition.
.IP \*(MK
The implementor may stumble over a certain combination of features.
Such cases can be executed both by the implementation and by the definition
and the results can be compared.
.br
.ne 6
.LP
Disadvantages for the implementor are:
.IP \*(MK
The implementor must be familiar with the definition method
or become acquainted with it.
This is only a minor effort if one compares it with the total effort
required to implement the language.
.IP \*(MK
It is non-trivial to derive an implementation strategy from the
language definition.
This is a problem shared by all `abstract' language definitions,
in which no attempt is made to use primitives in the definition
with a direct counterpart in an implementation.
This leads to the conclusion that such abstract definitions should
be accompanied by an `annotation for implementors', which states
where well-known implementation techniques can be used and where
certain optimizations are possible.
.br
.ne 6
.LP
Advantages for the \fBuser\fP are:
.IP \*(MK
Unambiguous and concise language definition.
.IP \*(MK
The user is used to reading programs and the formal definition can be read
as such.
In the case of a circular definition,
the formal definition may be considered as a very informative
example program.
.br
.ne 6
.LP
Disadvantages for the \fBuser\fP are:
.IP \*(MK
The user must be exposed to the definition method.
.IP \*(MK
A formal definition is harder to read than a `natural language' definition.
.IP \*(MK
In the case of the \s-2SUMMER\s0 definition,
the circularity may be confusing for the naive user.
.PP
In retrospect, it seems justified to conclude that the method presented
in this chapter is a first step in satisfying the requirements given
in Section 4.1.
However, many problems remain to be investigated.
Does the method given lend itself to mathematical analysis?
How can the `complexity' of a language be derived from its definition?
Is it possible to `optimize' the executable version of definitions?
Attempts in this direction can be found in [Jones80].
What is the relationship between this definition method
and extensible languages?
Answers to these questions will provide more insight into the
structure of programming languages and the methods of defining them.
.SH 4.4. "References for Chapter 4"
.so refs/Gordon79
.so refs/Jones80
.so refs/Klint81a
.so refs/Landin64
.so refs/Marcotty76
.so refs/Reynolds72
.so refs/Wegner72

.EC

.NC 5 "ASSESSMENT" " "
.ds LH ASSESSMENT
.SH 5.1. "Looking backward"
.PP
We have come a long way since we began considering string processing
in Chapter 1.
In Chapter 2, formal techniques were
used to analyze the pattern matching method of \s-2SNOBOL\s04.
Special attention was paid to
the confusion that can arise from side-effects due to failing
attempts during a pattern match.
As a result of this analysis, a new model for side-effect recovery
was designed and formally described.
.PP
This model, together with new insights of
how string processing should be incorporated into a programming language,
led to the design of the language \s-2SUMMER\s0 (Chapter 3).
In order to define the semantics of \s-2SUMMER\s0 formally,
an improved method for operational language definitions was
developed in Chapter 4.
.PP
In the current chapter we evaluate the results of this research
and indicate some directions for further investigation.
.SH 5.1.1. "S\s-2UMMER\s0 as a language"
.PP
Language design and compromise are almost synonymous.
A language designer has to reconcile simplicity, expressive power,
orthogonality, economy of concepts, anticipated application area,
tradition, style, taste,
implementation considerations, experience, enthusiasm and
available time (to mention but a few) with each other when designing a new language.
Compromises are thus inevitable.
Evidence of this kind of compromise can also be found in \s-2SUMMER\s0.
Some weak points of \s-2SUMMER\s0 are:
.IP \*(MK
Certain useful language features (like procedure variables
and advanced array operations)
were omitted in favour of simplicity.
.IP \*(MK
A very general notion of `subject' was included in the language.
This generality has (so far) not been fully exploited.
.IP \*(MK
Try-expressions do not recover the values of local variables in the `current'
procedure.
This inelegant way of obtaining information from an attempt that failed
was dictated by implementation considerations.
It would have been more elegant to include in the try-expression
an explicit list of variables whose values should \fBnot\fP be recovered.
.IP \*(MK
The mechanism to control access to class instances
(fetch- and store-associations) is too complicated.
.IP \*(MK
The string scanning functions in \s-2SUMMER\s0 are based on the functions for lexical
scanning as found in \s-2SNOBOL\s04.
It would have been better to design a new set of higher level primitives
for string scanning.
.IP \*(MK
Some cosmetic changes should be made to the syntax.
.IP \*(MK
The system of dynamic types used is adequate.
However, a slightly more restrictive type system
would make static type checking much easier.
In such a system, variables may still have values of arbitrary type, but
as soon as a variable has received a value of a certain type,
only values of that particular type may be assigned to it.
.LP
Some strong points of \s-2SUMMER\s0 are:
.IP \*(MK
Expression evaluation and pattern matching have been completely unified,
resulting in a substantial reduction in the number of language primitives.
.IP \*(MK
Incorporation of failure handling into the expression evaluation mechanism
leads to a concise notation, since the same expression can either
compute a result or produce a failure signal.
.IP \*(MK
The language is based on a consistent view of side-effect recovery, thus
eliminating the problems with immediate/conditional side-effects found
in \s-2SNOBOL\s04.
It turned out that the `recovery cache' could be used effectively to implement
side-effect recovery.
.IP \*(MK
The use of `classes' as a data abstraction mechanism
was a good choice.
Amongst other things, this allowed us to cast the notion of `subject string'
and `string pattern matching' into a more general framework.
.LP
Despite the mentioned shortcomings, experience shows that \s-2SUMMER\s0 is
a convenient, easy to learn, language.
The language has been used for the implementation of assemblers,
compilers, preprocessors, a parser generator [Florijn81],
a system for automatic type inference and data flow analysis [VanDijk83],
a language-independent pretty-printing system [Kroeze82],
a generator for simulators for microprogrammable computer architectures
[Oostman82],
a compiler for a subset of \s-2SUMMER\s0 that generates code for
the Manchester data flow machine [Veen85]
and a type checker for an algebraic specification formalism.
.SH 5.1.2. "The \s-2SUMMER\s0 implementation"
.PP
\s-2SUMMER\s0-programs are compiled into abstract machine programs.
These are subsequently executed by an interpreter
[Klint79a, Klint79b, Klint81b].
The compiler is written in \s-2SUMMER\s0 itself [Sint80].
.PP
The \s-2SUMMER\s0 implementation is reliable, gives good error messages, but is slow.
Users tend to complain mostly about long compilation times.
The compiler is slow because it is written in \s-2SUMMER\s0 itself
(and is thus being interpreted)
and because its two constituent parts (a parser and a code generator)
communicate with each other via a common data structure
whose size depends on the size of the source program.
For large programs there is considerable overhead due to garbage collections
during compilation.
Recently, an experimental version of the compiler has been constructed
that allows separate compilation of programs [Bekius84].
.PP
In most cases, the efficiency of \s-2SUMMER\s0 programs seems to be acceptable.
Generally speaking, one can say that programs which run slowly
are those which perform low level operations and do not use the higher level
facilities offered by the language.
.SH 5.1.3. "Use of a formal definition"
.PP
The semantics of \s-2SUMMER\s0 were formally described after the language
had been completely designed.
A considerable effort was required to develop a formal description method
and to produce a formal description of the language.
This effort, though much larger than anticipated, payed off:
much insight was gained into the structure of the language and
into errors or omissions in the design.
Three lessons can be learned from this:
.IP \*(MK
Language design and formal definition should proceed hand in hand.
.IP \*(MK
The language implementation should be derived (in some automatic way)
from the formal definition.
In that way one can avoid inconsistencies or incompatibilities
between definition and implementation.
.IP \*(MK
Several language definition methods first convert the program to be defined
to an intermediate form that is more suitable to operate on.
The `parse expressions' used in the formal definition of \s-2SUMMER\s0
operate directly on the source text of the program to be defined,
thus eliminating the extra conversion step and simplifying the definition.
.LP
Recently, we have experimented with the use of algebraic specification
techniques for defining programming languages [Bergstra85].
.XP 0.5
.SH 5.2. "Looking forward"
.PP
The research described in this monograph can be continued in the
direction of both
\fBexecutable language definitions\fP and \fBprogramming environments\fP.
.PP
\fBExecutable language definitions\fP are a valuable tool for the language
designer as was explained in Chapter 4.
The method used in the \s-2SUMMER\s0 definition could be improved in several ways:
.XP 0.25
.IP \*(MK
The method is not suited to the formulation (or proof) of
properties of a given language definition.
This can be cured by eliminating some operational aspects from the method.
.IP \*(MK
The method leads to intolerably inefficient implementations.
There are two major sources of this inefficiency.
First of all, statements are parsed every time they are executed.
This can be avoided in several ways:
one can either translate the source text to an intermediate form
or maintain a `cache' of pieces of source text that have already been parsed.
Secondly, a very general and expensive technique is used
to implement environment modifications.
Special properties of a language
(for example, the property that environments can be implemented on a stack)
are not exploited.
It is a non-trivial task to extract such optimization information
from a given language definition.
.XP 0.25
.PP
A \fBprogramming environment\fP is an interactive computer system
dedicated to the development and documentation of programs.
When \s-2SUMMER\s0 was being designed the idea was, that, for the sake of portability,
its interface with the host operating system should be kept as simple as possible.
Thinking on a dedicated \s-2SUMMER\s0 environment started only after the
design of the language was complete.
It quickly turned out that the original austere file system interface
was inadequate for use in an integrated environment.
More specifically, one would like to exploit the `class' mechanism
not only locally in programs, but also at the level of external files.
Besides leading to an integration of `internal' and `external'
data types, this further suggested the use of \s-2SUMMER\s0 as a command language.
At the same time, we noted a strong similarity between the language
of the symbolic debugger in the \s-2SUMMER\s0 system and \s-2SUMMER\s0 itself.
.PP
Although the analogies were strong in both cases, it was also evident
that \s-2SUMMER\s0 could not play the role of a unified command/programming/debugging
language without extensive modification.
The advantage to be gained was clear: a highly uniform
programming environment.
But the problems involved seemed many and we therefore decided to
concentrate, not on the modification of \s-2SUMMER\s0,
but, more generally, on the basic principles underlying
\fBmonolingual\fP systems, i.e. systems in which the command language,
the programming language, and the language of the symbolic debugger
are identical.
This has resulted in [Heering81].
.PP
Even within the monolingual framework,
it remains necessary to add new application languages to a system.
It seems therefore logical to consider \fBlanguage definitions\fP
as the unifying language level in a system.
As a preparation for this line of research, [Klint83] gives
a comparison of three language-independent programming environments:
Mentor [Donzeau-Gouge75, Donzeau-Gouge80],
The Synthesizer Generator [Reps82, Reps83] and Ceyx [Hullot83].
More recently, an algebraic specification has been constructed
of a simple programming language [Bergstra85].
This specification defines lexical analysis, parsing, syntax tree construction,
type checking and execution of programs.
.XP 0.5
.SH 5.3. "References for Chapter 5"
.so refs/Bekius84
.so refs/Bergstra85
.so refs/Donzeau-Gouge75
.so refs/Donzeau-Gouge80
.so refs/Heering81
.so refs/Hullot83
.so refs/Klint79a
.so refs/Klint79b
.so refs/Klint81b
.so refs/Klint83
.so refs/Kroeze82
.so refs/Oostman82
.so refs/Reps82
.so refs/Reps83
.so refs/Sint80
.so refs/VanDijk83
.so refs/Veen85

.EC
