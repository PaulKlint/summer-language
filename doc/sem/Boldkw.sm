# Boldkw -- insert troff commands in SUMMER program #

const letter := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
const lcase  := 'abcdefghijklmnopqrstuvwxyz';
const ucase  := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

var kwtab := table(30, undefined) init[
'else': 'monadic': 'subclass': 'assert': 'end': 'od': 'begin': 'esac': 'of': 'succeeds':
'case': 'fails': 'op': 'class': 'fetch': 'proc': 'then': 'code': 'fi': 'program': 'try':
'const': 'for': 'default': 'rof': 'until': 'do': 'if': 'scan': 'var':
'dyadic':
'in': 'while': 'elif': 'init': 'store': 'yrt':
	1];
var syntab := table(30, undefined);

proc process_fragment(line)
( scan line
  for
    while put(break(letter))
    do var n := '', w := span(letter);
       if kwtab[w] ~= undefined
       then
          if n := (rpos(0) | any(' \t,;')) then
             put('\\*[', w, '\\*]', n)
	  else
	     put('\\fI', w, '\\fP', n)
	  fi
       elif syntab[w] ~= undefined
       then
          put('\\fR', w, '\\fP')
       else
	  n := '';
	  if n := any('>') then
             put('\\fR', w, '\\fP', n)
	  else
             put('\\fI', w, '\\fP', n)
	  fi
       fi
    od;
    put(rtab(0))
  rof
);

proc process_line(line)
( var sep, pre, inside;

  scan line
  for while pre := break('''#')
      do process_fragment(pre);
         sep := move(1);
         if inside := break(sep) fails
         then
            error('missing "' || sep || '"');
            put(sep)
         else
            move(1);
            if sep = '''' then
               put(sep, '\\fI', inside, '\\fP', sep)
            else
               put(sep, inside, sep);
            fi
         fi
      od;
      process_fragment(rtab(0))
  rof;
);


proc uc(s) return(s.replace(lcase, ucase));

const COPY := 0, FONTS := 1;
var lino := 0;

proc error(s) stand_er.put('Line ', lino, ': ', s, '\n');

program boldkw()
( var f, com, line, state := COPY, lastopen := 0, lastclose := 0;

  for f in kwtab.index do syntab[uc(f)] := 1 od;

  syntab['ARRAY'] := syntab['TABLE'] :=
  syntab['RETURN'] := syntab['FRETURN'] :=
  syntab['FAILS'] := syntab['SUCCEEDS'] :=
  syntab['SELF'] := syntab['SUBJECT'] :=
  syntab['UNDEFINED'] := 1;
  while line := get()
  do lino := lino + 1;
     com := if line.size <= 3 then line else line.substr(0, 3) fi;
     if com = '.{{' then
	lastopen := lino;
	if state ~= COPY then
	   error('nested .{{')
        fi;
        put(line);
        state := FONTS;
     elif com = '.}}' then
        lastclose := lino;
        if state ~= FONTS then
	   error('unmatched .}}')
        fi;
        if line.size > 3 then
           put(line.substr(3, line.size - 3))
        fi;
        put('\n.}}\n');
        state := COPY;
     elif state = COPY then
        var pre, inside;
        scan line
        for while pre := find('\\*{')
            do put(pre);
               lit('\\*{');
               if inside := find('\\*}') fails
               then
                  error('missing \\*}')
               else
                  lit('\\*}');
                  process_line(inside)
               fi
            od;
            put(rtab(0), '\n')
        rof
     elif state = FONTS then
        if com ~= '' & com[0] = '.' then
           put('\n', line)
        else
           put('\n'); process_line(line);
        fi
     else
        error('FATAL ERROR')
     fi
  od;
  if state ~= COPY then
     stand_er.put('Line ', lino, ': .}} missing\n',
                  'Last .{{ at line ',  lastopen,
                  '\nLast .}} at line ', lastclose, '\n')
  fi
)
