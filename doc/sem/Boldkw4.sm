# Boldkw -- insert troff commands in SUMMER program #

var letter := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
var idchar := letter || '0123456789' || '-_';
var lcase  := 'abcdefghijklmnopqrstuvwxyz';
var ucase  := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

var kwtab := table(30, undefined) init[
'else': 'monadic': 'subclass': 'assert': 'end': 'od': 'begin': 'esac': 'of': 'succeeds':
'case': 'fails': 'op': 'class': 'fetch': 'proc': 'then': 'code': 'fi': 'program': 'try':
'const': 'for': 'default': 'rof': 'until': 'do': 'if': 'scan': 'var':
'dyadic':
'in': 'while': 'elif': 'init': 'store': 'yrt':
'PATPAT':	# for the benefit of SPRING programs #
	1];
var reduce_tab := table(50, undefined) init [
  'ARRAY': 'TABLE': 'RETURN': 'FRETURN':
  'FAILS': 'SUCCEEDS': 'SELF' : 'SUBJECT' :
  'UNDEFINED': 'IMSBAS': 'CDSBAS': 'IMACT':
  'CDACT': 'SBAS': 'ACT': 1];

const true := 1, false := 0;

const COPY := 0, PROG := 1,	# COPY: literally copying text #
      SYN := 2;			# PROG: expanding program text #
				# SYN:  expanding syntax rules #
var lino := 0;			# linenumber in source text #

const REGSTART := 5;		# to avoid strange "f" reg in Troff #
var registers := array(128, -1), maxreg := REGSTART;

proc mark(fill)
( var reg, n;

  put(fill);
  n := cursor;
  if (reg := registers[n]) = -1
  then
     maxreg := maxreg + 1;
     registers[n] := reg :=  maxreg
  fi;
  put('\\j', letter[reg]);
);


proc goto(fill)
( var n;

  n := cursor;
  if registers[n] = -1
  then
     put(fill);
     mark('');
  else
     put('\\h''|\\n', letter[registers[n]], 'u''')
  fi
);

proc process(line)
( var pre, inside, first;

  scan line
  for
    while ~rpos(0)
    do
      if pre := any(letter) then identifier('', pre)
      else
         case first := move(1) of
         ' ':  if pre := span(' ') then goto(pre || ' ') else put(' ') fi,
         '''': var inside;
               put('\\(fm\\fI');
               if any(letter) then move(-1); put('\\h''-0.1m''') fi;
               if inside := break('''') fails then
                  error('missing "''"'); put('''')
               else
                  lit('''');
                  beatify(inside);
                  if inside.size > 0 then
                     case inside[inside.size-1]
                     of 'd': 'f': 'l': 'i': 'N': 'T': put('\\^')
                     default:
                     esac
                  fi;
                  put('\\fR\\^\\(fm');
                  if any(')]') then move(-1); put('\\^') fi
               fi,
         '#':  if inside := break('#') fails then
                  error('missing "#"'); put('\\*#');
               else
                  put('\\*#');
                  beatify(inside);
                  mark('');
                  put('\\*', lit('#'));
               fi,
         '<':  if pre := any(letter) then
                  identifier('<', pre)
               else
                  put('<')
               fi
         default:
               one_beatify(first)
         esac
      fi
    od;
  rof
);

proc identifier(angle, pre)
( var w, sep;

  w := pre || (span(idchar) | '');
  if kwtab[w] ~= undefined & angle = ''
  then
     if w = 'PATPAT' then w := 'pat' fi;
     put('\\fB', w, '\\fR');
     if sep := span(' ') then mark(sep) fi
  elif reduce_tab[w] ~= undefined
  then
     reduce(w);
     if sep := span(' ') then mark(sep); fi
  elif angle = '<'  & lit('>') then
       put('\\*<'); put(w); put('\\*>');
  else
     put(angle, '\\fI');
     beatify(w);
     put('\\fR');
     if any(')]') then
        move(-1);
        case w[w.size-1]
        of 'd': 'l': 'i': 'N': 'T': 'F': 'M': 'V': put('\\|'),
           'f': put('\\|\\|')
        default:
        esac
     elif any('([') then
        move(-1);
        case w[w.size-1]
        of 'f': put('\\|\\|')
        default: put('\\^')
        esac
     fi
  fi
);

proc one_beatify(first)
( case first of
  '=':   if lit('<') then put('=\\h''-0.2m''<')
         elif lit('>') then put('=\\h''-0.2m''>')
         elif lit('=')
         then
            var pre;
            put('=\\h''-0.3m''=');
            if pre := span(' ') then mark(pre) fi
         else
            put('=')
         fi,
  '-':   if lit('-') then put('\\(mi\\h''-0.2m''\\(mi')
	 elif rpos(0) then put('-')
         elif lit('>') then put('\\(->')
	 elif any(letter) then move(-1); put('-')
         else put('\\(mi')
         fi,
  '+':   if lit('+') then put('+\\h''-0.15m''+')
         else put('+')
         fi,
  '.':   var c, pre;
         if pre := span('.') then
            for c in pre do put('.\\ ') od
         fi;
         put('.'),
  '*':   put('\\v''0.25m''*\\v''-0.25m'''),
  '_':   put('\\*_'),
  '~':   put('\\(ap');
         if lit('=') then put('\\h''-0.2m''=') fi,
  '\\':  put('\\v''-0.25m''\\s-2\\\\\\s0\\v''0.25m'''),
  '@':   put('\\v''-0.25m''\\s-2@\\s0\\v''0.25m''\\^'),
  '(':   if lit(')')
         then put('(\\^)')
         elif lit('[') then put('(\\^[')
         elif cursor = 1
         then var pre;
            put('\\z( ');
            if pre := span(' ') then
               mark(pre)
            else
               mark('')
            fi
         else
            var after;
            put('(');
            if after := any('fgjpy') then
               move(-1);
               put(if after = 'f' then '\\|\\|' else '\\^' fi)
            fi
         fi,
   ')':  if lit('(') then
            move(-1); put(')\\^')
         else
            put(')')
         fi,
   '[':  var after;
         put('[');
         if after := any('fgjpy') then
            move(-1);
            put(if after = 'f' then '\\|\\|' else '\\^' fi)
         fi,
   ']':  if lit(')') then
            put(']\\^)')
         else
            put(']');
         fi
   default:
         put(first)
   esac
);

proc beatify(w)
( scan w
  for
     while one_beatify(move(1)) do od
  rof
);

proc reduce(w)
( var pre;
  scan w
  for while pre := break(ucase)
      do put(pre, '\\s-2', span(ucase), '\\s0') od;
      put(rtab(0))
  rof
);

proc uc(s) return(s.replace(lcase, ucase));

proc error(s) stand_er.put('Line ', lino, ': ', s, '\n');

proc init_process()
( if maxreg > REGSTART
  then
     registers := array(128, -1);
     maxreg := REGSTART;
  fi
);

proc include_file(line)
( var fname, f, l;

  fname := scan line for move(3) & span(' \t') & rtab(0) rof;
  if f := file(fname, 'r') fails then
  error('Cannot open "' || fname || '"')
  else
     while l := f.get do process(l); put('\n') od;
     f.close
  fi
);

program boldkw()
( var f, com, line, mode := COPY, lastopen := 0, lastclose := 0;

  for f in kwtab.index
  do var u := uc(f);
     reduce_tab[u] := 1;
  od;

  while line := get()
  do lino := lino + 1;
     com := if line.size <= 3 then line else line.substr(0, 3) fi;
     case com of
     '.{{': lastopen := lino;
	    if mode ~= COPY then error('nested .{{') fi;
            put(line);
            mode := PROG;
            init_process(),
     '.}}': lastclose := lino;
            if mode ~= PROG then error('unmatched .}}') fi;
            put('\n.}}\n');
            mode := COPY,
     '.<<': if mode ~= COPY then error('nested .<<') fi;
            put(line, '\n');
            mode := SYN;
            init_process(),
     '.>>': if mode ~= SYN then error('unmatched .>>') fi;
            put(line, '\n');
            mode := COPY
     default:
            case mode of
            COPY: var pre, inside;
                  scan line
                  for while pre := find('\\*{')
                      do put(pre);
                         lit('\\*{');
                         if inside := find('\\*}') fails then error('missing \\*}')
                         else
                            lit('\\*}');
      		            init_process();
                            process(inside)
                         fi
                      od;
                      put(rtab(0), '\n')
                  rof,
            PROG: if com = '.so' then put('\n'); include_file(line)
		  elif com = '' then put('\n.sp 0.5')
                  elif com[0] = '.' then put('\n', line)
                  else
                       put('\n'); process(line);
                  fi,
            SYN:  if com = '.so' then include_file(line)
                  elif com = '' then put('.sp 0.5\n')
                  elif com[0] = '.' then put(line, '\n')
                  else
	             process(line); put('\n');
                  fi
            default:
                  error('FATAL ERROR')
            esac
     esac
  od;
  if mode ~= COPY then
     stand_er.put('Line ', lino, ': .}} missing\n',
                  'Last .{{ at line ',  lastopen,
                  '\nLast .}} at line ', lastclose, '\n')
  fi
)
