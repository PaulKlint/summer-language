# Boldkw -- insert troff commands in SUMMER program #

const letter := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
const lcase  := 'abcdefghijklmnopqrstuvwxyz';
const ucase  := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

var kwtab := table(30, undefined) init[
'else': 'monadic': 'subclass': 'assert': 'end': 'od': 'begin': 'esac': 'of': 'succeeds':
'case': 'fails': 'op': 'class': 'fetch': 'proc': 'then': 'code': 'fi': 'program': 'try':
'const': 'for': 'default': 'rof': 'until': 'do': 'if': 'scan': 'var':
'dyadic':
'in': 'while': 'elif': 'init': 'store': 'yrt':
'PATPAT':	# for the benefit of SPRING programs #
	1];
var reduce_tab := table(50, undefined) init [
  'ARRAY': 'TABLE': 'RETURN': 'FRETURN':
  'FAILS': 'SUCCEEDS': 'SELF' : 'SUBJECT' :
  'UNDEFINED': 'IMSBAS': 'CDSBAS': 'IMACT':
  'CDACT': 1];

const true := 1, false := 0;

const COPY := 0, PROG := 1,	# COPY: literally copying text #
      SYN := 2;			# PROG: expanding program text #
				# SYN:  expanding syntax rules #
var lino := 0;			# linenumber in source text #

const REGSTART := 5;		# to avoid strange "f" reg in Troff #
var registers := array(128, -1), maxreg := REGSTART;

proc mark(fill)
( var reg, n;

  put(fill);
  n := cursor;
  if (reg := registers[n]) = -1
  then
     maxreg := maxreg + 1;
     registers[n] := reg :=  maxreg
  fi;
  put('\\j', letter[reg]);
);


proc goto(fill)
( var n;

  n := cursor;
  if registers[n] = -1
  then
     put(fill);
     mark('');
  else
     put('\\h''|\\n', letter[registers[n]], 'u''')
  fi
);

proc process(line)
( var pre, inside;

  scan line
  for
    while ~rpos(0)
    do
      if lit(' ') then
         if pre := span(' ') then
            goto(pre || ' ')
         else
            put(' ')
         fi
      elif lit('''') then
         var inside;
         if inside := break('''') fails then
            error('missing "''"');
            put('''')
         else
            lit('''');
            put('\\*`\\fI');
            beatify(inside);
            put('\\fR\\^\\*''')
         fi
      elif lit('#') then
         if inside := break('#') fails then
            error('missing "#"');
            put('\\*#');
         else
            put('\\*#');
            beatify(inside);
            mark('');
            put('\\*', lit('#'));
         fi
      elif lit('<') then
         if pre := any(letter) then
            identifier('<', pre)
         else
            put('<')
         fi
      elif pre := any(letter) then
         identifier('', pre);
      else
         one_beatify()
      fi
    od;
  rof
);

proc identifier(angle, pre)
( var w, sep;

  w := pre || (span(letter) | '');
  if kwtab[w] ~= undefined
  then
     if w = 'PATPAT' then w := 'pat' fi;
     if angle ~= '' then error('keyword a preceeded by "<"') fi;
     put('\\fB', w, '\\fR');
     if sep := span(' ') then mark(sep) fi
  elif reduce_tab[w] ~= undefined
  then
     reduce(w);
     if sep := span(' ') then mark(sep); fi
  elif angle = '<'  & lit('>') then
       put('\\*<'); put(w); put('\\*>');
  else
     put(angle, '\\fI');
     beatify(w);
     put('\\^\\fR')
  fi
);

proc one_beatify()
( if lit('==')
  then
     var pre;
     put('=\\h''-0.3m''=');
     if pre := span(' ')
     then
        mark(pre)
     fi
  elif lit('--')
  then
     put('\\(mi\\h''-0.15m''\\(mi')
  elif lit('->') then put('\\(->')
  elif lit('.') then
     var c, pre;
     if pre := span('.') then
        for c in pre do put('.\\|') od
     fi;
     put('.')
  elif lit('*') then put('\\v''0.2m''*\\v''-0.2m''')
  elif lit('_') then put('\\*_')
  elif lit('-') then put('\\(mi')
  elif lit('~') then put('\\(ap')
  elif lit('\\') then put('\\s-2\\\\\\s0')
  elif lit('([') then put('(\\^[')
  elif lit('])') then put(']\\^)')
  elif lit('()') then put('(\\^)')
  elif cursor = 0 & lit('(')
  then var pre;
       put('\\z( ');
       if pre := span(' ') then
          mark(pre)
       else
          mark('')
       fi
  else
     put(move(1))
  fi
);

proc beatify(w)
( scan w
  for while ~rpos(0)
      do
         one_beatify()
      od
  rof
);

proc reduce(w)
( var pre;
  scan w
  for while pre := break(ucase)
      do put(pre, '\\s-2', span(ucase), '\\s0') od;
      put(rtab(0))
  rof
);

proc uc(s) return(s.replace(lcase, ucase));

proc error(s) stand_er.put('Line ', lino, ': ', s, '\n');

proc init_process()
( registers := array(128, -1);
  maxreg := REGSTART;
);

program boldkw()
( var f, com, line, mode := COPY, lastopen := 0, lastclose := 0;

  for f in kwtab.index
  do var u := uc(f);
     reduce_tab[u] := 1;
  od;

  while line := get()
  do lino := lino + 1;
     com := if line.size <= 3 then line else line.substr(0, 3) fi;
     if com = '.{{' then
	lastopen := lino;
	if mode ~= COPY then error('nested .{{') fi;
        put(line);
        mode := PROG;
        init_process();
     elif com = '.}}' then
        lastclose := lino;
        if mode ~= PROG then error('unmatched .}}') fi;
        put('\n.}}\n');
        mode := COPY;
     elif com = '.<<' then
        if mode ~= COPY then error('nested .<<') fi;
        put(line, '\n');
        mode := SYN;
        init_process();
     elif com = '.>>' then
        if mode ~= SYN then error('unmatched .>>') fi;
        put(line, '\n');
        mode := COPY;
     elif mode = COPY then
        var pre, inside;
        scan line
        for while pre := find('\\*{')
            do put(pre);
               lit('\\*{');
               if inside := find('\\*}') fails
               then
                  error('missing \\*}')
               else
                  lit('\\*}');
		  init_process();
                  process(inside)
               fi
            od;
            put(rtab(0), '\n')
        rof
     elif mode = PROG then
        if com = '' then
           put('\n.sp 0.5')
        elif com[0] = '.' then
           put('\n', line)
        else
           put('\n');
	   process(line);
        fi
     elif mode = SYN then
        if com = '.so' then
           var fname, f, l;
           fname := scan line for move(3) & span(' \t') & rtab(0) rof;
           if f := file(fname, 'r') fails then
              error('Cannot open "' || fname || '"')
           else
              while l := f.get do process(l); put('\n') od;
              f.close
           fi
        elif com = '' then
           put('.sp 0.5\n')
        elif com[0] = '.' then
           put(line, '\n')
        else
	   process(line);
           put('\n');
        fi
     else
        error('FATAL ERROR')
     fi
  od;
  if mode ~= COPY then
     stand_er.put('Line ', lino, ': .}} missing\n',
                  'Last .{{ at line ',  lastopen,
                  '\nLast .}} at line ', lastclose, '\n')
  fi
)
