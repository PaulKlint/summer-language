#							#
# parsgen -- a very simple minded parser generator	#
#							#
# This program takes a grammar, lexical procedures and  #
# a semantic definition as input and transforms them	#
# into an operational "implementation" of the defined	#
# language. This program is completely experimental:	#
# no checks, almost no error messages and so on.	#
# The most notable deficiency is the absence of a check	#
# on the type of input grammar. LL(1) is assumed, but	#
# a parser is even generated when the input grammar does#
# not satisfy the LL(1) conditions.			#
#							#
# Version 80:06:16 -- paulk				#
#							#
# syntactic definition of syntactic notation #

#
grammar		::= rule* .

rule		::= rule-name '::=' rule-body '.' .

rule-body	::= { primary+ '|' }* .

tagged-rule-body::= ( primary | tag ':' primary |
                      tag  (list | compound ['+' | '*']) )* .

tag		::= lower-case-letter (lower-case-letter | digit)* .

primary		::= (terminal-symbol | rule-name | option |
		    list | compound) [ '+' | '*' ] .

option		::= '[' rule-body ']' .

list		::= '{' primary terminal-symbol '}' ( '+' | '*') .


compound	::= '(' rule-body ')' .

terminal-symbol	::= upper-case-letter+ | QUOTE char QUOTE .

rule-name	::= '<' (lower-case-letter | '-')+ '>'.

lower-case-letter ::=
		    'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' |
		    'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' |
		    'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' |
		    'y' | 'z' .

upper-case-letter ::=
		    'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' |
		    'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' |
		    'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' |
		    'Y' | 'Z' .
#
const lcase := 'abcdefghijklmnopqrstuvwxyz',
      ucase := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
      digit := '0123456789';
var   idchar := lcase || ucase || '_' || digit;
var kwtab := table(30, undefined);

proc mk_while(e1, e2)
  return(' while ' || e1 || ' do ' || e2 || ' od ');

proc mk_asg(l, r)
  return(l || ':=' || r);

proc mk_match(n, r)
  return(mk_asg('pre', 'cursor') || '&(' || r || ')&' ||
         mk_asg('post', 'cursor') || '&' ||
         mk_asg(n, 'tab(pre)') || '&tab(post)' );

proc dupquotes_and_nl(s)
( var a,  t := '';
  scan scan s for ((break('\n') | tab(72)) || ' ...') | rtab(0) rof
  for while a := break('''') do t := t || a || '''''' & move(1) od;
      t := t || rtab(0)
  rof;
  return('\t{ ' || t || ' }\\n')
);

proc grammar ()
( var pre := 0, post := 0, r, nm;
  layout;
  while r := rule
  do post := cursor;
     put('#');
     put(tab(pre).replace('#', '%') , '\n');
     tab(post); pre := post;
     put('#\n');
     put(r)
   od;
   put('\nvar keyword := table(20, undefined) init[\n');
   put('''!filler!'':');
   for nm in kwtab.index 
   do put('\t''', nm, ''':\n')
   od;
   put('\t1];\n')
);

proc rule ()
( var rname, p := '';
  layout & ((rname := rule_name) | freturn) & layout & lit('::=') & layout &
  p := '\nproc ' || rname || '()\n(';
  p := p || rule_body &
  lit('.') & return(p || ');\n')
);

proc tagged_rule_body ()
( var sep := '', result:='', initial, pmatch;

  while ()
  do var r, ident, p, t;
     if p := primary
     then
        r := p
     elif ident := tag then
	layout & lit(':') & layout &
	if any('({') fails then
           r := mk_match(ident, primary)
        else
	   move(-1) &
	   if lit('{') then
	      p := primary & layout & t := terminal_symbol & layout & lit('}')
	   elif lit('(') then
	      p := rule_body & t := '' & layout & lit(')') &
              if any('+-') then move(-1)
              else
                 return(mk_match(ident, p))
              fi
	   fi &
	   initial := mk_asg(ident, 'flex&') &
	   pmatch := mk_asg('pre', 'cursor') || '&(' || p || ')&' ||
		     mk_asg('post', 'cursor') || '&' ||
		     ident || '.append(tab(pre)) & tab(post)' &
	   if lit('+') then
	      r := initial || pmatch || '&' ||
		   if t = '' then
		      mk_while(pmatch, '')
		   else
		      mk_while(t, pmatch)
		   fi
	   elif lit('*') then
	      r := initial ||
                   ' if ' || pmatch || ' then ' ||
		   if t = '' then
		      mk_while(pmatch, '')
		   else
		      mk_while(t, pmatch)
		   fi || ' fi '
	   else
	      freturn
	   fi | freturn
	fi
     else
        if rpos(0) then
	   return(result || '& L ')
        else
	   freturn
	fi
     fi;
     result := result || sep || r;
     sep := '&\n';
   od
);

proc tag ()
( var t;

  if try t := span(lcase || ucase || digit) & layout
     until lit(':') & move(-1) yrt
  then
     return(t)
  else
     freturn
  fi
);

proc rule_body ()
( var sep := '', p := '';

  while lit(sep)
  do p := p || sep || prim1; sep := '|' od &
  return(p)
);
proc primary ()
( var p;
  layout & p := (terminal_symbol | rule_name | option | list |  compound) &
  layout &
  if lit('+') then
     return(p || '&' || mk_while(p, ''))
  elif lit('*') then
     return(mk_while(p, ''))
  else
     return(p)
  fi
);

proc prim1 ()
( var p := '', sep := '';

  p := primary &
  while p := p || '&' || primary do od &
  return(p)
);

proc option ()
( var p;
  layout & lit('[') & layout & p := rule_body &
  layout & lit(']') & return( '(' || p || ' | empty) ')
);
proc list ()
( var p, t, r;
  layout & lit('{') &
  p := primary & t := terminal_symbol &
  layout & lit('}') &
  if lit('+') then
     return(p || '&' || mk_while(t, p))
  elif lit('*') then
     return('if ' || p || ' then ' || mk_while(t, p) || 'fi ')
  fi
);

proc compound ()
( lit('(') & layout &
  return( '(' || rule_body || (layout & lit(')')))
);

proc layout ()
( while span(' \t\n') | lit('#') & break('#') & move(1) do od );

proc rule_name ()
( var nm;
  lit('<') &
  nm := span(lcase || '-').replace('-', '_') &
  lit('>') &
  return(nm)
);


proc squote () lit('''') ;
proc terminal_symbol()
( var c;
  (squote & c := break('''') & move(1) |
  try c := span(ucase) & layout & ~lit(':') yrt &
  c := c.replace(ucase, lcase) & kwtab[c] := 2) &
  return('L&lit(''' || c || ''')&L')
);
proc cant(f)
( stand_er.put('\nCan''t open ', f, '\n');
  stop(1)
);


program parsgen (args)
( var lexname, synname, semname, nargs := args.size , line;
  var lex, syn, sem;

  lexname := if nargs > 0 then args[0] else 'lex.sm' fi;
  synname := if nargs > 1 then args[1] else 'syn.sm' fi;
  semname := if nargs > 2 then args[2] else 'sem.sm' fi;
  if lex := file(lexname,'r')fails then cant(lexname) fi;
  while line := lex.get do put(line, '\n') od;
  if syn := file(synname,'r')fails then cant(synname) fi;
  scan syn for grammar rof;

  if nargs < 3 then
     put('program parse(prog)\n',
         '( scan file(prog[0], ''r'')\n',
         '  for\n',
         '    if summer_program\n',
         '    then\n',
         '      put(prog[0], '' is syntactically correct\\n'')\n',
         '    else\n',
         '      put(prog[0], '' contains syntax error(s)\\n'');\n',
         '      put(''near ... '''''', move(20) | rtab(0), '''''' ...\\n'')\n',
         '    fi\n',
         '  rof\n',
         ')\n'
     );
     stop(0);
  fi;
  if sem := file(semname,'r')fails then cant(semname) fi;
   scan sem
   for while put(find('{{'))
	  do var r, sub;
	     lit('{{');
	     put('#{{ ');
	     span(' \t\n') | '';
	     r := find('}}'); lit('}}');
	     scan r for
	        if sub := find('==')
		then
		   lit('==');
		   r := rtab(0);
		   put(sub, ' == ')
		else
		   sub := undefined
	        fi
	     rof;
	     put(r, '}}#\n');
	     if sub ~= undefined then
	        put('scan ', sub, ' for \n')
	     fi;
	     put(scan r for tagged_rule_body rof ) |
	     stand_er.put('ERROR IN: ', r, '\n');
	     if sub ~= undefined
	     then
		put(' & rpos(0)\nrof')
	     else
		put('\n')
	     fi;
	     put(' &  if ruletrace ~= 0 then put(''',  dupquotes_and_nl(r), ''')fi\n');
	  od;
       put(rtab(0));
   rof;
);
