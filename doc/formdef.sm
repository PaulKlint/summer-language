#****************************************************************
*                                                               *
* A formal definition of the SUMMER programming language.       *
* PART I: miscellaneous procedures and classes required for     *
*         the complete operationalization of the definition.    *
*         This includes the notion of "locations" and           *
*         environments, procdecls, classdecls, instances, etc.  *
* PART II:                                                      *
*         formal definition, in the form of the declarations:   *
*         eval_call, eval_field_selection and eval              *
*         a_string, a_integer, a_array, eval_array_init,        *
*         eval_table_init, has_field.                           *
* PART III:
          a small driver to apply the operational definition to *
*         some examples.                                        *
*                                                               *
* This definition is written in a subset of SUMMER except the   *
* expr == syntax-rule                                           *
* (enclosed in double braces { and } )                          *
* statements which are expanded in to appropriate SUMMER        *
* statements by means of a preprocessor.                        *
* Here follows PART I.                                          *
*                                                               *
PRO MEMORIE:
- expand_super_class.
- files ?
- programma argumenten
- standard names stand_in, stand_out, stand_er
- scope van formelen en procedure body dienen samen te vallen.
****************************************************************#

const N := 0,   # evaluation terminates Normally #
      F := 1,   # evaluation Fails #
      NR := 2,  # Normal Return required for result of evaluation #
      FR := 3;  # Failure Return required for result of evaluation #
var   pre, post;        # pre and post cursor values during parsing #
var   ENV,      # current environment #
      ENVglobal,        # global environment #
      STATE,    # the current state #
      varinit;  # text of variable initialization encountered so far #

var   ruletrace := 0;
var   ENVtrace    := 0;
var   EVALtrace   := 0;

# flex -- flexible arrays #

class flex ()
begin fetch update, retrieve, append, size, next, index;

      var mem, size;

      proc retrieve(i)
      if 0 <= i < size then return(mem[i]) else stop(-1) fi;

      proc update(i, v)
      if 0 <= i < size then return(mem[i] := v) else stop(-1) fi;

      proc append(v)
      ( if size >= mem.size then
           var i, m1 := array(mem.size + 10, undefined);
           for i in mem.index do m1[i] := mem[i] od;
           mem := m1
        fi;
        mem[size] := v;
        size := size + 1;
        return(v)
      );

      proc next(state)
      ( if state = undefined then
         state := 0
        fi;
        if state < size then
           return([mem[state], state + 1])
        else
           freturn
        fi
      );

      proc index()
      return(interval(0, size - 1, 1));

init: mem := array(10, undefined);
      size := 0;
end flex;

# environments realize the mapping between names and values.    #
# Names can be mapped on:                                       #
#       a_loc   a location, which models memory cells           #
#       a_proc                                          #
#               describes a procedure declaration               #
#       a_class                                         #
#               describes a class declaration                   #
#       a_composite_instance                                              #
#               a class instance, i.e. one particular           #
#               occurrence of an object belonging to that class #
#                                                               #
# Environments can be copied in two ways:                       #
#       name_copy                                               #
#               only copies the name parts of the environment   #
#               and hence the value parts are shared beteen the #
#               original and the new environment. This type of  #
#               copy is used, to switch to a new environment    #
#               in procedure calls, field selection etc.        #
#       partial_state_copy                                      #
#               copies all the name parts and all value parts   #
#               with a scope greater than the scope of the      #
#               current procedure. This is used to implement    #
#               the "try-construct". The values of variables    #
#               declared inside the current procedure are never #
#               restored if the try fails, but the values of    #
#               global variables are restores in that case.     #
#                                                               #
# The scope rules are also realised by environments:            #
#       new_inner_scope                                         #
#               start the scope of an inner block               #
#       new_proc_scope                                          #
#               starts a new procedure scope                    #
#                                                               #

class environment (proc_scope, inner_scope)
begin fetch bind, binding, has_binding, print, name_copy, partial_state_copy,
            names, proc_scope, inner_scope, new_proc_scope, new_inner_scope;
      store t;  # a pity; necessary to make copies of envs #
      var t := flex;

      proc lookup(name)
      ( var i;
        for i in interval(t.size-1, 0, -1)
        do var nm, k;
           [nm, k] := t[i];
           if {{ nm == <identifier> }} fails then
              put('Illegal id in env\n');
              print();
              stop(-1);
           fi;
           if nm = name then return(i) fi
        od;
        freturn;
      );

      proc bind(name, value)
      ( var i;
        if i := lookup(name) & i > inner_scope
        then
           put('\n"', name, '" redeclared\n"');
        else
           t.append([name, value])
        fi
       );

      proc binding(name)
      ( var i;
        if i := lookup(name) fails then put('\nname "', name, '" has no binding\n') fi;
        return(t[i][1])
      );

      proc has_binding(name) return(lookup(name));

      proc new_inner_scope() inner_scope := t.size;

      proc new_proc_scope() proc_scope := inner_scope := t.size;

      proc names()
      ( var i, a := array(t.size, undefined);
        for i in t.index do a[i] := t[i][0] od;
        return(a)
      );

      proc print ()
      ( var name, val, i, tp;
        put('\nENVIRONMENT:');
        put(' proc_scope: ', proc_scope, ' inner_scope: ', inner_scope, '\n');
        for i in t.index
        do [name, val] := t[i]; tp := type(val);
           put(name, '\t');
           if tp = 'string' then put('"', val, '"')
           elif tp = 'integer' then put('#', string(val))
           else
                val.print;
           fi;
           put('\n');
        od;
      );

      proc name_copy ()
      ( var r, cenv, entry;
        cenv := environment(proc_scope, inner_scope);
        r := flex;
        for entry in t do r.append(entry) od;
        cenv.t := r;
        return(cenv)
      );

      proc partial_state_copy()
      ( var r, cenv, i;
        cenv := environment(proc_scope, inner_scope);
        r := flex;
        put('Partial_state_copy:\n');
        for i in t.index
        do var name, value;
           [name, value] := t[i];
           put(name);
           if is_loc(value) & i <= proc_scope
           then
              value := STATE.extend(STATE.contents(value));
              put('\t new location\n');
           else
              put('\tshared\n');
           fi;
           r.append([name, value])
        od;
        cenv.t := r;
        return(cenv)
       );

end environment;

# locations, i.e. cells capable of holding one value #

class a_loc(contents)
begin fetch contents, print; store contents;
      proc print()
      ( put('a_loc('); put(contents.print, ')'); return(''));
end a_loc;

proc is_loc(l) return(type(l) = 'a_loc');

# state -- map locations into values #

class state ()
begin fetch extend, contents, modify;

      proc extend(v)
      ( return(a_loc(v)) );

      proc contents(l)
      ( return(l.contents) );

      proc modify(l, v)
      ( l.contents := v; return(l) );

end state;
# proc, i.e. describes one procedure declaration #

class a_proc(text, env)
begin fetch text, env, print;
      store env;
      proc print() (put('a_proc'); return(''));
end a_proc;

proc is_proc(a) return(type(a) = 'a_proc');

# class, i.e. describes one class declaration #
class a_class(name, text)
begin fetch name, text, print;
    proc print() (put('a_class(', name, ')'); return(''));
end a_class;

proc is_class(a) return(type(a) = 'a_class');

proc expand_super_class(c) return(c);

# instance, i.e. describes one class instance #

class a_composite_instance(class_decl, env)
begin fetch class_decl, env, print, same_as;

      proc print() (put('a_composite_instance'); return(''));
      proc same_as(x)
         return(is_composite_instance(x) & x = self);
end a_composite_instance;

proc is_composite_instance(v) return(type(v) = 'a_composite_instance');

proc is_basic_instance(v)
   return(is_integer(v) | is_string(v) | is_undefined(v));

proc is_instance(v)
   return(is_basic_instance(v) | is_composite_instance(v));

proc get_program_arguments() return(a_undefined);
proc string_equal(s1, s2) return(s1 = s2);

proc substring(s1, base, length) return(s1.substr(base, length));

#! ***** <equal> ***** #
proc equal(a, b)
( if is_integer(a) & is_integer(b)
  then
     return(a.intval = b.intval)
  elif is_string(a) & is_string(b)
  then
     return(string_equal(a.stringval, b.stringval))
  elif is_composite_instance(a) & is_composite_instance(b) & 
       string_equal(a.class_decl.name, b.class_decl.name)
  then
     return(a.same_as(b))
  else
     freturn
  fi
);
#!#
#!******* <dereference> ********#
proc dereference(val)
( if is_loc(val)
  then
     return(STATE.contents(val))
  else
     return(val)
  fi
);
#!#

proc ERROR()
( put('\nERROR\n'); ENV.print; stop(-1) );

#****************************************************************
*                                                               *
* PART II: the formal definition.                               *
*                                                               *
****************************************************************#

class a_undefined()
begin fetch operation, print, has;

      proc print() (put('a_undefined'); return(''));

      proc has(oper) freturn;

      proc operation(oper) ERROR;
end a_undefined;

proc is_undefined(v) return(type(v) = 'a_undefined');

class a_string(stringval)
begin fetch operation, stringval, print, has;

      proc print() (put('a_string(''', stringval, ''')'); return(''));

      proc has(oper)
        case oper of
        '||': '=': 'retrieve':
            return('')
        default:
            freturn
        esac;

      proc operation(oper, actuals)
      ( case oper of
                'size':
                if actuals.size ~= 0 then ERROR fi;
                return([a_integer(stringval.size), N]),
        '||':
                if actuals.size ~= 1 | ~ is_string(actuals[0]) then ERROR fi;
                return([a_string(stringval || actuals[0].stringval), N]),
        '=':
                if actuals.size ~= 1 | ~ is_string(actuals[0]) then ERROR fi;
                if stringval = actuals[0].stringval then
                   return([actuals[0], N])
                else
                   return([a_undefined, F])
                fi,
        'retrieve':
                if actuals.size ~= 1 | ~is_integer(actuals[0]) |
                   actuals[0].intval < 0 | actuals[0] >= stringval.size
                then
                   ERROR
                fi;
                return([a_string(stringval[actuals[0].intval]), N])
        default:
                put('Undefined string operations'); ERROR
        esac
     );
end a_string;

proc is_string(s) return(type(s) = 'a_string');

class a_integer(intval)
begin fetch operation, intval, print, has;

      proc print() (put('a_integer(', string(intval), ')'); return(''));

      proc has(oper)
        case oper of
        '+': '-': '*': '/': '%':
        '<': '<=': '=': '~=': '>': '>=':
           return('')
        default:
           freturn
        esac;

      proc operation(oper, actuals)
      ( var m, res;
        if oper = '-' & actuals.size = 0 then
           return([a_integer(-intval), N])
        else
           if actuals.size ~= 1 | ~ is_integer(actuals[0]) then ERROR fi;
           m := actuals[0].intval;
           case oper of
           '+':  res := intval + m,
           '-':  res := intval - m,
           '*':  res := intval * m,
           '/':  res := intval / m,
           '%':  res := intval % m,
           '<':  if intval < m then res := m else return([a_undefined, F]) fi,
           '<=': if intval <= m then res := m else return([a_undefined, F]) fi,
           '=':  if intval = m then res := m else return([a_undefined, F]) fi,
           '~=': if intval ~= m then res := m else return([a_undefined, F]) fi,
           '>=': if intval >= m then res := m else return([a_undefined, F]) fi,
           '>':  if intval > m then res := m else return([a_undefined, F]) fi
           default:
                put('Undefined operation on integer'); ERROR
           esac;
           return([a_integer(res), N])
        fi
      );
init: if type(intval) = 'string' then
         if scan intval for span('0123456789') & rpos(0) rof fails then ERROR fi;
         intval := integer(intval)
      elif type(intval) ~= 'integer' then ERROR fi;
end a_integer;

proc is_integer(n) return(type(n) = 'a_integer');

class a_array(n, def)
begin fetch operation, print, has;
      var ar;

      proc print()
      ( var a;
        put('a_array[');
        for a in ar do a.print; put(' ') od;
        put(']');
        return('')
      );

      proc has(oper)
        case oper of 'update': 'retrieve': 'size': return('')
        default: freturn
        esac;

      proc operation(oper, actuals)
      ( var v;
        case oper of
        'update': v := ar[actuals[0].intval] := actuals[1],
        'retrieve': v := ar[actuals[0].intval],
        'size': v := a_integer(n)
        esac;
        return([v, N])
      );
init: ar := array(n.intval, def)
end a_array;

proc is_array(a) return(type(a) = 'a_array');
#! ***** <eval_standard_procedure> *****#
proc eval_standard_procedure(procname, actuals)
( case procname
  of 'string':
         if actuals.size ~= 1 | ~is_string(actuals[0]) then ERROR fi;
         return(a_string(actuals[0].stringval)),
     'integer':
         if actuals.size ~= 1 | ~is_integer(actuals[0]) then ERROR fi;
         return(a_integer(actuals[0].intval)),
#-#  'array':
#-#      if actuals.size ~= 2 then ERROR fi;
#-#      return(a_array(actuals[0], actuals[1])),
     'undefined':
         if actuals.size ~= 0 then ERROR fi;
         return(a_undefined),
     'type':
         if actuals.size ~= 1 then ERROR fi;
         if is_string(actuals[0])
         then
            return(a_string('string'))
         elif is_integer(actuals[0])
         then
            return(a_string('integer'))
#-#      elif is_array(actuals[0])
#-#      then
#-#         return(a_string('array'))
         elif is_undefined(actuals[0])
         then
            return(a_string('undefined'))
         else
            # is_composite_instance(actuals[0]) #
            return(a_string(actuals[0].class_decl.name))
         fi
     esac
);

#! ***** <eval_call> *****#
proc eval_call(procname, actuals)
( var procdef;

  if procname = 'string' | procname = 'integer' |
     procname = 'undefined' | procname = 'type'
#-#  | procname = 'array'
  then
     return([eval_standard_procedure(procname, actuals), N])
  fi;
  procdef := ENV.binding(procname);
  if is_proc(procdef)
  then
     var body, ENV1, formals, i, v, sig;

     {{ procdef.text ==
             PROC  <identifier> '(' formals: {<identifier> ','}* ')'
             body: [<expression>] ';'
     }};
     if actuals.size ~= formals.size then ERROR fi;
     ENV1 := ENV;
     ENV := procdef.env.name_copy;
     ENV.new_proc_scope;
     for i in actuals.index
     do ENV.bind(formals[i], STATE.extend(actuals[i])) od;
     [v, sig] := eval(body);
     ENV := ENV1;
     case sig
     of N: NR:  return([v, N]),
        F: FR:  return([v, F])
     esac
  else
     # is_class(procdef) #
     var formals, decls, initexpr, ENV1, varinit1;
     var name, instance, d, v, sig, expr, i;

     {{ procdef.text ==
           CLASS <identifier> '(' formals:{<identifier> ','}* ')'
           BEGIN <fetch-associations> <store-associations>
           decls:  (  <variable-declaration> | <constant-declaration> |
                      <procedure-declaration> | <operator-declaration>
                   )*
           initexpr:  [INIT ':' <block>]
           END <identifier> ';'
     }};
     ENV1 := ENV;
     ENV := ENVglobal.name_copy;
     ENV.new_inner_scope;
     varinit1 := varinit;
     varinit := '';
     if actuals.size ~= formals.size then ERROR fi;
     for i in actuals.index
     do ENV.bind(formals[i], STATE.extend(actuals[i])) od;

     for d in decls
     do [v, sig] := eval(d);
        if sig ~= N then ERROR fi
     od;
     for name in ENV.names
     do var b := ENV.binding(name);
        if is_proc(b) & b.env = undefined then b.env := ENV fi
     od;

     instance := a_composite_instance(procdef, ENV);
     ENV.bind('self', instance);
     [v, sig] := eval(varinit);
     varinit := varinit1;
     if sig ~= N
     then
        ENV := ENV1;
        case sig
        of F:   ERROR,
           FR:  return([v, F]),
           NR:  return([v, N])
        esac
     fi;
     if {{ initexpr == INIT ':' expr:<block> }}
     then
        ENV.new_proc_scope;
        [v, sig] := eval(expr);
     else
        [v, sig] := [a_undefined, N]
     fi;
     ENV := ENV1;
     case sig
     of F: FR:  return([v, F]),
        N: NR:  return([instance, N])
     esac
  fi
);
#! ***** <has_field> *****#
proc has_field(access_type, instance, field)
( var flist, slist, list, f, p, a;

  if is_basic_instance(instance)
#-#  | is_array(instance)
  then
     return(instance.has(field))
  fi;
  if ~ is_composite_instance(instance) then freturn fi;
  {{ instance.class_decl.text ==
           CLASS <identifier> <formals>
           BEGIN FETCH flist:{<association> ','}+ ';'
                 STORE slist:{<association> ','}+ ';'
                 (  <variable-declaration> | <constant-declaration> |
                    <procedure-declaration> | <operator-declaration>
                 )*
                 [INIT ':' <block>]
           END <identifier> ';'
  }};
  list := if access_type = 'fetch' then flist else slist fi;
  for a in list
  do if {{ a == f:<field-identifier> [':' <identifier> ] }} &
        string_equal(field, f)
     then
        return
#-# ('');
     fi
  od;
  freturn
);

#! ***** <eval_field_selection> *****#
proc eval_field_selection(access_type, instance, field, actuals)
( var flist, slist, list, v, sig, f, ENV1, p, a;

  if is_basic_instance(instance)
#-#  | is_array(instance)
  then
     return(instance.operation(field, actuals))
  fi;
  if ~ is_composite_instance(instance) then ERROR fi;
  {{ instance.class_decl.text ==
           CLASS <identifier> <formals>
           BEGIN FETCH flist:{<association> ','}+ ';'
                 STORE slist:{<association> ','}+ ';'
                 (  <variable-declaration> | <constant-declaration> |
                    <procedure-declaration> | <operator-declaration>
                 )*
                 [INIT ':' <block>]
           END <identifier> ';'
  }};
  ENV1 := ENV;
  ENV := instance.env;
  list := if access_type = 'fetch' then flist else slist fi;
  for a in list
  do if {{ a == f:<field-identifier> }} & string_equal(field, f)
     then
        if is_loc(ENV.binding(f))
        then
           if access_type = 'fetch'
           then
              if actuals.size ~= 0 then ERROR fi;
              v := dereference(ENV.binding(f));
              ENV := ENV1;
              return([v, N])
           else
              if actuals.size ~= 1 then ERROR fi;
              v := actuals[0];
              STATE.modify(ENV.binding(f), v);
              ENV := ENV1;
              return([v, N])
           fi
        else
           if access_type = 'fetch'
           then
              [v, sig] := eval_call(f, actuals);
              ENV := ENV1;
              return([v, sig])
           else
              ERROR
           fi
        fi;
     elif {{ a == f:<field-identifier> ':' p:<identifier> }} &
          string_equal(field, f)
     then
          [v, sig] := eval_call(p, actuals);
          ENV := ENV1;
          return([v, sig])
     fi
  od;
  ERROR
);
#! ***** <eval_array_init> *****#
proc eval_array_init(sz, def, initexpr)
( var ar, exprlist, i, v, v1, sig;

  [ar, sig] := eval_call('array', [sz, def]);
  if sig ~= N then return([ar, sig]) fi;
  {{ initexpr == INIT '[' exprlist:{<expression> ',' }* ']' }};
  for i in exprlist.index
  do [v,sig] := eval(exprlist[i]);
     if sig ~= N then return([v, sig]) fi;
     v := dereference(v);
     [v1, sig] := eval_field_selection('fetch', ar, 'update', [a_integer(i), v]);
     if sig ~= N then return([v1, sig]) fi;
  od;
  return([ar, N])
);
#! ***** <eval_table_init> *****#
proc eval_table_init(sz, def, initexpr)
( var tb, sig, v, expr, exprlist;

  [tb, sig] := eval_call('table', [sz, def]);
  if sig ~= N then return([tb, sig]) fi;
  {{ initexpr == INIT '[' exprlist:{<table-element> ',' }* ']' }};
  for expr in exprlist
  do var ar, k, key, keylist, expr1, v1;

     {{ expr == keylist:{<expression> ':'}+ ':' expr1:<expression> }};
     ar := array(keylist.size, undefined);
     for k in keylist.index
     do [v, sig] := eval(keylist[k]);
        if sig ~= N then return([v, sig]) fi;
        ar[k] := dereference(v);
     od;
     [v1, sig] := eval(expr1);
     if sig ~= N then return([v1, sig]) fi;
     v1 := dereference(v1);
     for key in ar
     do [v, sig] := eval_field_selection('fetch', tb, 'update', [key, v1]);
        if sig ~= N then return([v, sig]) fi;
     od
  od;
  return([tb, N])
);
#!#
# require_constant_expression                                   #
# check that all identifiers occurring in a <constant-expression> #
# are indeed declared by constant declarations                  #

#! ***** <req_constant_expression> ***** #
proc require_constant_expression(e)
( var se1, se2, name, tail, ce, c;

  {{ e ==  se1:   <simple-constant-expression>
           tail:  (<constant-operator> <constant-expression>)*
  }};
  if {{ se1 == <constant> }}
  then
     # ok #
  elif {{ se1 == name:<identifier> }}
  then
     if ~is_integer(ENV.binding(name)) & ~is_string(ENV.binding(name))
     then
        ERROR
     fi
  elif {{ se1 == '-' se2: <simple-constant-expression> }}
  then
     require_constant_expression(se2)
  elif {{ se1 == '(' ce:<constant-expression> ')' }}
  then
     require_constant_expression(ce)
  fi;
  for c in tail
  do {{ c == <constant-operator> ce:<constant-expression> }} ;
     require_constant_expression(ce)
  od
);
#!#
#                                                               #
# eval -- main interpreter routine                              #
#                                                               #
# eval evaluates its argument "e" and delivers the tuple        #
# [value, signal] as value. "value" is the result of evaluation #
# of expression or program "e". "signal" is a succeed/fail flag #
# with the following possible values:                           #
#       N       evaluation terminated normally                  #
#       F       evaluation failed                               #
#       NR      normal return from procedure                    #
#       FR      fail return from procedure                      #
# The signal is tested after each invocation of eval.           #
# In most cases eval performs an immediate return if signal is  #
# not equal to N after the evaluation of a subexpression.       #
# Exceptions are cases as <if-expression>, <while-expression> in which  #
# signals are manipulated explicitly. This organization has the #
# advantage, that aborting the evaluation of the current        #
# expression (necessary if failure occurs in a deeply nested    #
# subexpression) can be achieved by passing "signal" upwards to #
# that incarnation of eval that feels like taking appropriate   #
# counter measures.                                             #


proc eval(e)
(
#
  var e0, e1, e2, e3, ei, ex, elist;
  var p, body, k, field, x,
      f, b, l, dop, mop, cname, left, right, name,
      c, d, dlist, s, slist, sz, t;
  var a, a1, alist;
  var v, v0, v1, v2, v3, vi;
  var ENV1, i, sig;
#

  var varlist, constlist;
  var decllist, progdecl;
  var id;
  var act;
  var cname1, cname2;
  var expr;
  var elsepart, elifpart, sf;
  var def, caselist;
  var b, t;
  var u;
  var expr1, expr2, initexpr;
  var field;
  var mop, dop;
  var exprlist;


  if EVALtrace ~= 0 then put('EVAL: ', e, '\n') fi;
  if ENVtrace ~= 0 then ENV.print; fi;


#!****** <operator-symbol-declaration> ***********#
if {{ e == (MONADIC | DYADIC) { <operator-symbol> ',' }+ ';' }}
then
   return([a_undefined, N])

#!***** <var-decl> **************#

elif {{ e == VAR varlist:{<variable-initialization> ',' }+ ';' }}
then
   var name, onevar;

   for onevar in varlist
   do if {{ onevar == name:<identifier> ':=' <expression> }}
      then
         varinit := varinit || onevar || ';'
      else
         {{ onevar == name:<identifier> }}
      fi;
      ENV.bind(name, STATE.extend(a_undefined))
   od;
   return([a_undefined, N])
#!***** <constant-declaration> ************#

elif {{ e == CONST constlist:{<constant-initialization> ',' }+ ';' }}
then
   var cexpr, name, oneconst, v, sig;

   for oneconst in constlist
   do {{ oneconst == name:<identifier> ':=' cexpr:<constant-expression> }};
      require_constant_expression(cexpr);
      [v, sig] := eval(cexpr);
      if sig ~= N then ERROR fi;
      ENV.bind(name, v);
   od;
   return([a_undefined, N])
#!****** <procedure-declaration> | <operator-declaration> #

elif {{ e == PROC id:<identifier> <formals> [<expression>] ';' }} |
   {{ e == OP id:<operator-symbol> <formals> [<expression>] ';' }}
then
   ENV.bind(id, a_proc(e, undefined));
   return([a_undefined, N])
#!****** <class-declaration> ***********#

elif {{ e == CLASS cname1:<identifier> <formals>
           BEGIN <subclass-declaration>
                 <fetch-associations> <store-associations>
                 (  <variable-declaration> | <constant-declaration> |
                    <procedure-declaration> | <operator-declaration>
                 )*
                 [INIT ':'  <block>]
           END cname2:<identifier> ';' }}
then
   var e1;

   e1 := expand_super_class(e);
   if ~string_equal(cname1, cname2) then ERROR fi;
   ENV.bind(cname1, a_class(cname1, e1));
   return([a_undefined, N])
#!****** <summer-program> *******#

elif {{ e == decllist:  (  <variable-declaration> | <constant-declaration> |
                         <procedure-declaration> | <operator-declaration> |
                         <class-declaration> | <operator-symbol-declaration>
                      )*
           progdecl:  <program-declaration> }}
then
   var body, decl, name, progargs, v, sig;

   varinit := '';
   for decl in decllist
   do [v, sig] := eval(decl);
      if sig ~= N then ERROR fi
   od;
   for name in ENV.names
   do var b := ENV.binding(name);
      if is_proc(b) then b.env := ENV fi
   od;
   ENVglobal := ENV;
   [v, sig] := eval(varinit);
   if sig ~= N then ERROR fi;
   {{ progdecl == PROGRAM <identifier> '(' progargs:[<identifier>] ')'
                  body:[<expression>]
   }};
   ENV.new_proc_scope;
   if {{ progargs == <identifier> }}
   then
      ENV.bind(progargs, STATE.extend(get_program_arguments))
   fi;
   [v, sig] := eval(body);
   return([v, sig]);
#!****** <if-expression> ******#

elif {{ e == IF t:<test> THEN b:<block>
           elifpart: (ELIF <test> THEN <block>)*
           elsepart: [ELSE <block>] FI }}
then
   var v, sig;
   [v, sig] := eval(t);
   if sig = N
   then
      return(eval(b))
   elif sig = NR | sig = FR
   then
      return([v, sig])
   else
      var oneelif;
      for oneelif in elifpart
      do {{ oneelif == ELIF t:<test> THEN b:<block> }} ;
         [v, sig] := eval(t);
         if sig = N
         then
            return(eval(b))
         elif sig = NR | sig = FR
         then
            return([v, sig])
         fi
      od;
      if {{ elsepart == ELSE b:<block> }}
      then
         return(eval(b))
      else
         return([a_undefined, N])
      fi
   fi
#!******* <while-expression> **#

elif {{ e == WHILE t:<test> DO b:<block> OD }}
then
   var v, sig;

   [v, sig] := eval(t);
   case sig
   of N:         # do nothing #,
      F:         return([v, N]),
      NR: FR:    return([v, sig])
   esac;
   [v, sig] := eval(b);
   if sig ~= N then return([v, sig]) fi;
   return(eval(e))
#!******* <for-expression> ****#

elif {{e == FOR id:<identifier> IN expr:<expression> DO b:<block> OD }}
then
   var gen, v, sig, state;

   if ~ is_loc(ENV.binding(id)) then ERROR fi;
   [gen, sig] := eval(expr);
   if sig ~= N then return([gen, sig]) fi;
   gen := dereference(gen);
   state := a_undefined;
   while [state, sig] := eval_field_selection('fetch', gen, 'next', [state]) & sig = N
   do
      [v, sig] := eval_field_selection('fetch', state, 'retrieve', [a_integer(0)]);
      if sig ~= N then ERROR fi;
      STATE.modify(ENV.binding(id), v);
      [state, sig] := eval_field_selection('fetch', state, 'retrieve', [a_integer(1)]);
      if sig ~= N then ERROR fi;
      [v, sig] := eval(b);
      if sig ~= N then return([v, sig]) fi;
   od;
   return([a_undefined, N]);
#!******* <case-expression> ***#

elif {{ e == CASE expr:  <expression> OF
           caselist:   {<case-entry> ','}*
           def:        [DEFAULT ':' <block>] ESAC }}
then
   var b, onecase, v1, v2, sig;

   [v1, sig] := eval(expr);
   if sig ~= N then return([v1, sig]) fi;
   v1 := dereference(v1);
   for onecase in caselist
   do var onekey, keylist;

      {{ onecase == keylist:{<constant-expression> ':'}+ b:<block> }};
      for onekey in keylist
      do require_constant_expression(onekey);
         [v2, sig] := eval(onekey);
         if sig ~= N then ERROR fi;
         if equal(v1, v2) then return(eval(b)) fi
      od
   od;
   if {{ def == DEFAULT ':' b:<block> }}
   then
      return(eval(b))
   else
      ERROR
   fi
#!******* <scan-expression> ***#

elif {{ e == SCAN expr:<expression> FOR b:<block> ROF }}
then
   var ENV1, v, sig;

   [v, sig] := eval(expr);
   if sig ~= N then return([v, sig]) fi;
   v := dereference(v);
   if is_string(v)
   then
      [v, sig] := eval_call('scan_string', [v])
   fi;
   ENV1 := ENV;
   ENV := ENV.name_copy;
   ENV.new_inner_scope;
   ENV.bind('subject', v);
   [v, sig] := eval(b);
   ENV := ENV1;
   return([v, sig])
#!******* <try-expression> ****#

elif {{ e == TRY exprlist:{<expression> ','}+ u:[UNTIL <block>] YRT }}
then
   var b, ENV1, expr, v, sig;
   ENV1 := ENV;
   for expr in exprlist
   do ENV := ENV.partial_state_copy;
      [v, sig] := eval(expr);
      case sig
      of F:   ENV := ENV1,
         FR:  ENV := ENV1; return([v, FR]),
         NR:  return([v, NR]),
         N:   if {{ u == UNTIL b:<block> }}
              then
                 [v, sig] := eval(b);
                 case sig
                 of F:   ENV := ENV1,
                    FR:  ENV := ENV1; return([v, FR]),
                    NR:  return([v, NR]),
                    N:   return([v, N])
                 esac
              else
                 return([v, N])
              fi
      esac
   od;
   return([a_undefined, F])
#!******* <assert-expression> *#

elif {{ e == ASSERT expr:<expression> }}
then
   var v, sig;

   [v, sig] := eval(expr);
   if sig ~= N then ERROR fi;
   return([v, sig])
#!#

#****************************************************************
*                                                               *
*       E X P R E S S I O N    E V A L U A T I O N              *
*                                                               *
****************************************************************#
#! ***** <expr:undefined> *****#
elif {{ e == UNDEFINED }}
then
   return([a_undefined, N])
#! ***** <expr:integer> *****#
elif {{ e == expr:<integer-constant> }}
then
   return([a_integer(expr), N])
#! ***** <expr:string> *****#
elif {{ e == expr:<string-constant> }}
then
   expr := substring(expr, 1, expr.size - 2);
   return([a_string(expr), N])
#! ***** <expr:real> *****#
elif {{ e == expr:<real-constant> }}
then
   return(eval_call('real', a_string(expr)))
#! ***** <select> ***** #
elif {{ e == expr1:<identifier> '.' field:<identifier> act: [<actuals>] }}
then
   var actual_vals, v1, sig;

   [v1, sig] := eval(expr1);
   if sig ~= N then return([v1, sig]) fi;
   v1 := dereference(v1);
   if {{ actuals == '(' exprlist: {<expression> ','}* ')' }}
   then
      var i, exprlist, v;

      actual_vals := array(exprlist.size, undefined);
      for i in exprlist.index
      do [v, sig] := eval(exprlist[i]);
         if sig ~= N then return([v, sig]) fi;
         actual_vals[i] := dereference(v)
      od
   else
      actual_vals := array(0, undefined)
   fi;
   return(eval_field_selection('fetch', v1, field, actual_vals));
#! ***** <subscript> *****#
elif {{ e == expr1:<identifier> '[' expr2:<expression> ']' }}
then
   var v1, v2, sig;

   [v1, sig] := eval(expr1);
   if sig ~= N then return([v1, sig]) fi;
   v1 := dereference(v1);
   [v2, sig] := eval(expr2);
   if sig ~= N then return([v2, sig]) fi;
   v2 := dereference(v2);
   return(eval_field_selection('fetch', v1, 'retrieve', [v2]))
#!#

#********************* C A L L ******************************#

#! ***** <call> *****#
elif {{ e == id:<identifier> act:[<actuals>] }}
then
   var actual_vals, exprlist;

   if {{ act == '(' exprlist:{<expression> ',' }* ')' }}
   then
      var i, v, sig;

      actual_vals := array(exprlist.size, undefined);
      for i in exprlist.index
      do [v, sig] := eval(exprlist[i]);
         if sig ~= N then return([v, sig]) fi;
         actual_vals[i] := dereference(v);
      od;
   else
      actual_vals := array(0, undefined);
   fi;
   if ENV.has_binding(id)
   then
      var idbinding := ENV.binding(id);

      if is_instance(idbinding) | is_loc(idbinding) 
      then
         if {{ e == <identifier> }}
         then
            return([idbinding, N])
         else
            ERROR
         fi
      elif is_proc(idbinding) | is_class(idbinding)
      then
         return(eval_call(id, actual_vals))
      else
         ERROR
      fi
   else
      return(eval_field_selection('fetch', ENV.binding('subject'), id, actual_vals))
   fi
#! ***** <return1> *****#
elif {{ e == RETURN '(' expr:<expression> ')' }}
then
   var v, sig;

   [v, sig] := eval(expr);
   v := dereference(v);
   case sig
   of N: NR:  return([v, NR]),
      F: FR:  return([v, FR])
   esac
#! ***** <return0> *****#
elif {{ e == RETURN }}
then
   return([a_undefined, NR])
#! ***** <freturn> *****#
elif {{ e == FRETURN }}
then
   return([a_undefined, FR])
#!#
#**************** D Y A D I C   O P E R A T O R S ********************#

#! ***** <dyadic-expr> *****#
elif {{ e == expr1:  <monadic-expression> 
           dop:    <dyadic-operator> expr2: <monadic-expression> }}
then
   var left, right, sig;

   if {{ dop == ':=' }}
   then
      var exprlist, field, sub, u, vu, vs;

      [right, sig] := eval(expr2);
      if sig ~= N then return([right, sig]) fi;
      right := dereference(right);
      if {{ expr1 == u:<unit> '.' field:<identifier> }}
      then     # Case 2a. (field selection) #
         [vu, sig] := eval(u);
         if sig ~= N then return([vu, sig]) fi;
         vu := dereference(vu);
         return(eval_field_selection('store', vu, field, [right]));
      elif {{ expr1 == u:<unit> '[' sub:<expression> ']' }}
      then     # Case 2b. (subscription) #
         [vu, sig] := eval(u);
         if sig ~= N then return([vu, sig]) fi;
         vu := dereference(vu);
         [vs, sig] := eval(sub);
         if sig ~= N then return([vs, sig]) fi;
         vs := dereference(vs);
         return(eval_field_selection('fetch', vu, 'update', [vs, right]))
      elif {{ expr1 == '[' exprlist:{<expression> ','}+ ']' }}
      then     # Case 2c. (multiple assignment) #
         var i, vi, v;

         for i in exprlist.index
         do [vi, sig] := eval(exprlist[i]);
            if sig ~= N then return([vi, sig]) fi;
            if ~ is_loc(vi) then ERROR fi;
            [v, sig] :=
            eval_field_selection('fetch', right, 'retrieve', [a_integer(i)]);
            if sig ~= N then return([v, sig]) fi;
            STATE.modify(vi, v);
         od;
         return([vi, N])
      else     # Case 2d. (simple assignment) #
         [left, sig] := eval(expr1);
         if sig ~= N then return([left, sig]) fi;
         if ~is_loc(left) then ERROR fi;
         STATE.modify(left, right);
         return([right, N])
      fi
   else        # Case 3. operator unequal `:=' #
      [left, sig] := eval(expr1);
      if string_equal(dop, '|')
      then
         if sig ~= F then return([left, sig]) fi
      else
         if sig ~= N then return([left, sig]) fi
      fi;
      [right, sig] := eval(expr2);
      if sig ~= N | string_equal(dop, '|') | string_equal(dop, '&')
      then
         return([right, sig])
      fi;
      left := dereference(left);
      right := dereference(right);
      if has_field('fetch', left, dop)
      then     # Case 3a. #
         return(eval_field_selection('fetch', left, dop, [right]))
      elif ENV.has_binding(dop) & is_proc(ENV.binding(dop))
      then     # Case 3b. #
         return(eval_call(dop, [left, right]))
      elif dop = '=' | dop = '~='
      then     # Case 3c. #
         sig := if equal(left, right) then N else F fi;
         if dop = '~='
         then
            sig := if sig = N then F else N fi
         fi;
         return([right, sig])
      else
         ERROR
      fi
   fi
#!#

#**************** M O N A D I C  O P E R A T O R S *******************#

#! ***** <monadic-expr> *****#
elif {{ e == mop:<monadic-operator> expr:<primary> }}
then
   var v, sig;

   [v, sig] := eval(expr);
   if string_equal(mop, '~')
   then
      case sig
      of N:         return([a_undefined, F]),
         F:         return([a_undefined, N]),
         FR: NR:    return([v, sig])
      esac
   elif sig ~= N
   then
      return([v, sig])
   fi;
   v := dereference(v);
   if has_field('fetch', v, mop)
   then
      return(eval_field_selection('fetch', v, mop, []))
   elif ENV.has_binding(mop) & is_proc(ENV.binding(mop))
   then
      return(eval_call(mop, [v]))
   else
      ERROR
   fi
#! ***** <array1> *****#
elif {{ e == ARRAY '(' expr1:<expression> ',' expr2:<expression> ')' 
           initexpr:  [INIT <array-initialization> ] }}
then
   var def, sz, sig;

   [sz, sig] := eval(expr1);
   if sig ~= N then return([sz, sig]) fi;
   sz := dereference(sz);
   [def, sig] := eval(expr2);
   if sig ~= N then return([def, sig]) fi;
   def := dereference(def);
   return(eval_array_init(sz, def, initexpr));
#! ***** <array2> *****#
elif {{ e == '[' exprlist:{<expression> ','}* ']' }}
then
   return(eval_array_init(a_integer(exprlist.size), a_undefined, 'init' || e));
#! ***** <table1> *****#
elif {{ e == TABLE '(' expr1:<expression> ',' expr2:<expression> ')'
           initexpr: [INIT <table-initialization>] }}
then
   var def, sig, sz;

   [sz, sig] := eval(expr1);
   if sig ~= N then return([sz, sig]) fi;
   sz := dereference(sz);
   [def, sig] := eval(expr2);
   if sig ~= N then return([def, sig]) fi;
   def := dereference(def);
   return(eval_table_init(sz, def, initexpr));
#! ***** <table2> *****#
elif {{ e == '[' exprlist:{<table-element> ','}* ']' }}
then
   return(eval_table_init(a_integer(exprlist.size), a_undefined, 'init' || e))
#!******* <empty> *******#

elif {{ e == <empty> }}
then
   return([a_undefined, N])
#!******* <parenthesized-expression> ****#

elif {{ e == '(' b:<block> ')' }}
then
   return(eval(b))
#!******* <block> *******#

elif {{ e == decllist:  (<variable-declaration>|<constant-declaration>)*
           exprlist:  {[<expression>] ';'}* }}
then
   var decl, expr, ENV1, v, varinit1, sig;

   ENV1 := ENV;
   ENV  := ENV.name_copy;
   ENV.new_inner_scope;
   varinit1 := varinit;
   varinit := '' ;
   for decl in decllist do [v, sig] := eval(decl) od;
   [v, sig] := eval(varinit);
   varinit := varinit1;
   if sig ~= N
   then
      ENV := ENV1;
      if sig = F then ERROR else return([v, sig]) fi
   fi;
   if exprlist.size = 0
   then
      ENV := ENV1;
      return([a_undefined, N])
   else
      var i;

      for i in exprlist.index
      do [v, sig] := eval(exprlist[i]);
         case sig
         of N:         # do nothing #,
            F:         if i ~= exprlist.size - 1 then ERROR fi,
            NR: FR:    ENV := ENV1; return([v, sig])
         esac
      od;
      ENV := ENV1;
      return([v, sig])
   fi
#!******* <test> ********#

elif {{ e == expr:<expression> sf: (SUCCEEDS | FAILS) }}
then
   if {{ sf == SUCCEEDS }}
   then
      return(eval(expr))
   else
      var v, sig;

      [v, sig] := eval(expr);
      case sig
      of F:         return([v, N]),
         N:         return([v, F]),
         FR: NR:    return([v, sig])
      esac
   fi
#!#
else
   ERROR
fi
); # end of eval #
#****************************************************************
*                                                               *
* PART III: the driver.                                         *
*                                                               *
****************************************************************#

program summer_interpreter (args)
(  var p := '', a, f := stand_in;
   for a in args
   do
      case a of
      '-T': ruletrace := 1,
      '-ENV': ENVtrace := 1,
      '-EVAL': EVALtrace := 1
      default: f := file(a, 'r')
      esac
   od;
   if f = undefined then
      put('No program\n')
   else
      while p := p || f.get || '\n' do od;
      ENVglobal := ENV := environment(0, 0);
      STATE := state;
      varinit := '';
      ENV.bind('subject', a_undefined);
      eval(p);
      ENV.print;
   fi;
)
